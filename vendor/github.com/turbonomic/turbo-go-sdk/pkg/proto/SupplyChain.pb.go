// Code generated by protoc-gen-go. DO NOT EDIT.
// source: SupplyChain.proto

package proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TemplateDTO_TemplateType int32

const (
	TemplateDTO_BASE      TemplateDTO_TemplateType = 0
	TemplateDTO_EXTENSION TemplateDTO_TemplateType = 1
)

var TemplateDTO_TemplateType_name = map[int32]string{
	0: "BASE",
	1: "EXTENSION",
}
var TemplateDTO_TemplateType_value = map[string]int32{
	"BASE":      0,
	"EXTENSION": 1,
}

func (x TemplateDTO_TemplateType) Enum() *TemplateDTO_TemplateType {
	p := new(TemplateDTO_TemplateType)
	*p = x
	return p
}
func (x TemplateDTO_TemplateType) String() string {
	return proto.EnumName(TemplateDTO_TemplateType_name, int32(x))
}
func (x *TemplateDTO_TemplateType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TemplateDTO_TemplateType_value, data, "TemplateDTO_TemplateType")
	if err != nil {
		return err
	}
	*x = TemplateDTO_TemplateType(value)
	return nil
}
func (TemplateDTO_TemplateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor9, []int{0, 0} }

type Provider_ProviderType int32

const (
	// HOSTING is a To One relationship toward the provider, and it enforces containment.
	// This means that if the provider is removed, then every contained consumer will also be removed.
	Provider_HOSTING Provider_ProviderType = 0
	// LAYERED_OVER is a To Many relationship toward the provider, without containment.
	Provider_LAYERED_OVER Provider_ProviderType = 1
)

var Provider_ProviderType_name = map[int32]string{
	0: "HOSTING",
	1: "LAYERED_OVER",
}
var Provider_ProviderType_value = map[string]int32{
	"HOSTING":      0,
	"LAYERED_OVER": 1,
}

func (x Provider_ProviderType) Enum() *Provider_ProviderType {
	p := new(Provider_ProviderType)
	*p = x
	return p
}
func (x Provider_ProviderType) String() string {
	return proto.EnumName(Provider_ProviderType_name, int32(x))
}
func (x *Provider_ProviderType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Provider_ProviderType_value, data, "Provider_ProviderType")
	if err != nil {
		return err
	}
	*x = Provider_ProviderType(value)
	return nil
}
func (Provider_ProviderType) EnumDescriptor() ([]byte, []int) { return fileDescriptor9, []int{2, 0} }

// The type of the matching value we will use.  String or List<String>
type MergedEntityMetadata_ReturnType int32

const (
	MergedEntityMetadata_STRING      MergedEntityMetadata_ReturnType = 1
	MergedEntityMetadata_LIST_STRING MergedEntityMetadata_ReturnType = 2
)

var MergedEntityMetadata_ReturnType_name = map[int32]string{
	1: "STRING",
	2: "LIST_STRING",
}
var MergedEntityMetadata_ReturnType_value = map[string]int32{
	"STRING":      1,
	"LIST_STRING": 2,
}

func (x MergedEntityMetadata_ReturnType) Enum() *MergedEntityMetadata_ReturnType {
	p := new(MergedEntityMetadata_ReturnType)
	*p = x
	return p
}
func (x MergedEntityMetadata_ReturnType) String() string {
	return proto.EnumName(MergedEntityMetadata_ReturnType_name, int32(x))
}
func (x *MergedEntityMetadata_ReturnType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MergedEntityMetadata_ReturnType_value, data, "MergedEntityMetadata_ReturnType")
	if err != nil {
		return err
	}
	*x = MergedEntityMetadata_ReturnType(value)
	return nil
}
func (MergedEntityMetadata_ReturnType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor9, []int{4, 0}
}

//
// The TemplateDTO message represents entity types (templates) that the probe expects to
// discover in the target. For the probe to load in Operations Manager, it must discover
// entity types that are valid members of the supply chain, and these entities must have
// valid buy/sell relationships. Specifying the set of templates for a probe serves to
// validate that the specific entities the probe discovers and sends to Operations Manager do
// indeed match the entity descriptions the probe is expected to discover.
//
// Specify entity type by setting an EntityType value to the templateClass field.
//
// An entity can maintain a list of commodities that it sells.
//
// An entity can maintain a map of commodities bought (TemplateCommodity objects). Each map key is
// an instance of Provider. For each provider, the map entry is a list of the commodities bought
// from that provider.
//
// The templateType can be either {@code Base} or
// Extension (see TemplateType).
//
// A Base template indicates the initial representation
// of an entity, which means this probe performs the primary discovery of the entity and places it in the market.
// Note that there can be more than one probe that discovers the same Base entity. The template has a
// templatePriority setting that resolves such a collision. The template with the highest priority value
// wins, and discoveries made for the lower-priority template are ignored.
//
// An extension template adds data to already discovered entities. This is a way to extend the
// commodities managed by a base template.
//
type TemplateDTO struct {
	// The type of entity that the template represents. See EntityType
	// for the available types.
	TemplateClass *EntityDTO_EntityType `protobuf:"varint,1,req,name=templateClass,enum=common_dto.EntityDTO_EntityType" json:"templateClass,omitempty"`
	// The template type (Base or Extension), used during the validation process.
	TemplateType *TemplateDTO_TemplateType `protobuf:"varint,2,req,name=templateType,enum=common_dto.TemplateDTO_TemplateType" json:"templateType,omitempty"`
	// The priority of a Base template. For equivalent Base templates, Operations Manager uses the highest-priority
	// template, and discards discovered data from lower-priority Base templates.
	TemplatePriority *int32 `protobuf:"varint,3,req,name=templatePriority" json:"templatePriority,omitempty"`
	// This entity's list of {@link TemplateCommodity} items that it provides.
	CommoditySold []*TemplateCommodity `protobuf:"bytes,5,rep,name=commoditySold" json:"commoditySold,omitempty"`
	// The commodities bought from the different providers.
	// This Map contains the commodities bought where:
	CommodityBought []*TemplateDTO_CommBoughtProviderProp `protobuf:"bytes,6,rep,name=commodityBought" json:"commodityBought,omitempty"`
	// A map that defines the entity types that will be providers or consumers for this template entity.
	// The entry key is an entity type, from the EntityType enumeration. There can only be
	// one instance of each entity type in this map. The entry value is an instance of
	// ExternalEntityLink. Each entity link describes an entity type in the supply chain,
	// and the commodities it buys from or sells to the template entity.
	ExternalLink []*TemplateDTO_ExternalEntityLinkProp `protobuf:"bytes,7,rep,name=externalLink" json:"externalLink,omitempty"`
	// Each set represents a case where the entity must buy one commodity of the set ( a logical or of the set)
	// Note, the entity may buy more than one of the commodities in the set.
	CommBoughtOrSet []*TemplateDTO_CommBoughtProviderOrSet `protobuf:"bytes,8,rep,name=commBoughtOrSet" json:"commBoughtOrSet,omitempty"`
	// If this template represents an entity class that will be a proxy entity,
	// add MergedEntityMetadata that defines how to identify the matching entity in the server and
	// also what data from the proxy entity to copy over to the matching entity.
	// For details see the comment with the message definition of MergedEntityMetadata.
	MergedEntityMetaData *MergedEntityMetadata `protobuf:"bytes,9,opt,name=mergedEntityMetaData" json:"mergedEntityMetaData,omitempty"`
	XXX_unrecognized     []byte                `json:"-"`
}

func (m *TemplateDTO) Reset()                    { *m = TemplateDTO{} }
func (m *TemplateDTO) String() string            { return proto.CompactTextString(m) }
func (*TemplateDTO) ProtoMessage()               {}
func (*TemplateDTO) Descriptor() ([]byte, []int) { return fileDescriptor9, []int{0} }

func (m *TemplateDTO) GetTemplateClass() EntityDTO_EntityType {
	if m != nil && m.TemplateClass != nil {
		return *m.TemplateClass
	}
	return EntityDTO_SWITCH
}

func (m *TemplateDTO) GetTemplateType() TemplateDTO_TemplateType {
	if m != nil && m.TemplateType != nil {
		return *m.TemplateType
	}
	return TemplateDTO_BASE
}

func (m *TemplateDTO) GetTemplatePriority() int32 {
	if m != nil && m.TemplatePriority != nil {
		return *m.TemplatePriority
	}
	return 0
}

func (m *TemplateDTO) GetCommoditySold() []*TemplateCommodity {
	if m != nil {
		return m.CommoditySold
	}
	return nil
}

func (m *TemplateDTO) GetCommodityBought() []*TemplateDTO_CommBoughtProviderProp {
	if m != nil {
		return m.CommodityBought
	}
	return nil
}

func (m *TemplateDTO) GetExternalLink() []*TemplateDTO_ExternalEntityLinkProp {
	if m != nil {
		return m.ExternalLink
	}
	return nil
}

func (m *TemplateDTO) GetCommBoughtOrSet() []*TemplateDTO_CommBoughtProviderOrSet {
	if m != nil {
		return m.CommBoughtOrSet
	}
	return nil
}

func (m *TemplateDTO) GetMergedEntityMetaData() *MergedEntityMetadata {
	if m != nil {
		return m.MergedEntityMetaData
	}
	return nil
}

// In some cases, an entity may buy one commodity or another, but it must buy one of the two
// This set represents the set of commodities where the entity must buy one of these.
// It could be that the set contains multiple commodities from the same provider - where only
// one of these will be bought.  Or it could be that there are multiple provider types and the
// entity must buy one.  However, for this set, the entity is only required to buy one of the
// commodities.
type TemplateDTO_CommBoughtProviderOrSet struct {
	CommBought       []*TemplateDTO_CommBoughtProviderProp `protobuf:"bytes,1,rep,name=commBought" json:"commBought,omitempty"`
	XXX_unrecognized []byte                                `json:"-"`
}

func (m *TemplateDTO_CommBoughtProviderOrSet) Reset()         { *m = TemplateDTO_CommBoughtProviderOrSet{} }
func (m *TemplateDTO_CommBoughtProviderOrSet) String() string { return proto.CompactTextString(m) }
func (*TemplateDTO_CommBoughtProviderOrSet) ProtoMessage()    {}
func (*TemplateDTO_CommBoughtProviderOrSet) Descriptor() ([]byte, []int) {
	return fileDescriptor9, []int{0, 0}
}

func (m *TemplateDTO_CommBoughtProviderOrSet) GetCommBought() []*TemplateDTO_CommBoughtProviderProp {
	if m != nil {
		return m.CommBought
	}
	return nil
}

type TemplateDTO_CommBoughtProviderProp struct {
	// Provider entity type created by the probe
	Key *Provider `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	// The list of commodities bought from the provider specified as key.
	Value []*TemplateCommodity `protobuf:"bytes,2,rep,name=value" json:"value,omitempty"`
	// Specifies if the provider is optional or not.
	IsOptional       *bool  `protobuf:"varint,3,opt,name=isOptional,def=0" json:"isOptional,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TemplateDTO_CommBoughtProviderProp) Reset()         { *m = TemplateDTO_CommBoughtProviderProp{} }
func (m *TemplateDTO_CommBoughtProviderProp) String() string { return proto.CompactTextString(m) }
func (*TemplateDTO_CommBoughtProviderProp) ProtoMessage()    {}
func (*TemplateDTO_CommBoughtProviderProp) Descriptor() ([]byte, []int) {
	return fileDescriptor9, []int{0, 1}
}

const Default_TemplateDTO_CommBoughtProviderProp_IsOptional bool = false

func (m *TemplateDTO_CommBoughtProviderProp) GetKey() *Provider {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *TemplateDTO_CommBoughtProviderProp) GetValue() []*TemplateCommodity {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TemplateDTO_CommBoughtProviderProp) GetIsOptional() bool {
	if m != nil && m.IsOptional != nil {
		return *m.IsOptional
	}
	return Default_TemplateDTO_CommBoughtProviderProp_IsOptional
}

type TemplateDTO_ExternalEntityLinkProp struct {
	Key              *EntityDTO_EntityType `protobuf:"varint,1,req,name=key,enum=common_dto.EntityDTO_EntityType" json:"key,omitempty"`
	Value            *ExternalEntityLink   `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *TemplateDTO_ExternalEntityLinkProp) Reset()         { *m = TemplateDTO_ExternalEntityLinkProp{} }
func (m *TemplateDTO_ExternalEntityLinkProp) String() string { return proto.CompactTextString(m) }
func (*TemplateDTO_ExternalEntityLinkProp) ProtoMessage()    {}
func (*TemplateDTO_ExternalEntityLinkProp) Descriptor() ([]byte, []int) {
	return fileDescriptor9, []int{0, 2}
}

func (m *TemplateDTO_ExternalEntityLinkProp) GetKey() EntityDTO_EntityType {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return EntityDTO_SWITCH
}

func (m *TemplateDTO_ExternalEntityLinkProp) GetValue() *ExternalEntityLink {
	if m != nil {
		return m.Value
	}
	return nil
}

type TemplateCommodity struct {
	CommodityType *CommodityDTO_CommodityType `protobuf:"varint,1,req,name=commodityType,enum=common_dto.CommodityDTO_CommodityType" json:"commodityType,omitempty"`
	Key           *string                     `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	// Type of the commodity, that charges this one. This must be on of the commodities from
	// the entity (template) is expected to buy. So, this is a link between bought and sold
	// commodity of the same entity
	ChargedBy        []CommodityDTO_CommodityType `protobuf:"varint,3,rep,name=chargedBy,enum=common_dto.CommodityDTO_CommodityType" json:"chargedBy,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *TemplateCommodity) Reset()                    { *m = TemplateCommodity{} }
func (m *TemplateCommodity) String() string            { return proto.CompactTextString(m) }
func (*TemplateCommodity) ProtoMessage()               {}
func (*TemplateCommodity) Descriptor() ([]byte, []int) { return fileDescriptor9, []int{1} }

func (m *TemplateCommodity) GetCommodityType() CommodityDTO_CommodityType {
	if m != nil && m.CommodityType != nil {
		return *m.CommodityType
	}
	return CommodityDTO_CLUSTER
}

func (m *TemplateCommodity) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *TemplateCommodity) GetChargedBy() []CommodityDTO_CommodityType {
	if m != nil {
		return m.ChargedBy
	}
	return nil
}

// The Provider class creates a template entity that sells commodities to a
// consumer template.
//
// Each Provider instance has a templateClass to define the entity type, which is expressed
// as a member of the EntityType enumeration.
//
// A provider can have one of two types of relationship with the consumer entity -
// HOSTING or LAYERED_OVER (see ProviderType):
//
// HOSTING is a One Provider/Many Consumers relationship, where the provider contains the consumer.
// This means that if the provider is removed, then every consumer it contains will also be removed.
// For example, a PhysicalMachine contains many VirtualMachines. If you remove the PhysicalMachine
// entity, then its contained VMs will also be removed. You should move VMs off of a host before removing it.
//
// LAYERED_OVER is a Many/Many relationship, with no concept of containment. For example, many VMs
// can share more than one datastore. For LayeredOver relationships, you must specify max and min limits
// to determine how many providers can be layered over the given type of consumer. These values are set in the
// cardinalityMax and cardinalityMin members of this class.
type Provider struct {
	// The type of entity that the provider represents. See {@link Entity}
	// for the available types.
	TemplateClass *EntityDTO_EntityType `protobuf:"varint,1,req,name=templateClass,enum=common_dto.EntityDTO_EntityType" json:"templateClass,omitempty"`
	// ProviderType specifies the type of relationship between the provider and the consumer
	ProviderType *Provider_ProviderType `protobuf:"varint,2,req,name=providerType,enum=common_dto.Provider_ProviderType" json:"providerType,omitempty"`
	// For LAYERED_OVER providers, the maximum number of providers allowed for the consumer.
	CardinalityMax *int32 `protobuf:"varint,3,req,name=cardinalityMax" json:"cardinalityMax,omitempty"`
	// For LAYERED_OVER providers, the minimum number of providers allowed for the consumer.
	CardinalityMin   *int32 `protobuf:"varint,4,req,name=cardinalityMin" json:"cardinalityMin,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Provider) Reset()                    { *m = Provider{} }
func (m *Provider) String() string            { return proto.CompactTextString(m) }
func (*Provider) ProtoMessage()               {}
func (*Provider) Descriptor() ([]byte, []int) { return fileDescriptor9, []int{2} }

func (m *Provider) GetTemplateClass() EntityDTO_EntityType {
	if m != nil && m.TemplateClass != nil {
		return *m.TemplateClass
	}
	return EntityDTO_SWITCH
}

func (m *Provider) GetProviderType() Provider_ProviderType {
	if m != nil && m.ProviderType != nil {
		return *m.ProviderType
	}
	return Provider_HOSTING
}

func (m *Provider) GetCardinalityMax() int32 {
	if m != nil && m.CardinalityMax != nil {
		return *m.CardinalityMax
	}
	return 0
}

func (m *Provider) GetCardinalityMin() int32 {
	if m != nil && m.CardinalityMin != nil {
		return *m.CardinalityMin
	}
	return 0
}

// ExternalEntityLink is a subclass of {@link EntityLink} that
// describes the buy/sell relationship between an entity discovered by the probe, and
// an external entity.
//
// An external entity is one that exists in the
// Operations Manager topology, but has not been discovered by the probe.
// Operations Manager uses this link to stitch discovered entities into the
// existing topology that's managed by the Operations Manager market. This external
// entity can be a provider or a consumer. The ExternalEntityLink object
// contains a full description of the relationship between the external entity and
// the node entity.
// This description includes the entity types for the buyer and seller, the ProviderType
// (the relationship type for the provider, either HOSTING or LAYERED_OVER}),
// and the list of commodities bought from the provider.
//
// To enable stitching, the external link includes a map of {@code probeEntityDef} items
// and a list of ServerEntityPropertyDef items. These work together to identify which
// external entity to stitch together with the probe's discovered entity. The {@code probeEntityDef}
// items store data to identify the appropriate external entity. For example, a discovered application
// can store the IP address of the hosting VM.
//
// The ServerEntityPropertyDef items
// tell Operations Manager how to find identifying information in the external entities.
// For example, the discovered application stores IP address of the hosting VM. Operations Manager
// will use the ServerEntityPropertyDef to test the current VMs for a matching IP address.
type ExternalEntityLink struct {
	// Consumer entity in the link
	BuyerRef *EntityDTO_EntityType `protobuf:"varint,1,req,name=buyerRef,enum=common_dto.EntityDTO_EntityType" json:"buyerRef,omitempty"`
	// Provider entity in the link
	SellerRef *EntityDTO_EntityType `protobuf:"varint,2,req,name=sellerRef,enum=common_dto.EntityDTO_EntityType" json:"sellerRef,omitempty"`
	// Provider relationship type
	Relationship *Provider_ProviderType `protobuf:"varint,3,req,name=relationship,enum=common_dto.Provider_ProviderType" json:"relationship,omitempty"`
	// The list of commodities the consumer entity buys from the provider entity.
	CommodityDefs []*ExternalEntityLink_CommodityDef `protobuf:"bytes,4,rep,name=commodityDefs" json:"commodityDefs,omitempty"`
	// Commodity key
	Key *string `protobuf:"bytes,5,opt,name=key" json:"key,omitempty"`
	// If one of the entity is to be found outside the probe
	HasExternalEntity *bool `protobuf:"varint,6,opt,name=hasExternalEntity" json:"hasExternalEntity,omitempty"`
	// Map of the name and description of the property belonging to the entity instances
	// discovered by the probe.
	ProbeEntityPropertyDef []*ExternalEntityLink_EntityPropertyDef `protobuf:"bytes,7,rep,name=probeEntityPropertyDef" json:"probeEntityPropertyDef,omitempty"`
	// The meta data representing the property definition of the external entity.
	// The value of the property is used for matching the entity instances.
	ExternalEntityPropertyDefs []*ServerEntityPropDef `protobuf:"bytes,8,rep,name=externalEntityPropertyDefs" json:"externalEntityPropertyDefs,omitempty"`
	// if the provider can replace a placeholder entity created outside of the probe,
	// give a list of EntityTypes it can replace.  For example, a LogicalPool can replace
	// a DiskArray or LogicalPool created by another probe.  The replaced entity must be
	// marked REPLACEABLE by the probe that creates it.
	ReplacesEntity   []EntityDTO_EntityType `protobuf:"varint,9,rep,name=replacesEntity,enum=common_dto.EntityDTO_EntityType" json:"replacesEntity,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *ExternalEntityLink) Reset()                    { *m = ExternalEntityLink{} }
func (m *ExternalEntityLink) String() string            { return proto.CompactTextString(m) }
func (*ExternalEntityLink) ProtoMessage()               {}
func (*ExternalEntityLink) Descriptor() ([]byte, []int) { return fileDescriptor9, []int{3} }

func (m *ExternalEntityLink) GetBuyerRef() EntityDTO_EntityType {
	if m != nil && m.BuyerRef != nil {
		return *m.BuyerRef
	}
	return EntityDTO_SWITCH
}

func (m *ExternalEntityLink) GetSellerRef() EntityDTO_EntityType {
	if m != nil && m.SellerRef != nil {
		return *m.SellerRef
	}
	return EntityDTO_SWITCH
}

func (m *ExternalEntityLink) GetRelationship() Provider_ProviderType {
	if m != nil && m.Relationship != nil {
		return *m.Relationship
	}
	return Provider_HOSTING
}

func (m *ExternalEntityLink) GetCommodityDefs() []*ExternalEntityLink_CommodityDef {
	if m != nil {
		return m.CommodityDefs
	}
	return nil
}

func (m *ExternalEntityLink) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *ExternalEntityLink) GetHasExternalEntity() bool {
	if m != nil && m.HasExternalEntity != nil {
		return *m.HasExternalEntity
	}
	return false
}

func (m *ExternalEntityLink) GetProbeEntityPropertyDef() []*ExternalEntityLink_EntityPropertyDef {
	if m != nil {
		return m.ProbeEntityPropertyDef
	}
	return nil
}

func (m *ExternalEntityLink) GetExternalEntityPropertyDefs() []*ServerEntityPropDef {
	if m != nil {
		return m.ExternalEntityPropertyDefs
	}
	return nil
}

func (m *ExternalEntityLink) GetReplacesEntity() []EntityDTO_EntityType {
	if m != nil {
		return m.ReplacesEntity
	}
	return nil
}

type ExternalEntityLink_CommodityDef struct {
	Type             *CommodityDTO_CommodityType `protobuf:"varint,1,req,name=type,enum=common_dto.CommodityDTO_CommodityType" json:"type,omitempty"`
	HasKey           *bool                       `protobuf:"varint,2,opt,name=hasKey,def=0" json:"hasKey,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *ExternalEntityLink_CommodityDef) Reset()         { *m = ExternalEntityLink_CommodityDef{} }
func (m *ExternalEntityLink_CommodityDef) String() string { return proto.CompactTextString(m) }
func (*ExternalEntityLink_CommodityDef) ProtoMessage()    {}
func (*ExternalEntityLink_CommodityDef) Descriptor() ([]byte, []int) {
	return fileDescriptor9, []int{3, 0}
}

const Default_ExternalEntityLink_CommodityDef_HasKey bool = false

func (m *ExternalEntityLink_CommodityDef) GetType() CommodityDTO_CommodityType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return CommodityDTO_CLUSTER
}

func (m *ExternalEntityLink_CommodityDef) GetHasKey() bool {
	if m != nil && m.HasKey != nil {
		return *m.HasKey
	}
	return Default_ExternalEntityLink_CommodityDef_HasKey
}

// Holds a property for the probe's discovered entity that Operations Manager can use to stitch the discovered entity
// into the Operations Manager topology. Each property contains a property name and a description.
//
// The property name specifies which property of the discovered entity you want to match. The discovered
// entity's DTO contains the list of properties and values for that entity. This link must include a property that matches a
// named property in the DTO. Note that the SDK includes builders for different types of entities.
// These builders add properties to the entity DTO, giving them names from the {@link SupplyChainConstants} enumeration.
// However, you can use arbitrary names for these properties, so long as the named property is declared in the
// entity DTO.
//
// The properties you create here match the property names in the target DTO.
// For example, the {link ApplicationBuilder} adds an IP address as a property named {@code SupplyChainConstants.IP_ADDRESS}.
// To match the application IP address in this link, add a property to the link with the same name. By doing that,
// the stitching process can access the value that is set in the discovered entity's DTO.
//
// The property description is an arbitrary string to describe the purpose of this property. This is useful
// when you print out the link via a {@code toString()} method.
type ExternalEntityLink_EntityPropertyDef struct {
	// An entity property name
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// An arbitrary description
	Description      *string `protobuf:"bytes,2,req,name=description" json:"description,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ExternalEntityLink_EntityPropertyDef) Reset()         { *m = ExternalEntityLink_EntityPropertyDef{} }
func (m *ExternalEntityLink_EntityPropertyDef) String() string { return proto.CompactTextString(m) }
func (*ExternalEntityLink_EntityPropertyDef) ProtoMessage()    {}
func (*ExternalEntityLink_EntityPropertyDef) Descriptor() ([]byte, []int) {
	return fileDescriptor9, []int{3, 1}
}

func (m *ExternalEntityLink_EntityPropertyDef) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ExternalEntityLink_EntityPropertyDef) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

// MergedEntityMetadata provides data that defines how to merge entities of this template type
// discovered by this probe with entities (referred to here as external entities) that were
// discovered by other probes and exist in the server.  There should be a MergedEntityMetadata entry
// for each entity type in the probe that is reported as origin "proxy".  The XL server will
// process the MergedEntityMetadata for each probe and create stitching operations for that probe.
// When processing topology from all the probes, XL will process the topology through the set of
// stitching operations to combine proxy instances with their matching external entities.
// The MergedEntityMetadata combines information that was previously contained in
// various places (e.g. external entity link, replacement entity metadata, and hardcoded in
// OpsManager stitching code).  It is currently used in XL for stitching,
// but is not used by OpsManager.  It consists of two parts: one part describes how to
// match two entities to know they are the same and the other part describes which properties and
// commodities to transfer from the proxy entity to the external entity it matches.  Matching can be
// done based on an entity property or field.  You specify one field or property to use on the entity
// that this probe discovers and one field or property for the external entity.  You may also
// specify multiple fields on either side in which case they will be concatenated together to
// form the matching value.  For the transfer, you can specify a list of entity properties, a list
// of entity fields, a list of sold commodities and/or a list of bought commodities.
type MergedEntityMetadata struct {
	// Should this entity type reported by the probe be kept in the topology if no stitching match
	// is found?  If yes, keepStandalone should be true.  If no, it should be false.
	KeepStandalone *bool `protobuf:"varint,1,opt,name=keepStandalone,def=1" json:"keepStandalone,omitempty"`
	// MatchingMetadata contains the information for matching this proxy entity with an external
	// entity
	MatchingMetadata *MergedEntityMetadata_MatchingMetadata `protobuf:"bytes,2,req,name=matchingMetadata" json:"matchingMetadata,omitempty"`
	// Names of entity properties that will be patched during merging.
	// Entities will be searched in EntityDTO.propMap.
	// These properties will be taken from the internal entity and written to the external entity.
	// If the external entity already has a property with the same key, it will be replaced by the
	// internal entity's property value.
	PatchedProperties []*MergedEntityMetadata_EntityPropertyName `protobuf:"bytes,3,rep,name=patchedProperties" json:"patchedProperties,omitempty"`
	// Similar to patched properties, we can have a list of fields in the EntityDTO to patch.
	// Again, if a field is specified here and exists in both the internal and external entities,
	// the value from the internal entity will overwrite the value from the external entity.
	PatchedFields []*MergedEntityMetadata_EntityField `protobuf:"bytes,4,rep,name=patchedFields" json:"patchedFields,omitempty"`
	// List of sold commodities that must be merged.
	CommoditiesSold []CommodityDTO_CommodityType `protobuf:"varint,5,rep,name=commoditiesSold,enum=common_dto.CommodityDTO_CommodityType" json:"commoditiesSold,omitempty"`
	// List of bought commodities that must be merged.
	CommoditiesBought []*MergedEntityMetadata_CommodityBoughtMetadata `protobuf:"bytes,6,rep,name=commoditiesBought" json:"commoditiesBought,omitempty"`
	XXX_unrecognized  []byte                                          `json:"-"`
}

func (m *MergedEntityMetadata) Reset()                    { *m = MergedEntityMetadata{} }
func (m *MergedEntityMetadata) String() string            { return proto.CompactTextString(m) }
func (*MergedEntityMetadata) ProtoMessage()               {}
func (*MergedEntityMetadata) Descriptor() ([]byte, []int) { return fileDescriptor9, []int{4} }

const Default_MergedEntityMetadata_KeepStandalone bool = true

func (m *MergedEntityMetadata) GetKeepStandalone() bool {
	if m != nil && m.KeepStandalone != nil {
		return *m.KeepStandalone
	}
	return Default_MergedEntityMetadata_KeepStandalone
}

func (m *MergedEntityMetadata) GetMatchingMetadata() *MergedEntityMetadata_MatchingMetadata {
	if m != nil {
		return m.MatchingMetadata
	}
	return nil
}

func (m *MergedEntityMetadata) GetPatchedProperties() []*MergedEntityMetadata_EntityPropertyName {
	if m != nil {
		return m.PatchedProperties
	}
	return nil
}

func (m *MergedEntityMetadata) GetPatchedFields() []*MergedEntityMetadata_EntityField {
	if m != nil {
		return m.PatchedFields
	}
	return nil
}

func (m *MergedEntityMetadata) GetCommoditiesSold() []CommodityDTO_CommodityType {
	if m != nil {
		return m.CommoditiesSold
	}
	return nil
}

func (m *MergedEntityMetadata) GetCommoditiesBought() []*MergedEntityMetadata_CommodityBoughtMetadata {
	if m != nil {
		return m.CommoditiesBought
	}
	return nil
}

type MergedEntityMetadata_MatchingMetadata struct {
	// indicates the type of the matching metadata.  We currently support STRING and LIST_STRING
	// For example, storage external names is a LIST_STRING.
	ReturnType *MergedEntityMetadata_ReturnType `protobuf:"varint,1,req,name=returnType,enum=common_dto.MergedEntityMetadata_ReturnType" json:"returnType,omitempty"`
	// This is the field/property or combination of fields and properties that we extract from
	// the internal entity for matching.  It is not repeated in most cases.  The only use case
	// for repeated fields here is if you want to merge multiple String fields and/or properties
	// into a single value for matching purposes.
	MatchingData []*MergedEntityMetadata_MatchingData `protobuf:"bytes,2,rep,name=matchingData" json:"matchingData,omitempty"`
	// Definition of server entity property that we are matching with
	ExternalEntityReturnType *MergedEntityMetadata_ReturnType `protobuf:"varint,3,req,name=externalEntityReturnType,enum=common_dto.MergedEntityMetadata_ReturnType" json:"externalEntityReturnType,omitempty"`
	// This defines fields and/or properties we will extract from server side to attempt to
	// match an external entity with the internal entity
	ExternalEntityMatchingProperty []*MergedEntityMetadata_MatchingData `protobuf:"bytes,4,rep,name=externalEntityMatchingProperty" json:"externalEntityMatchingProperty,omitempty"`
	XXX_unrecognized               []byte                               `json:"-"`
}

func (m *MergedEntityMetadata_MatchingMetadata) Reset()         { *m = MergedEntityMetadata_MatchingMetadata{} }
func (m *MergedEntityMetadata_MatchingMetadata) String() string { return proto.CompactTextString(m) }
func (*MergedEntityMetadata_MatchingMetadata) ProtoMessage()    {}
func (*MergedEntityMetadata_MatchingMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor9, []int{4, 0}
}

func (m *MergedEntityMetadata_MatchingMetadata) GetReturnType() MergedEntityMetadata_ReturnType {
	if m != nil && m.ReturnType != nil {
		return *m.ReturnType
	}
	return MergedEntityMetadata_STRING
}

func (m *MergedEntityMetadata_MatchingMetadata) GetMatchingData() []*MergedEntityMetadata_MatchingData {
	if m != nil {
		return m.MatchingData
	}
	return nil
}

func (m *MergedEntityMetadata_MatchingMetadata) GetExternalEntityReturnType() MergedEntityMetadata_ReturnType {
	if m != nil && m.ExternalEntityReturnType != nil {
		return *m.ExternalEntityReturnType
	}
	return MergedEntityMetadata_STRING
}

func (m *MergedEntityMetadata_MatchingMetadata) GetExternalEntityMatchingProperty() []*MergedEntityMetadata_MatchingData {
	if m != nil {
		return m.ExternalEntityMatchingProperty
	}
	return nil
}

// The kind of data we will extract for matching.  It can be a property which is extracted from
// the entity property map or it can be a field which is named within the entityDTO itself. In
// some cases, we encode a List of Strings as a single string.  In that case, one can specify a
// delimiter that separates different strings in the value.  For example, we have a
// PM_UUID_LIST property where we have a comma separated list of UUIDs in a single string.
type MergedEntityMetadata_MatchingData struct {
	// Types that are valid to be assigned to MatchingData:
	//	*MergedEntityMetadata_MatchingData_MatchingProperty
	//	*MergedEntityMetadata_MatchingData_MatchingField
	MatchingData     isMergedEntityMetadata_MatchingData_MatchingData `protobuf_oneof:"matching_data"`
	Delimiter        *string                                          `protobuf:"bytes,200,opt,name=delimiter" json:"delimiter,omitempty"`
	XXX_unrecognized []byte                                           `json:"-"`
}

func (m *MergedEntityMetadata_MatchingData) Reset()         { *m = MergedEntityMetadata_MatchingData{} }
func (m *MergedEntityMetadata_MatchingData) String() string { return proto.CompactTextString(m) }
func (*MergedEntityMetadata_MatchingData) ProtoMessage()    {}
func (*MergedEntityMetadata_MatchingData) Descriptor() ([]byte, []int) {
	return fileDescriptor9, []int{4, 1}
}

type isMergedEntityMetadata_MatchingData_MatchingData interface {
	isMergedEntityMetadata_MatchingData_MatchingData()
}

type MergedEntityMetadata_MatchingData_MatchingProperty struct {
	MatchingProperty *MergedEntityMetadata_EntityPropertyName `protobuf:"bytes,100,opt,name=matching_property,json=matchingProperty,oneof"`
}
type MergedEntityMetadata_MatchingData_MatchingField struct {
	MatchingField *MergedEntityMetadata_EntityField `protobuf:"bytes,101,opt,name=matching_field,json=matchingField,oneof"`
}

func (*MergedEntityMetadata_MatchingData_MatchingProperty) isMergedEntityMetadata_MatchingData_MatchingData() {
}
func (*MergedEntityMetadata_MatchingData_MatchingField) isMergedEntityMetadata_MatchingData_MatchingData() {
}

func (m *MergedEntityMetadata_MatchingData) GetMatchingData() isMergedEntityMetadata_MatchingData_MatchingData {
	if m != nil {
		return m.MatchingData
	}
	return nil
}

func (m *MergedEntityMetadata_MatchingData) GetMatchingProperty() *MergedEntityMetadata_EntityPropertyName {
	if x, ok := m.GetMatchingData().(*MergedEntityMetadata_MatchingData_MatchingProperty); ok {
		return x.MatchingProperty
	}
	return nil
}

func (m *MergedEntityMetadata_MatchingData) GetMatchingField() *MergedEntityMetadata_EntityField {
	if x, ok := m.GetMatchingData().(*MergedEntityMetadata_MatchingData_MatchingField); ok {
		return x.MatchingField
	}
	return nil
}

func (m *MergedEntityMetadata_MatchingData) GetDelimiter() string {
	if m != nil && m.Delimiter != nil {
		return *m.Delimiter
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MergedEntityMetadata_MatchingData) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MergedEntityMetadata_MatchingData_OneofMarshaler, _MergedEntityMetadata_MatchingData_OneofUnmarshaler, _MergedEntityMetadata_MatchingData_OneofSizer, []interface{}{
		(*MergedEntityMetadata_MatchingData_MatchingProperty)(nil),
		(*MergedEntityMetadata_MatchingData_MatchingField)(nil),
	}
}

func _MergedEntityMetadata_MatchingData_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MergedEntityMetadata_MatchingData)
	// matching_data
	switch x := m.MatchingData.(type) {
	case *MergedEntityMetadata_MatchingData_MatchingProperty:
		b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MatchingProperty); err != nil {
			return err
		}
	case *MergedEntityMetadata_MatchingData_MatchingField:
		b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MatchingField); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MergedEntityMetadata_MatchingData.MatchingData has unexpected type %T", x)
	}
	return nil
}

func _MergedEntityMetadata_MatchingData_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MergedEntityMetadata_MatchingData)
	switch tag {
	case 100: // matching_data.matching_property
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MergedEntityMetadata_EntityPropertyName)
		err := b.DecodeMessage(msg)
		m.MatchingData = &MergedEntityMetadata_MatchingData_MatchingProperty{msg}
		return true, err
	case 101: // matching_data.matching_field
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MergedEntityMetadata_EntityField)
		err := b.DecodeMessage(msg)
		m.MatchingData = &MergedEntityMetadata_MatchingData_MatchingField{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MergedEntityMetadata_MatchingData_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MergedEntityMetadata_MatchingData)
	// matching_data
	switch x := m.MatchingData.(type) {
	case *MergedEntityMetadata_MatchingData_MatchingProperty:
		s := proto.Size(x.MatchingProperty)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MergedEntityMetadata_MatchingData_MatchingField:
		s := proto.Size(x.MatchingField)
		n += proto.SizeVarint(101<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The name of a property to extract from the entity property map.
type MergedEntityMetadata_EntityPropertyName struct {
	PropertyName     *string `protobuf:"bytes,1,req,name=propertyName" json:"propertyName,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MergedEntityMetadata_EntityPropertyName) Reset() {
	*m = MergedEntityMetadata_EntityPropertyName{}
}
func (m *MergedEntityMetadata_EntityPropertyName) String() string { return proto.CompactTextString(m) }
func (*MergedEntityMetadata_EntityPropertyName) ProtoMessage()    {}
func (*MergedEntityMetadata_EntityPropertyName) Descriptor() ([]byte, []int) {
	return fileDescriptor9, []int{4, 2}
}

func (m *MergedEntityMetadata_EntityPropertyName) GetPropertyName() string {
	if m != nil && m.PropertyName != nil {
		return *m.PropertyName
	}
	return ""
}

// A string or ordered sequence of strings describing the field in the entity DTO to use.  For
// example, for storage stitching we use messagePath={"storage_data"}, fieldName="externalName".
type MergedEntityMetadata_EntityField struct {
	MessagePath      []string `protobuf:"bytes,1,rep,name=messagePath" json:"messagePath,omitempty"`
	FieldName        *string  `protobuf:"bytes,2,req,name=fieldName" json:"fieldName,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *MergedEntityMetadata_EntityField) Reset()         { *m = MergedEntityMetadata_EntityField{} }
func (m *MergedEntityMetadata_EntityField) String() string { return proto.CompactTextString(m) }
func (*MergedEntityMetadata_EntityField) ProtoMessage()    {}
func (*MergedEntityMetadata_EntityField) Descriptor() ([]byte, []int) {
	return fileDescriptor9, []int{4, 3}
}

func (m *MergedEntityMetadata_EntityField) GetMessagePath() []string {
	if m != nil {
		return m.MessagePath
	}
	return nil
}

func (m *MergedEntityMetadata_EntityField) GetFieldName() string {
	if m != nil && m.FieldName != nil {
		return *m.FieldName
	}
	return ""
}

type MergedEntityMetadata_CommodityBoughtMetadata struct {
	ProviderType *EntityDTO_EntityType `protobuf:"varint,1,req,name=providerType,enum=common_dto.EntityDTO_EntityType" json:"providerType,omitempty"`
	// If specified, this provider will replace the provider of the replacesProvider EntityType
	// of the externalEntity
	ReplacesProvider  *EntityDTO_EntityType        `protobuf:"varint,2,opt,name=replacesProvider,enum=common_dto.EntityDTO_EntityType" json:"replacesProvider,omitempty"`
	CommodityMetadata []CommodityDTO_CommodityType `protobuf:"varint,3,rep,name=commodityMetadata,enum=common_dto.CommodityDTO_CommodityType" json:"commodityMetadata,omitempty"`
	XXX_unrecognized  []byte                       `json:"-"`
}

func (m *MergedEntityMetadata_CommodityBoughtMetadata) Reset() {
	*m = MergedEntityMetadata_CommodityBoughtMetadata{}
}
func (m *MergedEntityMetadata_CommodityBoughtMetadata) String() string {
	return proto.CompactTextString(m)
}
func (*MergedEntityMetadata_CommodityBoughtMetadata) ProtoMessage() {}
func (*MergedEntityMetadata_CommodityBoughtMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor9, []int{4, 4}
}

func (m *MergedEntityMetadata_CommodityBoughtMetadata) GetProviderType() EntityDTO_EntityType {
	if m != nil && m.ProviderType != nil {
		return *m.ProviderType
	}
	return EntityDTO_SWITCH
}

func (m *MergedEntityMetadata_CommodityBoughtMetadata) GetReplacesProvider() EntityDTO_EntityType {
	if m != nil && m.ReplacesProvider != nil {
		return *m.ReplacesProvider
	}
	return EntityDTO_SWITCH
}

func (m *MergedEntityMetadata_CommodityBoughtMetadata) GetCommodityMetadata() []CommodityDTO_CommodityType {
	if m != nil {
		return m.CommodityMetadata
	}
	return nil
}

func init() {
	proto.RegisterType((*TemplateDTO)(nil), "common_dto.TemplateDTO")
	proto.RegisterType((*TemplateDTO_CommBoughtProviderOrSet)(nil), "common_dto.TemplateDTO.CommBoughtProviderOrSet")
	proto.RegisterType((*TemplateDTO_CommBoughtProviderProp)(nil), "common_dto.TemplateDTO.CommBoughtProviderProp")
	proto.RegisterType((*TemplateDTO_ExternalEntityLinkProp)(nil), "common_dto.TemplateDTO.ExternalEntityLinkProp")
	proto.RegisterType((*TemplateCommodity)(nil), "common_dto.TemplateCommodity")
	proto.RegisterType((*Provider)(nil), "common_dto.Provider")
	proto.RegisterType((*ExternalEntityLink)(nil), "common_dto.ExternalEntityLink")
	proto.RegisterType((*ExternalEntityLink_CommodityDef)(nil), "common_dto.ExternalEntityLink.CommodityDef")
	proto.RegisterType((*ExternalEntityLink_EntityPropertyDef)(nil), "common_dto.ExternalEntityLink.EntityPropertyDef")
	proto.RegisterType((*MergedEntityMetadata)(nil), "common_dto.MergedEntityMetadata")
	proto.RegisterType((*MergedEntityMetadata_MatchingMetadata)(nil), "common_dto.MergedEntityMetadata.MatchingMetadata")
	proto.RegisterType((*MergedEntityMetadata_MatchingData)(nil), "common_dto.MergedEntityMetadata.MatchingData")
	proto.RegisterType((*MergedEntityMetadata_EntityPropertyName)(nil), "common_dto.MergedEntityMetadata.EntityPropertyName")
	proto.RegisterType((*MergedEntityMetadata_EntityField)(nil), "common_dto.MergedEntityMetadata.EntityField")
	proto.RegisterType((*MergedEntityMetadata_CommodityBoughtMetadata)(nil), "common_dto.MergedEntityMetadata.CommodityBoughtMetadata")
	proto.RegisterEnum("common_dto.TemplateDTO_TemplateType", TemplateDTO_TemplateType_name, TemplateDTO_TemplateType_value)
	proto.RegisterEnum("common_dto.Provider_ProviderType", Provider_ProviderType_name, Provider_ProviderType_value)
	proto.RegisterEnum("common_dto.MergedEntityMetadata_ReturnType", MergedEntityMetadata_ReturnType_name, MergedEntityMetadata_ReturnType_value)
}

func init() { proto.RegisterFile("SupplyChain.proto", fileDescriptor9) }

var fileDescriptor9 = []byte{
	// 1252 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x6e, 0x1b, 0xb7,
	0x13, 0xf7, 0xca, 0x1f, 0xb1, 0x46, 0xb2, 0x2d, 0x0d, 0x82, 0xfc, 0x17, 0xc2, 0x3f, 0x89, 0x2a,
	0xb4, 0xa9, 0xdb, 0x24, 0x6a, 0xeb, 0xf4, 0x10, 0x04, 0x45, 0x81, 0xd8, 0x52, 0x6a, 0x23, 0xb6,
	0xe5, 0x50, 0x6a, 0x91, 0x1c, 0x0a, 0x83, 0xd6, 0x52, 0xd6, 0x22, 0xfb, 0x05, 0x2e, 0x65, 0x44,
	0xd7, 0xf6, 0x0d, 0x7a, 0xea, 0xa1, 0xf7, 0x3e, 0x42, 0xd1, 0x37, 0xe8, 0x5b, 0xf4, 0x39, 0x7a,
	0x2b, 0xc8, 0xfd, 0xe2, 0x6a, 0xe5, 0x48, 0x0e, 0x7a, 0xe3, 0x0e, 0xe7, 0xf7, 0x9b, 0xe1, 0x70,
	0x66, 0x38, 0x0b, 0xf5, 0xfe, 0x24, 0x08, 0x9c, 0xe9, 0xc1, 0x98, 0xda, 0x5e, 0x3b, 0xe0, 0xbe,
	0xf0, 0x11, 0x86, 0xbe, 0xeb, 0xfa, 0xde, 0xb9, 0x25, 0xfc, 0xc6, 0xce, 0x81, 0x5a, 0x77, 0x06,
	0xbd, 0x68, 0xb3, 0xf5, 0xfb, 0x26, 0x54, 0x06, 0xcc, 0x0d, 0x1c, 0x2a, 0x58, 0x67, 0xd0, 0xc3,
	0x17, 0xb0, 0x25, 0xe2, 0xcf, 0x03, 0x87, 0x86, 0xa1, 0x69, 0x34, 0x4b, 0xbb, 0xdb, 0x7b, 0xcd,
	0x76, 0x46, 0xd2, 0xee, 0x7a, 0xc2, 0x16, 0x53, 0xc9, 0x11, 0xad, 0x06, 0xd3, 0x80, 0x91, 0x3c,
	0x0c, 0x0f, 0xa1, 0x9a, 0x08, 0xe4, 0xb6, 0x59, 0x52, 0x34, 0x1f, 0xeb, 0x34, 0x9a, 0xd9, 0x74,
	0xad, 0xa8, 0x72, 0x48, 0xfc, 0x1c, 0x6a, 0xc9, 0xf7, 0x19, 0xb7, 0x7d, 0x6e, 0x8b, 0xa9, 0xb9,
	0xda, 0x2c, 0xed, 0xae, 0x93, 0x82, 0x1c, 0x0f, 0x60, 0x4b, 0x19, 0xb0, 0x6c, 0x31, 0xed, 0xfb,
	0x8e, 0x65, 0xae, 0x37, 0x57, 0x77, 0x2b, 0x7b, 0x77, 0xe7, 0x99, 0x3d, 0x48, 0x14, 0x49, 0x1e,
	0x83, 0xaf, 0x61, 0x27, 0x15, 0xec, 0xfb, 0x93, 0xcb, 0xb1, 0x30, 0x37, 0x14, 0x4d, 0xfb, 0x3a,
	0xef, 0x25, 0x55, 0xa4, 0x79, 0xc6, 0xfd, 0x2b, 0xdb, 0x62, 0xfc, 0x8c, 0xfb, 0x01, 0x99, 0xa5,
	0x41, 0x02, 0x55, 0xf6, 0x4e, 0x30, 0xee, 0x51, 0xe7, 0xd8, 0xf6, 0xde, 0x9a, 0xb7, 0xde, 0x4f,
	0xdb, 0x8d, 0x75, 0xa3, 0x28, 0x4b, 0x84, 0xa2, 0xcd, 0x71, 0xe0, 0x9b, 0xc8, 0xdb, 0xc8, 0x42,
	0x8f, 0xf7, 0x99, 0x30, 0x37, 0x15, 0xed, 0x17, 0xcb, 0x7b, 0xab, 0x60, 0x64, 0x96, 0x07, 0x07,
	0x70, 0xdb, 0x65, 0xfc, 0x92, 0x59, 0x91, 0x03, 0x27, 0x4c, 0xd0, 0x0e, 0x15, 0xd4, 0x2c, 0x37,
	0x8d, 0xdd, 0x4a, 0x3e, 0x25, 0x4e, 0x66, 0xf4, 0x2c, 0x2a, 0x28, 0x99, 0x8b, 0x6e, 0xd8, 0xf0,
	0xbf, 0x6b, 0x3c, 0xc0, 0x53, 0x80, 0xcc, 0x07, 0xd3, 0xf8, 0xa0, 0xa0, 0x6b, 0x0c, 0x8d, 0xdf,
	0x0c, 0xb8, 0x33, 0x5f, 0x0d, 0x1f, 0xc0, 0xea, 0x5b, 0x36, 0x55, 0xd9, 0x5d, 0xd9, 0xbb, 0xad,
	0xdb, 0x48, 0xd4, 0x88, 0x54, 0xc0, 0x27, 0xb0, 0x7e, 0x45, 0x9d, 0x89, 0x4c, 0xe0, 0x25, 0x32,
	0x29, 0xd2, 0xc5, 0x4f, 0x00, 0xec, 0xb0, 0x17, 0x08, 0xdb, 0xf7, 0xa8, 0x63, 0xae, 0x36, 0x8d,
	0xdd, 0xcd, 0x67, 0xeb, 0x23, 0xea, 0x84, 0x8c, 0x68, 0x1b, 0x8d, 0x9f, 0x0c, 0xb8, 0x33, 0xff,
	0x8e, 0x71, 0x2f, 0x73, 0x6f, 0x99, 0xe2, 0x53, 0xae, 0x7e, 0x9d, 0xb9, 0x2a, 0x0f, 0x75, 0x2f,
	0x87, 0x2a, 0x98, 0x89, 0x7d, 0x6d, 0x7d, 0x0a, 0x55, 0xbd, 0xf8, 0x70, 0x13, 0xd6, 0xf6, 0x9f,
	0xf7, 0xbb, 0xb5, 0x15, 0xdc, 0x82, 0x72, 0xf7, 0xf5, 0xa0, 0x7b, 0xda, 0x3f, 0xea, 0x9d, 0xd6,
	0x8c, 0xd6, 0x9f, 0x06, 0xd4, 0x0b, 0x27, 0xc6, 0x63, 0xad, 0xe2, 0x54, 0xa1, 0x47, 0x2e, 0x3f,
	0xd0, 0x8d, 0xa7, 0xda, 0xc9, 0xb5, 0xa5, 0xda, 0x24, 0x0f, 0xc6, 0x5a, 0x74, 0xec, 0x52, 0xd3,
	0xd8, 0x2d, 0x47, 0x87, 0xea, 0x40, 0x79, 0x38, 0xa6, 0x32, 0x8d, 0xf6, 0x65, 0xd9, 0xaf, 0xde,
	0x80, 0x3b, 0x03, 0xb6, 0x7e, 0x2d, 0xc1, 0x66, 0x72, 0xaf, 0xff, 0x59, 0x8b, 0xeb, 0x42, 0x35,
	0x88, 0x39, 0xb5, 0x16, 0xf7, 0xd1, 0xbc, 0x5c, 0x4a, 0x17, 0x51, 0x7f, 0xd3, 0x61, 0xf8, 0x00,
	0xb6, 0x87, 0x94, 0x5b, 0xb6, 0x47, 0x1d, 0x59, 0x26, 0xf4, 0x5d, 0xdc, 0xdd, 0x66, 0xa4, 0xb3,
	0x7a, 0xb6, 0x67, 0xae, 0x15, 0xf5, 0x6c, 0xaf, 0xf5, 0x18, 0xaa, 0xba, 0x35, 0xac, 0xc0, 0xad,
	0xc3, 0x5e, 0x7f, 0x70, 0x74, 0xfa, 0x5d, 0x6d, 0x05, 0x6b, 0x50, 0x3d, 0x7e, 0xfe, 0xa6, 0x4b,
	0xba, 0x9d, 0xf3, 0xde, 0x0f, 0x5d, 0x52, 0x33, 0x5a, 0x7f, 0x6c, 0x00, 0x16, 0xb3, 0x03, 0xbf,
	0x81, 0xcd, 0x8b, 0xc9, 0x94, 0x71, 0xc2, 0x46, 0x4b, 0xc7, 0x27, 0x45, 0xe0, 0xb7, 0x50, 0x0e,
	0x99, 0xe3, 0x44, 0xf0, 0xd2, 0x92, 0xf0, 0x0c, 0x22, 0x43, 0xcb, 0x99, 0x43, 0x65, 0x9d, 0x84,
	0x63, 0x3b, 0x50, 0x11, 0x59, 0x2e, 0xb4, 0x3a, 0x0c, 0x5f, 0x69, 0xc9, 0xd9, 0x61, 0xa3, 0xd0,
	0x5c, 0x53, 0x45, 0xfc, 0xf0, 0xfd, 0x95, 0xa1, 0xe5, 0x14, 0x1b, 0x91, 0x3c, 0x43, 0x92, 0xa1,
	0xeb, 0x59, 0x86, 0x3e, 0x82, 0xfa, 0x98, 0x86, 0x79, 0x1a, 0x73, 0x43, 0xd6, 0x3c, 0x29, 0x6e,
	0xe0, 0x18, 0xee, 0x04, 0xdc, 0xbf, 0x60, 0xd1, 0xa7, 0xac, 0x75, 0xc6, 0x15, 0x75, 0xfc, 0x18,
	0x7c, 0xb9, 0xc0, 0xb7, 0x02, 0x8e, 0x5c, 0xc3, 0x87, 0xe7, 0xd0, 0x60, 0x39, 0xbc, 0xb6, 0x19,
	0xc6, 0x6f, 0xc4, 0x7d, 0xdd, 0x5a, 0x9f, 0xf1, 0x2b, 0xc6, 0x33, 0x5d, 0x49, 0xfe, 0x1e, 0x0a,
	0x3c, 0x84, 0x6d, 0xce, 0x02, 0x87, 0x0e, 0x59, 0x18, 0x9f, 0xba, 0xac, 0xea, 0x73, 0xf1, 0x4d,
	0xcf, 0xe0, 0x1a, 0x36, 0x54, 0xf5, 0x98, 0xe3, 0x33, 0x58, 0x13, 0x37, 0xef, 0x25, 0x0a, 0x83,
	0x77, 0x61, 0x63, 0x4c, 0xc3, 0x97, 0x71, 0x17, 0x49, 0xfb, 0x6e, 0x2c, 0x6c, 0x1c, 0x41, 0xbd,
	0x18, 0x2a, 0x84, 0x35, 0x8f, 0xba, 0x91, 0xbd, 0x32, 0x51, 0x6b, 0x6c, 0x42, 0xc5, 0x62, 0xe1,
	0x90, 0xdb, 0xaa, 0x5b, 0xab, 0x24, 0x2e, 0x13, 0x5d, 0xd4, 0xfa, 0xbb, 0x0a, 0xb7, 0xe7, 0xbd,
	0x7b, 0xf8, 0x08, 0xb6, 0xdf, 0x32, 0x16, 0xf4, 0x05, 0xf5, 0x2c, 0xea, 0xf8, 0x9e, 0x24, 0x96,
	0xae, 0xac, 0x09, 0x3e, 0x61, 0x64, 0x66, 0x0f, 0x7f, 0x84, 0x9a, 0x4b, 0xc5, 0x70, 0x6c, 0x7b,
	0x97, 0x09, 0x43, 0xdc, 0xc1, 0xbf, 0x5a, 0xf4, 0xc2, 0xb6, 0x4f, 0x66, 0x80, 0xa4, 0x40, 0x85,
	0x14, 0xea, 0x81, 0x94, 0x31, 0x2b, 0x3e, 0xb1, 0xcd, 0x42, 0xd5, 0x48, 0x2b, 0x7b, 0x4f, 0x16,
	0xf2, 0xe7, 0x43, 0x75, 0x4a, 0x5d, 0x46, 0x8a, 0x6c, 0x48, 0x60, 0x2b, 0x16, 0xbe, 0xb0, 0x99,
	0x63, 0x25, 0x65, 0xf6, 0x68, 0x49, 0x7a, 0x05, 0x22, 0x79, 0x0a, 0x3c, 0xcb, 0x86, 0x30, 0x9b,
	0x85, 0xe9, 0x2c, 0xb7, 0x7c, 0x36, 0xcc, 0xc2, 0x71, 0x04, 0x75, 0x4d, 0x94, 0x1b, 0xec, 0x9e,
	0x2e, 0xf4, 0xf4, 0x20, 0x3f, 0xc9, 0xa5, 0xf1, 0x2e, 0x52, 0x36, 0x7e, 0x59, 0x85, 0xda, 0xec,
	0xbd, 0xe0, 0x4b, 0x00, 0xce, 0xc4, 0x84, 0x7b, 0xda, 0x1b, 0xf9, 0x70, 0xa1, 0x55, 0x92, 0x42,
	0x88, 0x06, 0xc7, 0x57, 0x50, 0x4d, 0xae, 0xb9, 0x13, 0x65, 0x8b, 0x3c, 0xc4, 0xe3, 0xa5, 0xb3,
	0x45, 0x82, 0x48, 0x8e, 0x02, 0x2f, 0xc1, 0xcc, 0x57, 0x7a, 0x66, 0x3a, 0x6e, 0xbe, 0x37, 0xf2,
	0xf6, 0x5a, 0x32, 0x9c, 0xc0, 0xbd, 0xfc, 0x5e, 0xe2, 0x54, 0x92, 0x64, 0x71, 0xf2, 0xdc, 0xf0,
	0x34, 0x0b, 0x48, 0x1b, 0xff, 0x18, 0x50, 0xd5, 0x01, 0x78, 0x01, 0xf5, 0x24, 0x00, 0xe7, 0x41,
	0x62, 0xda, 0x52, 0x83, 0xed, 0x87, 0x94, 0xc5, 0xe1, 0x4a, 0x56, 0x7a, 0x89, 0x1c, 0xbf, 0x87,
	0xed, 0xd4, 0xc6, 0x48, 0xa6, 0xb5, 0xc9, 0x94, 0x81, 0x1b, 0x15, 0xc6, 0xe1, 0x0a, 0xd9, 0x4a,
	0x58, 0x94, 0x00, 0xef, 0x42, 0xd9, 0x62, 0x8e, 0xed, 0xda, 0x82, 0x71, 0xf3, 0x2f, 0x43, 0xbd,
	0x44, 0x99, 0x64, 0x7f, 0x07, 0x52, 0xfd, 0x73, 0x49, 0xd6, 0x78, 0x0a, 0x58, 0x74, 0x18, 0x5b,
	0x6a, 0x7a, 0x49, 0xbf, 0xe3, 0xde, 0x97, 0x93, 0x35, 0x4e, 0xa0, 0xa2, 0x79, 0x22, 0x5b, 0xa2,
	0xcb, 0xc2, 0x90, 0x5e, 0xb2, 0x33, 0x2a, 0xc6, 0x6a, 0x3e, 0x2f, 0x13, 0x5d, 0x84, 0xff, 0x87,
	0xb2, 0x3a, 0xa8, 0x62, 0x8c, 0x5a, 0x66, 0x26, 0x68, 0xfc, 0x5c, 0x8a, 0x46, 0xff, 0x39, 0x85,
	0x84, 0x9d, 0x99, 0x61, 0x6a, 0xd9, 0x99, 0x23, 0x3f, 0x4b, 0x1d, 0x43, 0x2d, 0x79, 0x5a, 0x92,
	0xb1, 0x40, 0x3d, 0x03, 0xcb, 0x30, 0x15, 0x90, 0x38, 0xc8, 0x3a, 0x46, 0x7a, 0x35, 0x37, 0x9c,
	0x41, 0x8b, 0x04, 0xad, 0xcf, 0x00, 0xb4, 0x7a, 0x00, 0xd8, 0xe8, 0x0f, 0x88, 0x1c, 0xce, 0x0c,
	0xdc, 0x81, 0xca, 0xf1, 0x51, 0x7f, 0x70, 0x1e, 0x0b, 0x4a, 0xfb, 0x6d, 0xb8, 0x3f, 0xf4, 0xdd,
	0xf6, 0x95, 0x2b, 0x26, 0xfc, 0xc2, 0x6f, 0xcb, 0xd9, 0x73, 0xe4, 0x73, 0x37, 0xb6, 0xdd, 0xb6,
	0x84, 0xbf, 0x5f, 0xd1, 0xfe, 0xf7, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x18, 0xcf, 0x6e, 0xff,
	0xfd, 0x0f, 0x00, 0x00,
}
