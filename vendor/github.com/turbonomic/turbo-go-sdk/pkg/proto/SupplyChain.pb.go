// Code generated by protoc-gen-go. DO NOT EDIT.
// source: SupplyChain.proto

package proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type TemplateDTO_TemplateType int32

const (
	TemplateDTO_BASE      TemplateDTO_TemplateType = 0
	TemplateDTO_EXTENSION TemplateDTO_TemplateType = 1
)

var TemplateDTO_TemplateType_name = map[int32]string{
	0: "BASE",
	1: "EXTENSION",
}

var TemplateDTO_TemplateType_value = map[string]int32{
	"BASE":      0,
	"EXTENSION": 1,
}

func (x TemplateDTO_TemplateType) Enum() *TemplateDTO_TemplateType {
	p := new(TemplateDTO_TemplateType)
	*p = x
	return p
}

func (x TemplateDTO_TemplateType) String() string {
	return proto.EnumName(TemplateDTO_TemplateType_name, int32(x))
}

func (x *TemplateDTO_TemplateType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TemplateDTO_TemplateType_value, data, "TemplateDTO_TemplateType")
	if err != nil {
		return err
	}
	*x = TemplateDTO_TemplateType(value)
	return nil
}

func (TemplateDTO_TemplateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{0, 0}
}

type Provider_ProviderType int32

const (
	// HOSTING is a To One relationship toward the provider, and it enforces containment.
	// This means that if the provider is removed, then every contained consumer will also be removed.
	Provider_HOSTING Provider_ProviderType = 0
	// LAYERED_OVER is a To Many relationship toward the provider, without containment.
	Provider_LAYERED_OVER Provider_ProviderType = 1
)

var Provider_ProviderType_name = map[int32]string{
	0: "HOSTING",
	1: "LAYERED_OVER",
}

var Provider_ProviderType_value = map[string]int32{
	"HOSTING":      0,
	"LAYERED_OVER": 1,
}

func (x Provider_ProviderType) Enum() *Provider_ProviderType {
	p := new(Provider_ProviderType)
	*p = x
	return p
}

func (x Provider_ProviderType) String() string {
	return proto.EnumName(Provider_ProviderType_name, int32(x))
}

func (x *Provider_ProviderType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Provider_ProviderType_value, data, "Provider_ProviderType")
	if err != nil {
		return err
	}
	*x = Provider_ProviderType(value)
	return nil
}

func (Provider_ProviderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{2, 0}
}

// The type of the matching value we will use.  String or List<String>
type MergedEntityMetadata_ReturnType int32

const (
	MergedEntityMetadata_STRING      MergedEntityMetadata_ReturnType = 1
	MergedEntityMetadata_LIST_STRING MergedEntityMetadata_ReturnType = 2
)

var MergedEntityMetadata_ReturnType_name = map[int32]string{
	1: "STRING",
	2: "LIST_STRING",
}

var MergedEntityMetadata_ReturnType_value = map[string]int32{
	"STRING":      1,
	"LIST_STRING": 2,
}

func (x MergedEntityMetadata_ReturnType) Enum() *MergedEntityMetadata_ReturnType {
	p := new(MergedEntityMetadata_ReturnType)
	*p = x
	return p
}

func (x MergedEntityMetadata_ReturnType) String() string {
	return proto.EnumName(MergedEntityMetadata_ReturnType_name, int32(x))
}

func (x *MergedEntityMetadata_ReturnType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MergedEntityMetadata_ReturnType_value, data, "MergedEntityMetadata_ReturnType")
	if err != nil {
		return err
	}
	*x = MergedEntityMetadata_ReturnType(value)
	return nil
}

func (MergedEntityMetadata_ReturnType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{4, 0}
}

//
// The TemplateDTO message represents entity types (templates) that the probe expects to
// discover in the target. For the probe to load in Operations Manager, it must discover
// entity types that are valid members of the supply chain, and these entities must have
// valid buy/sell relationships. Specifying the set of templates for a probe serves to
// validate that the specific entities the probe discovers and sends to Operations Manager do
// indeed match the entity descriptions the probe is expected to discover.
//
// Specify entity type by setting an EntityType value to the templateClass field.
//
// An entity can maintain a list of commodities that it sells.
//
// An entity can maintain a map of commodities bought (TemplateCommodity objects). Each map key is
// an instance of Provider. For each provider, the map entry is a list of the commodities bought
// from that provider.
//
// The templateType can be either {@code Base} or
// Extension (see TemplateType).
//
// A Base template indicates the initial representation
// of an entity, which means this probe performs the primary discovery of the entity and places it in the market.
// Note that there can be more than one probe that discovers the same Base entity. The template has a
// templatePriority setting that resolves such a collision. The template with the highest priority value
// wins, and discoveries made for the lower-priority template are ignored.
//
// An extension template adds data to already discovered entities. This is a way to extend the
// commodities managed by a base template.
//
type TemplateDTO struct {
	// The type of entity that the template represents. See EntityType
	// for the available types.
	TemplateClass *EntityDTO_EntityType `protobuf:"varint,1,req,name=templateClass,enum=common_dto.EntityDTO_EntityType" json:"templateClass,omitempty"`
	// The template type (Base or Extension), used during the validation process.
	TemplateType *TemplateDTO_TemplateType `protobuf:"varint,2,req,name=templateType,enum=common_dto.TemplateDTO_TemplateType" json:"templateType,omitempty"`
	// The priority of a Base template. For equivalent Base templates, Operations Manager uses the highest-priority
	// template, and discards discovered data from lower-priority Base templates.
	TemplatePriority *int32 `protobuf:"varint,3,req,name=templatePriority" json:"templatePriority,omitempty"`
	// This entity's list of {@link TemplateCommodity} items that it provides.
	CommoditySold []*TemplateCommodity `protobuf:"bytes,5,rep,name=commoditySold" json:"commoditySold,omitempty"`
	// The commodities bought from the different providers.
	// This Map contains the commodities bought where:
	CommodityBought []*TemplateDTO_CommBoughtProviderProp `protobuf:"bytes,6,rep,name=commodityBought" json:"commodityBought,omitempty"`
	// A map that defines the entity types that will be providers or consumers for this template entity.
	// The entry key is an entity type, from the EntityType enumeration. There can only be
	// one instance of each entity type in this map. The entry value is an instance of
	// ExternalEntityLink. Each entity link describes an entity type in the supply chain,
	// and the commodities it buys from or sells to the template entity.
	ExternalLink []*TemplateDTO_ExternalEntityLinkProp `protobuf:"bytes,7,rep,name=externalLink" json:"externalLink,omitempty"`
	// Each set represents a case where the entity must buy one commodity of the set ( a logical or of the set)
	// Note, the entity may buy more than one of the commodities in the set.
	CommBoughtOrSet []*TemplateDTO_CommBoughtProviderOrSet `protobuf:"bytes,8,rep,name=commBoughtOrSet" json:"commBoughtOrSet,omitempty"`
	// If this template represents an entity class that will be a proxy entity,
	// add MergedEntityMetadata that defines how to identify the matching entity in the server and
	// also what data from the proxy entity to copy over to the matching entity.
	// For details see the comment with the message definition of MergedEntityMetadata.
	MergedEntityMetaData *MergedEntityMetadata `protobuf:"bytes,9,opt,name=mergedEntityMetaData" json:"mergedEntityMetaData,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TemplateDTO) Reset()         { *m = TemplateDTO{} }
func (m *TemplateDTO) String() string { return proto.CompactTextString(m) }
func (*TemplateDTO) ProtoMessage()    {}
func (*TemplateDTO) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{0}
}

func (m *TemplateDTO) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TemplateDTO.Unmarshal(m, b)
}
func (m *TemplateDTO) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TemplateDTO.Marshal(b, m, deterministic)
}
func (m *TemplateDTO) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TemplateDTO.Merge(m, src)
}
func (m *TemplateDTO) XXX_Size() int {
	return xxx_messageInfo_TemplateDTO.Size(m)
}
func (m *TemplateDTO) XXX_DiscardUnknown() {
	xxx_messageInfo_TemplateDTO.DiscardUnknown(m)
}

var xxx_messageInfo_TemplateDTO proto.InternalMessageInfo

func (m *TemplateDTO) GetTemplateClass() EntityDTO_EntityType {
	if m != nil && m.TemplateClass != nil {
		return *m.TemplateClass
	}
	return EntityDTO_SWITCH
}

func (m *TemplateDTO) GetTemplateType() TemplateDTO_TemplateType {
	if m != nil && m.TemplateType != nil {
		return *m.TemplateType
	}
	return TemplateDTO_BASE
}

func (m *TemplateDTO) GetTemplatePriority() int32 {
	if m != nil && m.TemplatePriority != nil {
		return *m.TemplatePriority
	}
	return 0
}

func (m *TemplateDTO) GetCommoditySold() []*TemplateCommodity {
	if m != nil {
		return m.CommoditySold
	}
	return nil
}

func (m *TemplateDTO) GetCommodityBought() []*TemplateDTO_CommBoughtProviderProp {
	if m != nil {
		return m.CommodityBought
	}
	return nil
}

func (m *TemplateDTO) GetExternalLink() []*TemplateDTO_ExternalEntityLinkProp {
	if m != nil {
		return m.ExternalLink
	}
	return nil
}

func (m *TemplateDTO) GetCommBoughtOrSet() []*TemplateDTO_CommBoughtProviderOrSet {
	if m != nil {
		return m.CommBoughtOrSet
	}
	return nil
}

func (m *TemplateDTO) GetMergedEntityMetaData() *MergedEntityMetadata {
	if m != nil {
		return m.MergedEntityMetaData
	}
	return nil
}

// In some cases, an entity may buy one commodity or another, but it must buy one of the two
// This set represents the set of commodities where the entity must buy one of these.
// It could be that the set contains multiple commodities from the same provider - where only
// one of these will be bought.  Or it could be that there are multiple provider types and the
// entity must buy one.  However, for this set, the entity is only required to buy one of the
// commodities.
type TemplateDTO_CommBoughtProviderOrSet struct {
	CommBought           []*TemplateDTO_CommBoughtProviderProp `protobuf:"bytes,1,rep,name=commBought" json:"commBought,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *TemplateDTO_CommBoughtProviderOrSet) Reset()         { *m = TemplateDTO_CommBoughtProviderOrSet{} }
func (m *TemplateDTO_CommBoughtProviderOrSet) String() string { return proto.CompactTextString(m) }
func (*TemplateDTO_CommBoughtProviderOrSet) ProtoMessage()    {}
func (*TemplateDTO_CommBoughtProviderOrSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{0, 0}
}

func (m *TemplateDTO_CommBoughtProviderOrSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TemplateDTO_CommBoughtProviderOrSet.Unmarshal(m, b)
}
func (m *TemplateDTO_CommBoughtProviderOrSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TemplateDTO_CommBoughtProviderOrSet.Marshal(b, m, deterministic)
}
func (m *TemplateDTO_CommBoughtProviderOrSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TemplateDTO_CommBoughtProviderOrSet.Merge(m, src)
}
func (m *TemplateDTO_CommBoughtProviderOrSet) XXX_Size() int {
	return xxx_messageInfo_TemplateDTO_CommBoughtProviderOrSet.Size(m)
}
func (m *TemplateDTO_CommBoughtProviderOrSet) XXX_DiscardUnknown() {
	xxx_messageInfo_TemplateDTO_CommBoughtProviderOrSet.DiscardUnknown(m)
}

var xxx_messageInfo_TemplateDTO_CommBoughtProviderOrSet proto.InternalMessageInfo

func (m *TemplateDTO_CommBoughtProviderOrSet) GetCommBought() []*TemplateDTO_CommBoughtProviderProp {
	if m != nil {
		return m.CommBought
	}
	return nil
}

type TemplateDTO_CommBoughtProviderProp struct {
	// Provider entity type created by the probe
	Key *Provider `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	// The list of commodities bought from the provider specified as key.
	Value []*TemplateCommodity `protobuf:"bytes,2,rep,name=value" json:"value,omitempty"`
	// Specifies if the provider is optional or not.
	IsOptional           *bool    `protobuf:"varint,3,opt,name=isOptional,def=0" json:"isOptional,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TemplateDTO_CommBoughtProviderProp) Reset()         { *m = TemplateDTO_CommBoughtProviderProp{} }
func (m *TemplateDTO_CommBoughtProviderProp) String() string { return proto.CompactTextString(m) }
func (*TemplateDTO_CommBoughtProviderProp) ProtoMessage()    {}
func (*TemplateDTO_CommBoughtProviderProp) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{0, 1}
}

func (m *TemplateDTO_CommBoughtProviderProp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TemplateDTO_CommBoughtProviderProp.Unmarshal(m, b)
}
func (m *TemplateDTO_CommBoughtProviderProp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TemplateDTO_CommBoughtProviderProp.Marshal(b, m, deterministic)
}
func (m *TemplateDTO_CommBoughtProviderProp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TemplateDTO_CommBoughtProviderProp.Merge(m, src)
}
func (m *TemplateDTO_CommBoughtProviderProp) XXX_Size() int {
	return xxx_messageInfo_TemplateDTO_CommBoughtProviderProp.Size(m)
}
func (m *TemplateDTO_CommBoughtProviderProp) XXX_DiscardUnknown() {
	xxx_messageInfo_TemplateDTO_CommBoughtProviderProp.DiscardUnknown(m)
}

var xxx_messageInfo_TemplateDTO_CommBoughtProviderProp proto.InternalMessageInfo

const Default_TemplateDTO_CommBoughtProviderProp_IsOptional bool = false

func (m *TemplateDTO_CommBoughtProviderProp) GetKey() *Provider {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *TemplateDTO_CommBoughtProviderProp) GetValue() []*TemplateCommodity {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TemplateDTO_CommBoughtProviderProp) GetIsOptional() bool {
	if m != nil && m.IsOptional != nil {
		return *m.IsOptional
	}
	return Default_TemplateDTO_CommBoughtProviderProp_IsOptional
}

type TemplateDTO_ExternalEntityLinkProp struct {
	Key                  *EntityDTO_EntityType `protobuf:"varint,1,req,name=key,enum=common_dto.EntityDTO_EntityType" json:"key,omitempty"`
	Value                *ExternalEntityLink   `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TemplateDTO_ExternalEntityLinkProp) Reset()         { *m = TemplateDTO_ExternalEntityLinkProp{} }
func (m *TemplateDTO_ExternalEntityLinkProp) String() string { return proto.CompactTextString(m) }
func (*TemplateDTO_ExternalEntityLinkProp) ProtoMessage()    {}
func (*TemplateDTO_ExternalEntityLinkProp) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{0, 2}
}

func (m *TemplateDTO_ExternalEntityLinkProp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TemplateDTO_ExternalEntityLinkProp.Unmarshal(m, b)
}
func (m *TemplateDTO_ExternalEntityLinkProp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TemplateDTO_ExternalEntityLinkProp.Marshal(b, m, deterministic)
}
func (m *TemplateDTO_ExternalEntityLinkProp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TemplateDTO_ExternalEntityLinkProp.Merge(m, src)
}
func (m *TemplateDTO_ExternalEntityLinkProp) XXX_Size() int {
	return xxx_messageInfo_TemplateDTO_ExternalEntityLinkProp.Size(m)
}
func (m *TemplateDTO_ExternalEntityLinkProp) XXX_DiscardUnknown() {
	xxx_messageInfo_TemplateDTO_ExternalEntityLinkProp.DiscardUnknown(m)
}

var xxx_messageInfo_TemplateDTO_ExternalEntityLinkProp proto.InternalMessageInfo

func (m *TemplateDTO_ExternalEntityLinkProp) GetKey() EntityDTO_EntityType {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return EntityDTO_SWITCH
}

func (m *TemplateDTO_ExternalEntityLinkProp) GetValue() *ExternalEntityLink {
	if m != nil {
		return m.Value
	}
	return nil
}

type TemplateCommodity struct {
	CommodityType *CommodityDTO_CommodityType `protobuf:"varint,1,req,name=commodityType,enum=common_dto.CommodityDTO_CommodityType" json:"commodityType,omitempty"`
	Key           *string                     `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	// Type of the bought commodity, that charges this one. This must be one of the commodities
	// the entity (template) is expected to buy. So, this is a link between bought and sold
	// commodity of the same entity
	ChargedBy []CommodityDTO_CommodityType `protobuf:"varint,3,rep,name=chargedBy,enum=common_dto.CommodityDTO_CommodityType" json:"chargedBy,omitempty"`
	// Flag indicating that this commodity is optional. If a commodity is not optional, then it
	// is mandatory. If commodity is mandatory it is a validation exception not to have
	// this commodity set up
	Optional *bool `protobuf:"varint,4,opt,name=optional,def=0" json:"optional,omitempty"`
	// Type of the sold commodity, that charges this one. This must be one of the commodities the
	// entity (template) is expected to sell. So, this is a linek between sold commodities of the
	// same entity.
	ChargedBySold        []CommodityDTO_CommodityType `protobuf:"varint,5,rep,name=chargedBySold,enum=common_dto.CommodityDTO_CommodityType" json:"chargedBySold,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *TemplateCommodity) Reset()         { *m = TemplateCommodity{} }
func (m *TemplateCommodity) String() string { return proto.CompactTextString(m) }
func (*TemplateCommodity) ProtoMessage()    {}
func (*TemplateCommodity) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{1}
}

func (m *TemplateCommodity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TemplateCommodity.Unmarshal(m, b)
}
func (m *TemplateCommodity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TemplateCommodity.Marshal(b, m, deterministic)
}
func (m *TemplateCommodity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TemplateCommodity.Merge(m, src)
}
func (m *TemplateCommodity) XXX_Size() int {
	return xxx_messageInfo_TemplateCommodity.Size(m)
}
func (m *TemplateCommodity) XXX_DiscardUnknown() {
	xxx_messageInfo_TemplateCommodity.DiscardUnknown(m)
}

var xxx_messageInfo_TemplateCommodity proto.InternalMessageInfo

const Default_TemplateCommodity_Optional bool = false

func (m *TemplateCommodity) GetCommodityType() CommodityDTO_CommodityType {
	if m != nil && m.CommodityType != nil {
		return *m.CommodityType
	}
	return CommodityDTO_CLUSTER
}

func (m *TemplateCommodity) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *TemplateCommodity) GetChargedBy() []CommodityDTO_CommodityType {
	if m != nil {
		return m.ChargedBy
	}
	return nil
}

func (m *TemplateCommodity) GetOptional() bool {
	if m != nil && m.Optional != nil {
		return *m.Optional
	}
	return Default_TemplateCommodity_Optional
}

func (m *TemplateCommodity) GetChargedBySold() []CommodityDTO_CommodityType {
	if m != nil {
		return m.ChargedBySold
	}
	return nil
}

// The Provider class creates a template entity that sells commodities to a
// consumer template.
//
// Each Provider instance has a templateClass to define the entity type, which is expressed
// as a member of the EntityType enumeration.
//
// A provider can have one of two types of relationship with the consumer entity -
// HOSTING or LAYERED_OVER (see ProviderType):
//
// HOSTING is a One Provider/Many Consumers relationship, where the provider contains the consumer.
// This means that if the provider is removed, then every consumer it contains will also be removed.
// For example, a PhysicalMachine contains many VirtualMachines. If you remove the PhysicalMachine
// entity, then its contained VMs will also be removed. You should move VMs off of a host before removing it.
//
// LAYERED_OVER is a Many/Many relationship, with no concept of containment. For example, many VMs
// can share more than one datastore. For LayeredOver relationships, you must specify max and min limits
// to determine how many providers can be layered over the given type of consumer. These values are set in the
// cardinalityMax and cardinalityMin members of this class.
type Provider struct {
	// The type of entity that the provider represents. See {@link Entity}
	// for the available types.
	TemplateClass *EntityDTO_EntityType `protobuf:"varint,1,req,name=templateClass,enum=common_dto.EntityDTO_EntityType" json:"templateClass,omitempty"`
	// ProviderType specifies the type of relationship between the provider and the consumer
	ProviderType *Provider_ProviderType `protobuf:"varint,2,req,name=providerType,enum=common_dto.Provider_ProviderType" json:"providerType,omitempty"`
	// For LAYERED_OVER providers, the maximum number of providers allowed for the consumer.
	CardinalityMax *int32 `protobuf:"varint,3,req,name=cardinalityMax" json:"cardinalityMax,omitempty"`
	// For LAYERED_OVER providers, the minimum number of providers allowed for the consumer.
	CardinalityMin       *int32   `protobuf:"varint,4,req,name=cardinalityMin" json:"cardinalityMin,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Provider) Reset()         { *m = Provider{} }
func (m *Provider) String() string { return proto.CompactTextString(m) }
func (*Provider) ProtoMessage()    {}
func (*Provider) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{2}
}

func (m *Provider) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Provider.Unmarshal(m, b)
}
func (m *Provider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Provider.Marshal(b, m, deterministic)
}
func (m *Provider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Provider.Merge(m, src)
}
func (m *Provider) XXX_Size() int {
	return xxx_messageInfo_Provider.Size(m)
}
func (m *Provider) XXX_DiscardUnknown() {
	xxx_messageInfo_Provider.DiscardUnknown(m)
}

var xxx_messageInfo_Provider proto.InternalMessageInfo

func (m *Provider) GetTemplateClass() EntityDTO_EntityType {
	if m != nil && m.TemplateClass != nil {
		return *m.TemplateClass
	}
	return EntityDTO_SWITCH
}

func (m *Provider) GetProviderType() Provider_ProviderType {
	if m != nil && m.ProviderType != nil {
		return *m.ProviderType
	}
	return Provider_HOSTING
}

func (m *Provider) GetCardinalityMax() int32 {
	if m != nil && m.CardinalityMax != nil {
		return *m.CardinalityMax
	}
	return 0
}

func (m *Provider) GetCardinalityMin() int32 {
	if m != nil && m.CardinalityMin != nil {
		return *m.CardinalityMin
	}
	return 0
}

// ExternalEntityLink is a subclass of {@link EntityLink} that
// describes the buy/sell relationship between an entity discovered by the probe, and
// an external entity.
//
// An external entity is one that exists in the
// Operations Manager topology, but has not been discovered by the probe.
// Operations Manager uses this link to stitch discovered entities into the
// existing topology that's managed by the Operations Manager market. This external
// entity can be a provider or a consumer. The ExternalEntityLink object
// contains a full description of the relationship between the external entity and
// the node entity.
// This description includes the entity types for the buyer and seller, the ProviderType
// (the relationship type for the provider, either HOSTING or LAYERED_OVER}),
// and the list of commodities bought from the provider.
//
// To enable stitching, the external link includes a map of {@code probeEntityDef} items
// and a list of ServerEntityPropertyDef items. These work together to identify which
// external entity to stitch together with the probe's discovered entity. The {@code probeEntityDef}
// items store data to identify the appropriate external entity. For example, a discovered application
// can store the IP address of the hosting VM.
//
// The ServerEntityPropertyDef items
// tell Operations Manager how to find identifying information in the external entities.
// For example, the discovered application stores IP address of the hosting VM. Operations Manager
// will use the ServerEntityPropertyDef to test the current VMs for a matching IP address.
type ExternalEntityLink struct {
	// Consumer entity in the link
	BuyerRef *EntityDTO_EntityType `protobuf:"varint,1,req,name=buyerRef,enum=common_dto.EntityDTO_EntityType" json:"buyerRef,omitempty"`
	// Provider entity in the link
	SellerRef *EntityDTO_EntityType `protobuf:"varint,2,req,name=sellerRef,enum=common_dto.EntityDTO_EntityType" json:"sellerRef,omitempty"`
	// Provider relationship type
	Relationship *Provider_ProviderType `protobuf:"varint,3,req,name=relationship,enum=common_dto.Provider_ProviderType" json:"relationship,omitempty"`
	// The list of commodities the consumer entity buys from the provider entity.
	CommodityDefs []*ExternalEntityLink_CommodityDef `protobuf:"bytes,4,rep,name=commodityDefs" json:"commodityDefs,omitempty"`
	// Commodity key
	Key *string `protobuf:"bytes,5,opt,name=key" json:"key,omitempty"`
	// If one of the entity is to be found outside the probe
	HasExternalEntity *bool `protobuf:"varint,6,opt,name=hasExternalEntity" json:"hasExternalEntity,omitempty"`
	// Map of the name and description of the property belonging to the entity instances
	// discovered by the probe.
	ProbeEntityPropertyDef []*ExternalEntityLink_EntityPropertyDef `protobuf:"bytes,7,rep,name=probeEntityPropertyDef" json:"probeEntityPropertyDef,omitempty"`
	// The meta data representing the property definition of the external entity.
	// The value of the property is used for matching the entity instances.
	ExternalEntityPropertyDefs []*ServerEntityPropDef `protobuf:"bytes,8,rep,name=externalEntityPropertyDefs" json:"externalEntityPropertyDefs,omitempty"`
	// if the provider can replace a placeholder entity created outside of the probe,
	// give a list of EntityTypes it can replace.  For example, a LogicalPool can replace
	// a DiskArray or LogicalPool created by another probe.  The replaced entity must be
	// marked REPLACEABLE by the probe that creates it.
	ReplacesEntity       []EntityDTO_EntityType `protobuf:"varint,9,rep,name=replacesEntity,enum=common_dto.EntityDTO_EntityType" json:"replacesEntity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ExternalEntityLink) Reset()         { *m = ExternalEntityLink{} }
func (m *ExternalEntityLink) String() string { return proto.CompactTextString(m) }
func (*ExternalEntityLink) ProtoMessage()    {}
func (*ExternalEntityLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{3}
}

func (m *ExternalEntityLink) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExternalEntityLink.Unmarshal(m, b)
}
func (m *ExternalEntityLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExternalEntityLink.Marshal(b, m, deterministic)
}
func (m *ExternalEntityLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalEntityLink.Merge(m, src)
}
func (m *ExternalEntityLink) XXX_Size() int {
	return xxx_messageInfo_ExternalEntityLink.Size(m)
}
func (m *ExternalEntityLink) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalEntityLink.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalEntityLink proto.InternalMessageInfo

func (m *ExternalEntityLink) GetBuyerRef() EntityDTO_EntityType {
	if m != nil && m.BuyerRef != nil {
		return *m.BuyerRef
	}
	return EntityDTO_SWITCH
}

func (m *ExternalEntityLink) GetSellerRef() EntityDTO_EntityType {
	if m != nil && m.SellerRef != nil {
		return *m.SellerRef
	}
	return EntityDTO_SWITCH
}

func (m *ExternalEntityLink) GetRelationship() Provider_ProviderType {
	if m != nil && m.Relationship != nil {
		return *m.Relationship
	}
	return Provider_HOSTING
}

func (m *ExternalEntityLink) GetCommodityDefs() []*ExternalEntityLink_CommodityDef {
	if m != nil {
		return m.CommodityDefs
	}
	return nil
}

func (m *ExternalEntityLink) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *ExternalEntityLink) GetHasExternalEntity() bool {
	if m != nil && m.HasExternalEntity != nil {
		return *m.HasExternalEntity
	}
	return false
}

func (m *ExternalEntityLink) GetProbeEntityPropertyDef() []*ExternalEntityLink_EntityPropertyDef {
	if m != nil {
		return m.ProbeEntityPropertyDef
	}
	return nil
}

func (m *ExternalEntityLink) GetExternalEntityPropertyDefs() []*ServerEntityPropDef {
	if m != nil {
		return m.ExternalEntityPropertyDefs
	}
	return nil
}

func (m *ExternalEntityLink) GetReplacesEntity() []EntityDTO_EntityType {
	if m != nil {
		return m.ReplacesEntity
	}
	return nil
}

type ExternalEntityLink_CommodityDef struct {
	Type                 *CommodityDTO_CommodityType `protobuf:"varint,1,req,name=type,enum=common_dto.CommodityDTO_CommodityType" json:"type,omitempty"`
	HasKey               *bool                       `protobuf:"varint,2,opt,name=hasKey,def=0" json:"hasKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ExternalEntityLink_CommodityDef) Reset()         { *m = ExternalEntityLink_CommodityDef{} }
func (m *ExternalEntityLink_CommodityDef) String() string { return proto.CompactTextString(m) }
func (*ExternalEntityLink_CommodityDef) ProtoMessage()    {}
func (*ExternalEntityLink_CommodityDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{3, 0}
}

func (m *ExternalEntityLink_CommodityDef) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExternalEntityLink_CommodityDef.Unmarshal(m, b)
}
func (m *ExternalEntityLink_CommodityDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExternalEntityLink_CommodityDef.Marshal(b, m, deterministic)
}
func (m *ExternalEntityLink_CommodityDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalEntityLink_CommodityDef.Merge(m, src)
}
func (m *ExternalEntityLink_CommodityDef) XXX_Size() int {
	return xxx_messageInfo_ExternalEntityLink_CommodityDef.Size(m)
}
func (m *ExternalEntityLink_CommodityDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalEntityLink_CommodityDef.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalEntityLink_CommodityDef proto.InternalMessageInfo

const Default_ExternalEntityLink_CommodityDef_HasKey bool = false

func (m *ExternalEntityLink_CommodityDef) GetType() CommodityDTO_CommodityType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return CommodityDTO_CLUSTER
}

func (m *ExternalEntityLink_CommodityDef) GetHasKey() bool {
	if m != nil && m.HasKey != nil {
		return *m.HasKey
	}
	return Default_ExternalEntityLink_CommodityDef_HasKey
}

// Holds a property for the probe's discovered entity that Operations Manager can use to stitch the discovered entity
// into the Operations Manager topology. Each property contains a property name and a description.
//
// The property name specifies which property of the discovered entity you want to match. The discovered
// entity's DTO contains the list of properties and values for that entity. This link must include a property that matches a
// named property in the DTO. Note that the SDK includes builders for different types of entities.
// These builders add properties to the entity DTO, giving them names from the {@link SupplyChainConstants} enumeration.
// However, you can use arbitrary names for these properties, so long as the named property is declared in the
// entity DTO.
//
// The properties you create here match the property names in the target DTO.
// For example, the {link ApplicationBuilder} adds an IP address as a property named {@code SupplyChainConstants.IP_ADDRESS}.
// To match the application IP address in this link, add a property to the link with the same name. By doing that,
// the stitching process can access the value that is set in the discovered entity's DTO.
//
// The property description is an arbitrary string to describe the purpose of this property. This is useful
// when you print out the link via a {@code toString()} method.
type ExternalEntityLink_EntityPropertyDef struct {
	// An entity property name
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// An arbitrary description
	Description          *string  `protobuf:"bytes,2,req,name=description" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExternalEntityLink_EntityPropertyDef) Reset()         { *m = ExternalEntityLink_EntityPropertyDef{} }
func (m *ExternalEntityLink_EntityPropertyDef) String() string { return proto.CompactTextString(m) }
func (*ExternalEntityLink_EntityPropertyDef) ProtoMessage()    {}
func (*ExternalEntityLink_EntityPropertyDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{3, 1}
}

func (m *ExternalEntityLink_EntityPropertyDef) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExternalEntityLink_EntityPropertyDef.Unmarshal(m, b)
}
func (m *ExternalEntityLink_EntityPropertyDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExternalEntityLink_EntityPropertyDef.Marshal(b, m, deterministic)
}
func (m *ExternalEntityLink_EntityPropertyDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalEntityLink_EntityPropertyDef.Merge(m, src)
}
func (m *ExternalEntityLink_EntityPropertyDef) XXX_Size() int {
	return xxx_messageInfo_ExternalEntityLink_EntityPropertyDef.Size(m)
}
func (m *ExternalEntityLink_EntityPropertyDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalEntityLink_EntityPropertyDef.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalEntityLink_EntityPropertyDef proto.InternalMessageInfo

func (m *ExternalEntityLink_EntityPropertyDef) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ExternalEntityLink_EntityPropertyDef) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

// MergedEntityMetadata provides data that defines how to merge entities of this template type
// discovered by this probe with entities (referred to here as external entities) that were
// discovered by other probes and exist in the server.  There should be a MergedEntityMetadata entry
// for each entity type in the probe that is reported as origin "proxy".  The XL server will
// process the MergedEntityMetadata for each probe and create stitching operations for that probe.
// When processing topology from all the probes, XL will process the topology through the set of
// stitching operations to combine proxy instances with their matching external entities.
// The MergedEntityMetadata combines information that was previously contained in
// various places (e.g. external entity link, replacement entity metadata, and hardcoded in
// OpsManager stitching code).  It is currently used in XL for stitching,
// but is not used by OpsManager.  It consists of two parts: one part describes how to
// match two entities to know they are the same and the other part describes which properties and
// commodities to transfer from the proxy entity to the external entity it matches.  Matching can be
// done based on an entity property or field.  You specify one field or property to use on the entity
// that this probe discovers and one field or property for the external entity.  You may also
// specify multiple fields on either side in which case they will be concatenated together to
// form the matching value.  For the transfer, you can specify a list of entity properties, a list
// of entity fields, a list of sold commodities and/or a list of bought commodities.
type MergedEntityMetadata struct {
	// Should this entity type reported by the probe be kept in the topology if no stitching match
	// is found?  If yes, keepStandalone should be true.  If no, it should be false.
	KeepStandalone *bool `protobuf:"varint,1,opt,name=keepStandalone,def=1" json:"keepStandalone,omitempty"`
	// MatchingMetadata contains the information for matching this proxy entity with an external
	// entity
	MatchingMetadata *MergedEntityMetadata_MatchingMetadata `protobuf:"bytes,2,req,name=matchingMetadata" json:"matchingMetadata,omitempty"`
	// Names of entity properties that will be patched during merging.
	// Entities will be searched in EntityDTO.propMap.
	// These properties will be taken from the internal entity and written to the external entity.
	// If the external entity already has a property with the same key, it will be replaced by the
	// internal entity's property value.
	PatchedProperties []*MergedEntityMetadata_EntityPropertyName `protobuf:"bytes,3,rep,name=patchedProperties" json:"patchedProperties,omitempty"`
	// Similar to patched properties, we can have a list of fields in the EntityDTO to patch.
	// Again, if a field is specified here and exists in both the internal and external entities,
	// the value from the internal entity will overwrite the value from the external entity.
	PatchedFields []*MergedEntityMetadata_EntityField `protobuf:"bytes,4,rep,name=patchedFields" json:"patchedFields,omitempty"`
	// List of sold commodities that must be merged.
	CommoditiesSold []CommodityDTO_CommodityType `protobuf:"varint,5,rep,name=commoditiesSold,enum=common_dto.CommodityDTO_CommodityType" json:"commoditiesSold,omitempty"` // Deprecated: Do not use.
	// List of bought commodities that must be merged.
	CommoditiesBought []*MergedEntityMetadata_CommodityBoughtMetadata `protobuf:"bytes,6,rep,name=commoditiesBought" json:"commoditiesBought,omitempty"`
	// List of metadata for the sold commodities that must be merged.
	CommoditiesSoldMetadata []*MergedEntityMetadata_CommoditySoldMetadata `protobuf:"bytes,7,rep,name=commodities_sold_metadata,json=commoditiesSoldMetadata" json:"commodities_sold_metadata,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                                      `json:"-"`
	XXX_unrecognized        []byte                                        `json:"-"`
	XXX_sizecache           int32                                         `json:"-"`
}

func (m *MergedEntityMetadata) Reset()         { *m = MergedEntityMetadata{} }
func (m *MergedEntityMetadata) String() string { return proto.CompactTextString(m) }
func (*MergedEntityMetadata) ProtoMessage()    {}
func (*MergedEntityMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{4}
}

func (m *MergedEntityMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MergedEntityMetadata.Unmarshal(m, b)
}
func (m *MergedEntityMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MergedEntityMetadata.Marshal(b, m, deterministic)
}
func (m *MergedEntityMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergedEntityMetadata.Merge(m, src)
}
func (m *MergedEntityMetadata) XXX_Size() int {
	return xxx_messageInfo_MergedEntityMetadata.Size(m)
}
func (m *MergedEntityMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MergedEntityMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MergedEntityMetadata proto.InternalMessageInfo

const Default_MergedEntityMetadata_KeepStandalone bool = true

func (m *MergedEntityMetadata) GetKeepStandalone() bool {
	if m != nil && m.KeepStandalone != nil {
		return *m.KeepStandalone
	}
	return Default_MergedEntityMetadata_KeepStandalone
}

func (m *MergedEntityMetadata) GetMatchingMetadata() *MergedEntityMetadata_MatchingMetadata {
	if m != nil {
		return m.MatchingMetadata
	}
	return nil
}

func (m *MergedEntityMetadata) GetPatchedProperties() []*MergedEntityMetadata_EntityPropertyName {
	if m != nil {
		return m.PatchedProperties
	}
	return nil
}

func (m *MergedEntityMetadata) GetPatchedFields() []*MergedEntityMetadata_EntityField {
	if m != nil {
		return m.PatchedFields
	}
	return nil
}

// Deprecated: Do not use.
func (m *MergedEntityMetadata) GetCommoditiesSold() []CommodityDTO_CommodityType {
	if m != nil {
		return m.CommoditiesSold
	}
	return nil
}

func (m *MergedEntityMetadata) GetCommoditiesBought() []*MergedEntityMetadata_CommodityBoughtMetadata {
	if m != nil {
		return m.CommoditiesBought
	}
	return nil
}

func (m *MergedEntityMetadata) GetCommoditiesSoldMetadata() []*MergedEntityMetadata_CommoditySoldMetadata {
	if m != nil {
		return m.CommoditiesSoldMetadata
	}
	return nil
}

type MergedEntityMetadata_MatchingMetadata struct {
	// indicates the type of the matching metadata.  We currently support STRING and LIST_STRING
	// For example, storage external names is a LIST_STRING.
	ReturnType *MergedEntityMetadata_ReturnType `protobuf:"varint,1,req,name=returnType,enum=common_dto.MergedEntityMetadata_ReturnType" json:"returnType,omitempty"`
	// This is the field/property or combination of fields and properties that we extract from
	// the internal entity for matching.  It is not repeated in most cases.  The only use case
	// for repeated fields here is if you want to merge multiple String fields and/or properties
	// into a single value for matching purposes.
	MatchingData []*MergedEntityMetadata_MatchingData `protobuf:"bytes,2,rep,name=matchingData" json:"matchingData,omitempty"`
	// Definition of server entity property that we are matching with
	ExternalEntityReturnType *MergedEntityMetadata_ReturnType `protobuf:"varint,3,req,name=externalEntityReturnType,enum=common_dto.MergedEntityMetadata_ReturnType" json:"externalEntityReturnType,omitempty"`
	// This defines fields and/or properties we will extract from server side to attempt to
	// match an external entity with the internal entity
	ExternalEntityMatchingProperty []*MergedEntityMetadata_MatchingData `protobuf:"bytes,4,rep,name=externalEntityMatchingProperty" json:"externalEntityMatchingProperty,omitempty"`
	XXX_NoUnkeyedLiteral           struct{}                             `json:"-"`
	XXX_unrecognized               []byte                               `json:"-"`
	XXX_sizecache                  int32                                `json:"-"`
}

func (m *MergedEntityMetadata_MatchingMetadata) Reset()         { *m = MergedEntityMetadata_MatchingMetadata{} }
func (m *MergedEntityMetadata_MatchingMetadata) String() string { return proto.CompactTextString(m) }
func (*MergedEntityMetadata_MatchingMetadata) ProtoMessage()    {}
func (*MergedEntityMetadata_MatchingMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{4, 0}
}

func (m *MergedEntityMetadata_MatchingMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MergedEntityMetadata_MatchingMetadata.Unmarshal(m, b)
}
func (m *MergedEntityMetadata_MatchingMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MergedEntityMetadata_MatchingMetadata.Marshal(b, m, deterministic)
}
func (m *MergedEntityMetadata_MatchingMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergedEntityMetadata_MatchingMetadata.Merge(m, src)
}
func (m *MergedEntityMetadata_MatchingMetadata) XXX_Size() int {
	return xxx_messageInfo_MergedEntityMetadata_MatchingMetadata.Size(m)
}
func (m *MergedEntityMetadata_MatchingMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MergedEntityMetadata_MatchingMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MergedEntityMetadata_MatchingMetadata proto.InternalMessageInfo

func (m *MergedEntityMetadata_MatchingMetadata) GetReturnType() MergedEntityMetadata_ReturnType {
	if m != nil && m.ReturnType != nil {
		return *m.ReturnType
	}
	return MergedEntityMetadata_STRING
}

func (m *MergedEntityMetadata_MatchingMetadata) GetMatchingData() []*MergedEntityMetadata_MatchingData {
	if m != nil {
		return m.MatchingData
	}
	return nil
}

func (m *MergedEntityMetadata_MatchingMetadata) GetExternalEntityReturnType() MergedEntityMetadata_ReturnType {
	if m != nil && m.ExternalEntityReturnType != nil {
		return *m.ExternalEntityReturnType
	}
	return MergedEntityMetadata_STRING
}

func (m *MergedEntityMetadata_MatchingMetadata) GetExternalEntityMatchingProperty() []*MergedEntityMetadata_MatchingData {
	if m != nil {
		return m.ExternalEntityMatchingProperty
	}
	return nil
}

// The kind of data we will extract for matching. It can be a property which is extracted from
// the entity property map, or it can be a field which is named within the entityDTO itself, or
// the entity OID in XL repository. In some cases, we encode a List of Strings as a single string.
// In that case, one can specify a delimiter that separates different strings in the value.
// For example, we have a PM_UUID_LIST property where we have a comma separated list of UUIDs
// in a single string.
type MergedEntityMetadata_MatchingData struct {
	// Types that are valid to be assigned to MatchingData:
	//	*MergedEntityMetadata_MatchingData_MatchingProperty
	//	*MergedEntityMetadata_MatchingData_MatchingField
	//	*MergedEntityMetadata_MatchingData_MatchingEntityOid
	MatchingData         isMergedEntityMetadata_MatchingData_MatchingData `protobuf_oneof:"matching_data"`
	Delimiter            *string                                          `protobuf:"bytes,200,opt,name=delimiter" json:"delimiter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_unrecognized     []byte                                           `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *MergedEntityMetadata_MatchingData) Reset()         { *m = MergedEntityMetadata_MatchingData{} }
func (m *MergedEntityMetadata_MatchingData) String() string { return proto.CompactTextString(m) }
func (*MergedEntityMetadata_MatchingData) ProtoMessage()    {}
func (*MergedEntityMetadata_MatchingData) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{4, 1}
}

func (m *MergedEntityMetadata_MatchingData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MergedEntityMetadata_MatchingData.Unmarshal(m, b)
}
func (m *MergedEntityMetadata_MatchingData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MergedEntityMetadata_MatchingData.Marshal(b, m, deterministic)
}
func (m *MergedEntityMetadata_MatchingData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergedEntityMetadata_MatchingData.Merge(m, src)
}
func (m *MergedEntityMetadata_MatchingData) XXX_Size() int {
	return xxx_messageInfo_MergedEntityMetadata_MatchingData.Size(m)
}
func (m *MergedEntityMetadata_MatchingData) XXX_DiscardUnknown() {
	xxx_messageInfo_MergedEntityMetadata_MatchingData.DiscardUnknown(m)
}

var xxx_messageInfo_MergedEntityMetadata_MatchingData proto.InternalMessageInfo

type isMergedEntityMetadata_MatchingData_MatchingData interface {
	isMergedEntityMetadata_MatchingData_MatchingData()
}

type MergedEntityMetadata_MatchingData_MatchingProperty struct {
	MatchingProperty *MergedEntityMetadata_EntityPropertyName `protobuf:"bytes,100,opt,name=matching_property,json=matchingProperty,oneof"`
}

type MergedEntityMetadata_MatchingData_MatchingField struct {
	MatchingField *MergedEntityMetadata_EntityField `protobuf:"bytes,101,opt,name=matching_field,json=matchingField,oneof"`
}

type MergedEntityMetadata_MatchingData_MatchingEntityOid struct {
	MatchingEntityOid *MergedEntityMetadata_EntityOid `protobuf:"bytes,102,opt,name=matching_entity_oid,json=matchingEntityOid,oneof"`
}

func (*MergedEntityMetadata_MatchingData_MatchingProperty) isMergedEntityMetadata_MatchingData_MatchingData() {
}

func (*MergedEntityMetadata_MatchingData_MatchingField) isMergedEntityMetadata_MatchingData_MatchingData() {
}

func (*MergedEntityMetadata_MatchingData_MatchingEntityOid) isMergedEntityMetadata_MatchingData_MatchingData() {
}

func (m *MergedEntityMetadata_MatchingData) GetMatchingData() isMergedEntityMetadata_MatchingData_MatchingData {
	if m != nil {
		return m.MatchingData
	}
	return nil
}

func (m *MergedEntityMetadata_MatchingData) GetMatchingProperty() *MergedEntityMetadata_EntityPropertyName {
	if x, ok := m.GetMatchingData().(*MergedEntityMetadata_MatchingData_MatchingProperty); ok {
		return x.MatchingProperty
	}
	return nil
}

func (m *MergedEntityMetadata_MatchingData) GetMatchingField() *MergedEntityMetadata_EntityField {
	if x, ok := m.GetMatchingData().(*MergedEntityMetadata_MatchingData_MatchingField); ok {
		return x.MatchingField
	}
	return nil
}

func (m *MergedEntityMetadata_MatchingData) GetMatchingEntityOid() *MergedEntityMetadata_EntityOid {
	if x, ok := m.GetMatchingData().(*MergedEntityMetadata_MatchingData_MatchingEntityOid); ok {
		return x.MatchingEntityOid
	}
	return nil
}

func (m *MergedEntityMetadata_MatchingData) GetDelimiter() string {
	if m != nil && m.Delimiter != nil {
		return *m.Delimiter
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MergedEntityMetadata_MatchingData) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MergedEntityMetadata_MatchingData_MatchingProperty)(nil),
		(*MergedEntityMetadata_MatchingData_MatchingField)(nil),
		(*MergedEntityMetadata_MatchingData_MatchingEntityOid)(nil),
	}
}

// The name of a property to extract from the entity property map.
type MergedEntityMetadata_EntityPropertyName struct {
	PropertyName         *string  `protobuf:"bytes,1,req,name=propertyName" json:"propertyName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MergedEntityMetadata_EntityPropertyName) Reset() {
	*m = MergedEntityMetadata_EntityPropertyName{}
}
func (m *MergedEntityMetadata_EntityPropertyName) String() string { return proto.CompactTextString(m) }
func (*MergedEntityMetadata_EntityPropertyName) ProtoMessage()    {}
func (*MergedEntityMetadata_EntityPropertyName) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{4, 2}
}

func (m *MergedEntityMetadata_EntityPropertyName) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MergedEntityMetadata_EntityPropertyName.Unmarshal(m, b)
}
func (m *MergedEntityMetadata_EntityPropertyName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MergedEntityMetadata_EntityPropertyName.Marshal(b, m, deterministic)
}
func (m *MergedEntityMetadata_EntityPropertyName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergedEntityMetadata_EntityPropertyName.Merge(m, src)
}
func (m *MergedEntityMetadata_EntityPropertyName) XXX_Size() int {
	return xxx_messageInfo_MergedEntityMetadata_EntityPropertyName.Size(m)
}
func (m *MergedEntityMetadata_EntityPropertyName) XXX_DiscardUnknown() {
	xxx_messageInfo_MergedEntityMetadata_EntityPropertyName.DiscardUnknown(m)
}

var xxx_messageInfo_MergedEntityMetadata_EntityPropertyName proto.InternalMessageInfo

func (m *MergedEntityMetadata_EntityPropertyName) GetPropertyName() string {
	if m != nil && m.PropertyName != nil {
		return *m.PropertyName
	}
	return ""
}

// A string or ordered sequence of strings describing the field in the entity DTO to use.  For
// example, for storage stitching we use messagePath={"storage_data"}, fieldName="externalName".
type MergedEntityMetadata_EntityField struct {
	MessagePath          []string `protobuf:"bytes,1,rep,name=messagePath" json:"messagePath,omitempty"`
	FieldName            *string  `protobuf:"bytes,2,req,name=fieldName" json:"fieldName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MergedEntityMetadata_EntityField) Reset()         { *m = MergedEntityMetadata_EntityField{} }
func (m *MergedEntityMetadata_EntityField) String() string { return proto.CompactTextString(m) }
func (*MergedEntityMetadata_EntityField) ProtoMessage()    {}
func (*MergedEntityMetadata_EntityField) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{4, 3}
}

func (m *MergedEntityMetadata_EntityField) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MergedEntityMetadata_EntityField.Unmarshal(m, b)
}
func (m *MergedEntityMetadata_EntityField) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MergedEntityMetadata_EntityField.Marshal(b, m, deterministic)
}
func (m *MergedEntityMetadata_EntityField) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergedEntityMetadata_EntityField.Merge(m, src)
}
func (m *MergedEntityMetadata_EntityField) XXX_Size() int {
	return xxx_messageInfo_MergedEntityMetadata_EntityField.Size(m)
}
func (m *MergedEntityMetadata_EntityField) XXX_DiscardUnknown() {
	xxx_messageInfo_MergedEntityMetadata_EntityField.DiscardUnknown(m)
}

var xxx_messageInfo_MergedEntityMetadata_EntityField proto.InternalMessageInfo

func (m *MergedEntityMetadata_EntityField) GetMessagePath() []string {
	if m != nil {
		return m.MessagePath
	}
	return nil
}

func (m *MergedEntityMetadata_EntityField) GetFieldName() string {
	if m != nil && m.FieldName != nil {
		return *m.FieldName
	}
	return ""
}

// Empty message representing the fact that TopologyEntity OID is used as the matching field.
type MergedEntityMetadata_EntityOid struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MergedEntityMetadata_EntityOid) Reset()         { *m = MergedEntityMetadata_EntityOid{} }
func (m *MergedEntityMetadata_EntityOid) String() string { return proto.CompactTextString(m) }
func (*MergedEntityMetadata_EntityOid) ProtoMessage()    {}
func (*MergedEntityMetadata_EntityOid) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{4, 4}
}

func (m *MergedEntityMetadata_EntityOid) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MergedEntityMetadata_EntityOid.Unmarshal(m, b)
}
func (m *MergedEntityMetadata_EntityOid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MergedEntityMetadata_EntityOid.Marshal(b, m, deterministic)
}
func (m *MergedEntityMetadata_EntityOid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergedEntityMetadata_EntityOid.Merge(m, src)
}
func (m *MergedEntityMetadata_EntityOid) XXX_Size() int {
	return xxx_messageInfo_MergedEntityMetadata_EntityOid.Size(m)
}
func (m *MergedEntityMetadata_EntityOid) XXX_DiscardUnknown() {
	xxx_messageInfo_MergedEntityMetadata_EntityOid.DiscardUnknown(m)
}

var xxx_messageInfo_MergedEntityMetadata_EntityOid proto.InternalMessageInfo

type MergedEntityMetadata_CommodityBoughtMetadata struct {
	ProviderType *EntityDTO_EntityType `protobuf:"varint,1,req,name=providerType,enum=common_dto.EntityDTO_EntityType" json:"providerType,omitempty"`
	// If specified, this provider will replace the provider of the replacesProvider EntityType
	// of the externalEntity
	ReplacesProvider     *EntityDTO_EntityType        `protobuf:"varint,2,opt,name=replacesProvider,enum=common_dto.EntityDTO_EntityType" json:"replacesProvider,omitempty"`
	CommodityMetadata    []CommodityDTO_CommodityType `protobuf:"varint,3,rep,name=commodityMetadata,enum=common_dto.CommodityDTO_CommodityType" json:"commodityMetadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *MergedEntityMetadata_CommodityBoughtMetadata) Reset() {
	*m = MergedEntityMetadata_CommodityBoughtMetadata{}
}
func (m *MergedEntityMetadata_CommodityBoughtMetadata) String() string {
	return proto.CompactTextString(m)
}
func (*MergedEntityMetadata_CommodityBoughtMetadata) ProtoMessage() {}
func (*MergedEntityMetadata_CommodityBoughtMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{4, 5}
}

func (m *MergedEntityMetadata_CommodityBoughtMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MergedEntityMetadata_CommodityBoughtMetadata.Unmarshal(m, b)
}
func (m *MergedEntityMetadata_CommodityBoughtMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MergedEntityMetadata_CommodityBoughtMetadata.Marshal(b, m, deterministic)
}
func (m *MergedEntityMetadata_CommodityBoughtMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergedEntityMetadata_CommodityBoughtMetadata.Merge(m, src)
}
func (m *MergedEntityMetadata_CommodityBoughtMetadata) XXX_Size() int {
	return xxx_messageInfo_MergedEntityMetadata_CommodityBoughtMetadata.Size(m)
}
func (m *MergedEntityMetadata_CommodityBoughtMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MergedEntityMetadata_CommodityBoughtMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MergedEntityMetadata_CommodityBoughtMetadata proto.InternalMessageInfo

func (m *MergedEntityMetadata_CommodityBoughtMetadata) GetProviderType() EntityDTO_EntityType {
	if m != nil && m.ProviderType != nil {
		return *m.ProviderType
	}
	return EntityDTO_SWITCH
}

func (m *MergedEntityMetadata_CommodityBoughtMetadata) GetReplacesProvider() EntityDTO_EntityType {
	if m != nil && m.ReplacesProvider != nil {
		return *m.ReplacesProvider
	}
	return EntityDTO_SWITCH
}

func (m *MergedEntityMetadata_CommodityBoughtMetadata) GetCommodityMetadata() []CommodityDTO_CommodityType {
	if m != nil {
		return m.CommodityMetadata
	}
	return nil
}

type MergedEntityMetadata_CommoditySoldMetadata struct {
	// type of the sold commodity which should be merged during stitching
	CommodityType *CommodityDTO_CommodityType `protobuf:"varint,1,opt,name=commodity_type,json=commodityType,enum=common_dto.CommodityDTO_CommodityType" json:"commodity_type,omitempty"`
	// do not merge if commodity of this type (ignoring key) already exists in the external
	// entity, this ONLY covers the case where it is a keyed commodity and the external entity
	// has the same commodity with a different key. It is used to ensure there is only one
	// commodity of this type on the final stitched entity.
	// For example: ACM probe discovers a proxy VM selling Application commodity with
	// key "key1", and VC probe discovers a real VM selling Application commodity with key
	// "key2" (the keys are different due to different info exposed in different probes),
	// we only want to keep one Application commodity after stitching. Probe writer can mark
	// this to be true so that the Application commodity from proxy VM is ignored
	IgnoreIfPresent *bool `protobuf:"varint,2,opt,name=ignore_if_present,json=ignoreIfPresent,def=0" json:"ignore_if_present,omitempty"`
	// if specified, it will only patch the provided fields, otherwise it will patch all.
	// For example: the "used" value is meaningful so it should be patched, but other fields
	// like "capacity" is less meaningful than that of the external entity
	PatchedFields        []*MergedEntityMetadata_EntityField `protobuf:"bytes,3,rep,name=patched_fields,json=patchedFields" json:"patched_fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *MergedEntityMetadata_CommoditySoldMetadata) Reset() {
	*m = MergedEntityMetadata_CommoditySoldMetadata{}
}
func (m *MergedEntityMetadata_CommoditySoldMetadata) String() string {
	return proto.CompactTextString(m)
}
func (*MergedEntityMetadata_CommoditySoldMetadata) ProtoMessage() {}
func (*MergedEntityMetadata_CommoditySoldMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_433ea2f7708f0dad, []int{4, 6}
}

func (m *MergedEntityMetadata_CommoditySoldMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MergedEntityMetadata_CommoditySoldMetadata.Unmarshal(m, b)
}
func (m *MergedEntityMetadata_CommoditySoldMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MergedEntityMetadata_CommoditySoldMetadata.Marshal(b, m, deterministic)
}
func (m *MergedEntityMetadata_CommoditySoldMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergedEntityMetadata_CommoditySoldMetadata.Merge(m, src)
}
func (m *MergedEntityMetadata_CommoditySoldMetadata) XXX_Size() int {
	return xxx_messageInfo_MergedEntityMetadata_CommoditySoldMetadata.Size(m)
}
func (m *MergedEntityMetadata_CommoditySoldMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MergedEntityMetadata_CommoditySoldMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MergedEntityMetadata_CommoditySoldMetadata proto.InternalMessageInfo

const Default_MergedEntityMetadata_CommoditySoldMetadata_IgnoreIfPresent bool = false

func (m *MergedEntityMetadata_CommoditySoldMetadata) GetCommodityType() CommodityDTO_CommodityType {
	if m != nil && m.CommodityType != nil {
		return *m.CommodityType
	}
	return CommodityDTO_CLUSTER
}

func (m *MergedEntityMetadata_CommoditySoldMetadata) GetIgnoreIfPresent() bool {
	if m != nil && m.IgnoreIfPresent != nil {
		return *m.IgnoreIfPresent
	}
	return Default_MergedEntityMetadata_CommoditySoldMetadata_IgnoreIfPresent
}

func (m *MergedEntityMetadata_CommoditySoldMetadata) GetPatchedFields() []*MergedEntityMetadata_EntityField {
	if m != nil {
		return m.PatchedFields
	}
	return nil
}

func init() {
	proto.RegisterEnum("common_dto.TemplateDTO_TemplateType", TemplateDTO_TemplateType_name, TemplateDTO_TemplateType_value)
	proto.RegisterEnum("common_dto.Provider_ProviderType", Provider_ProviderType_name, Provider_ProviderType_value)
	proto.RegisterEnum("common_dto.MergedEntityMetadata_ReturnType", MergedEntityMetadata_ReturnType_name, MergedEntityMetadata_ReturnType_value)
	proto.RegisterType((*TemplateDTO)(nil), "common_dto.TemplateDTO")
	proto.RegisterType((*TemplateDTO_CommBoughtProviderOrSet)(nil), "common_dto.TemplateDTO.CommBoughtProviderOrSet")
	proto.RegisterType((*TemplateDTO_CommBoughtProviderProp)(nil), "common_dto.TemplateDTO.CommBoughtProviderProp")
	proto.RegisterType((*TemplateDTO_ExternalEntityLinkProp)(nil), "common_dto.TemplateDTO.ExternalEntityLinkProp")
	proto.RegisterType((*TemplateCommodity)(nil), "common_dto.TemplateCommodity")
	proto.RegisterType((*Provider)(nil), "common_dto.Provider")
	proto.RegisterType((*ExternalEntityLink)(nil), "common_dto.ExternalEntityLink")
	proto.RegisterType((*ExternalEntityLink_CommodityDef)(nil), "common_dto.ExternalEntityLink.CommodityDef")
	proto.RegisterType((*ExternalEntityLink_EntityPropertyDef)(nil), "common_dto.ExternalEntityLink.EntityPropertyDef")
	proto.RegisterType((*MergedEntityMetadata)(nil), "common_dto.MergedEntityMetadata")
	proto.RegisterType((*MergedEntityMetadata_MatchingMetadata)(nil), "common_dto.MergedEntityMetadata.MatchingMetadata")
	proto.RegisterType((*MergedEntityMetadata_MatchingData)(nil), "common_dto.MergedEntityMetadata.MatchingData")
	proto.RegisterType((*MergedEntityMetadata_EntityPropertyName)(nil), "common_dto.MergedEntityMetadata.EntityPropertyName")
	proto.RegisterType((*MergedEntityMetadata_EntityField)(nil), "common_dto.MergedEntityMetadata.EntityField")
	proto.RegisterType((*MergedEntityMetadata_EntityOid)(nil), "common_dto.MergedEntityMetadata.EntityOid")
	proto.RegisterType((*MergedEntityMetadata_CommodityBoughtMetadata)(nil), "common_dto.MergedEntityMetadata.CommodityBoughtMetadata")
	proto.RegisterType((*MergedEntityMetadata_CommoditySoldMetadata)(nil), "common_dto.MergedEntityMetadata.CommoditySoldMetadata")
}

func init() { proto.RegisterFile("SupplyChain.proto", fileDescriptor_433ea2f7708f0dad) }

var fileDescriptor_433ea2f7708f0dad = []byte{
	// 1393 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x5b, 0x6f, 0x1b, 0x45,
	0x14, 0xce, 0x3a, 0x97, 0xda, 0xc7, 0x8e, 0x63, 0x1f, 0x4a, 0xbb, 0x58, 0xb4, 0x75, 0x2d, 0x28,
	0xa1, 0x17, 0x43, 0x53, 0x84, 0xaa, 0x0a, 0x21, 0xd5, 0xb1, 0x4b, 0xa2, 0x26, 0x71, 0x3a, 0x36,
	0xa8, 0x95, 0x40, 0xd6, 0xc4, 0x3b, 0x8e, 0x57, 0xdd, 0x9b, 0x66, 0xd7, 0x51, 0xfd, 0x0a, 0xff,
	0x80, 0x27, 0x1e, 0x78, 0x47, 0xe2, 0x95, 0x07, 0xfe, 0x02, 0xff, 0x80, 0x7f, 0xc1, 0x6f, 0x40,
	0x3b, 0x7b, 0x9b, 0xf5, 0x3a, 0xb5, 0x5d, 0x78, 0x5b, 0x9f, 0x39, 0xdf, 0x77, 0x2e, 0x7b, 0x2e,
	0xb3, 0x86, 0x6a, 0x6f, 0xe2, 0x38, 0xc6, 0x74, 0x7f, 0x4c, 0x75, 0xab, 0xe9, 0x70, 0xdb, 0xb3,
	0x11, 0x86, 0xb6, 0x69, 0xda, 0xd6, 0x40, 0xf3, 0xec, 0xda, 0xce, 0xbe, 0x78, 0x6e, 0xf7, 0xbb,
	0xc1, 0x61, 0xe3, 0xb7, 0x3c, 0x14, 0xfb, 0xcc, 0x74, 0x0c, 0xea, 0xb1, 0x76, 0xbf, 0x8b, 0xcf,
	0x60, 0xdb, 0x0b, 0x7f, 0xee, 0x1b, 0xd4, 0x75, 0x55, 0xa5, 0x9e, 0xdb, 0x2d, 0xef, 0xd5, 0x9b,
	0x09, 0x49, 0xb3, 0x63, 0x79, 0xba, 0x37, 0xf5, 0x39, 0x82, 0xa7, 0xfe, 0xd4, 0x61, 0x24, 0x0d,
	0xc3, 0x03, 0x28, 0x45, 0x02, 0xff, 0x58, 0xcd, 0x09, 0x9a, 0x8f, 0x64, 0x1a, 0xc9, 0x6c, 0xfc,
	0x2c, 0xa8, 0x52, 0x48, 0xbc, 0x0b, 0x95, 0xe8, 0xf7, 0x29, 0xd7, 0x6d, 0xae, 0x7b, 0x53, 0x75,
	0xbd, 0x9e, 0xdb, 0xdd, 0x24, 0x19, 0x39, 0xee, 0xc3, 0xb6, 0x30, 0xa0, 0xe9, 0xde, 0xb4, 0x67,
	0x1b, 0x9a, 0xba, 0x59, 0x5f, 0xdf, 0x2d, 0xee, 0xdd, 0x98, 0x67, 0x76, 0x3f, 0x52, 0x24, 0x69,
	0x0c, 0xbe, 0x84, 0x9d, 0x58, 0xd0, 0xb2, 0x27, 0xe7, 0x63, 0x4f, 0xdd, 0x12, 0x34, 0xcd, 0xcb,
	0xbc, 0xf7, 0xa9, 0x02, 0xcd, 0x53, 0x6e, 0x5f, 0xe8, 0x1a, 0xe3, 0xa7, 0xdc, 0x76, 0xc8, 0x2c,
	0x0d, 0x12, 0x28, 0xb1, 0x37, 0x1e, 0xe3, 0x16, 0x35, 0x8e, 0x74, 0xeb, 0xb5, 0x7a, 0xe5, 0xed,
	0xb4, 0x9d, 0x50, 0x37, 0xc8, 0xb2, 0x8f, 0x10, 0xb4, 0x29, 0x0e, 0x7c, 0x15, 0x78, 0x1b, 0x58,
	0xe8, 0xf2, 0x1e, 0xf3, 0xd4, 0xbc, 0xa0, 0xfd, 0x6c, 0x79, 0x6f, 0x05, 0x8c, 0xcc, 0xf2, 0x60,
	0x1f, 0xae, 0x9a, 0x8c, 0x9f, 0x33, 0x2d, 0x70, 0xe0, 0x98, 0x79, 0xb4, 0x4d, 0x3d, 0xaa, 0x16,
	0xea, 0xca, 0x6e, 0x31, 0x5d, 0x12, 0xc7, 0x33, 0x7a, 0x1a, 0xf5, 0x28, 0x99, 0x8b, 0xae, 0xe9,
	0x70, 0xfd, 0x12, 0x0f, 0xf0, 0x04, 0x20, 0xf1, 0x41, 0x55, 0xde, 0x29, 0xe9, 0x12, 0x43, 0xed,
	0x57, 0x05, 0xae, 0xcd, 0x57, 0xc3, 0x3b, 0xb0, 0xfe, 0x9a, 0x4d, 0x45, 0x75, 0x17, 0xf7, 0xae,
	0xca, 0x36, 0x22, 0x35, 0xe2, 0x2b, 0xe0, 0x23, 0xd8, 0xbc, 0xa0, 0xc6, 0xc4, 0x2f, 0xe0, 0x25,
	0x2a, 0x29, 0xd0, 0xc5, 0x8f, 0x01, 0x74, 0xb7, 0xeb, 0x78, 0xba, 0x6d, 0x51, 0x43, 0x5d, 0xaf,
	0x2b, 0xbb, 0xf9, 0x27, 0x9b, 0x23, 0x6a, 0xb8, 0x8c, 0x48, 0x07, 0xb5, 0x1f, 0x15, 0xb8, 0x36,
	0xff, 0x1d, 0xe3, 0x5e, 0xe2, 0xde, 0x32, 0xcd, 0x27, 0x5c, 0xfd, 0x22, 0x71, 0xd5, 0x0f, 0xea,
	0x66, 0x0a, 0x95, 0x31, 0x13, 0xfa, 0xda, 0xf8, 0x04, 0x4a, 0x72, 0xf3, 0x61, 0x1e, 0x36, 0x5a,
	0x4f, 0x7b, 0x9d, 0xca, 0x1a, 0x6e, 0x43, 0xa1, 0xf3, 0xb2, 0xdf, 0x39, 0xe9, 0x1d, 0x76, 0x4f,
	0x2a, 0x4a, 0xe3, 0xf7, 0x1c, 0x54, 0x33, 0x11, 0xe3, 0x91, 0xd4, 0x71, 0xa2, 0xd1, 0x03, 0x97,
	0xef, 0xc8, 0xc6, 0x63, 0xed, 0xe8, 0xb5, 0xc5, 0xda, 0x24, 0x0d, 0xc6, 0x4a, 0x10, 0x76, 0xae,
	0xae, 0xec, 0x16, 0x82, 0xa0, 0xda, 0x50, 0x18, 0x8e, 0xa9, 0x5f, 0x46, 0x2d, 0xbf, 0xed, 0xd7,
	0x57, 0xe0, 0x4e, 0x80, 0x78, 0x1b, 0xf2, 0x76, 0xf4, 0x3a, 0x36, 0xe4, 0xd7, 0x11, 0x8b, 0x45,
	0x20, 0x91, 0x7e, 0x3c, 0x3a, 0x56, 0x09, 0x44, 0x06, 0x37, 0x7e, 0xc9, 0x41, 0x3e, 0x2a, 0xa4,
	0xff, 0x6d, 0xa6, 0x76, 0xa0, 0xe4, 0x84, 0x9c, 0xd2, 0x4c, 0xbd, 0x3d, 0xaf, 0x78, 0xe3, 0x87,
	0x60, 0xa0, 0xca, 0x30, 0xbc, 0x03, 0xe5, 0x21, 0xe5, 0x9a, 0x6e, 0x51, 0xc3, 0xef, 0x4b, 0xfa,
	0x26, 0x1c, 0xa7, 0x33, 0xd2, 0x59, 0x3d, 0xdd, 0x52, 0x37, 0xb2, 0x7a, 0xba, 0xd5, 0x78, 0x00,
	0x25, 0xd9, 0x1a, 0x16, 0xe1, 0xca, 0x41, 0xb7, 0xd7, 0x3f, 0x3c, 0xf9, 0xa6, 0xb2, 0x86, 0x15,
	0x28, 0x1d, 0x3d, 0x7d, 0xd5, 0x21, 0x9d, 0xf6, 0xa0, 0xfb, 0x5d, 0x87, 0x54, 0x94, 0xc6, 0x9f,
	0x5b, 0x80, 0xd9, 0x72, 0xc4, 0xaf, 0x20, 0x7f, 0x36, 0x99, 0x32, 0x4e, 0xd8, 0x68, 0xe9, 0xfc,
	0xc4, 0x08, 0xfc, 0x1a, 0x0a, 0x2e, 0x33, 0x8c, 0x00, 0x9e, 0x5b, 0x12, 0x9e, 0x40, 0xfc, 0xd4,
	0x72, 0x66, 0x50, 0xbf, 0x16, 0xdc, 0xb1, 0xee, 0x88, 0x8c, 0x2c, 0x97, 0x5a, 0x19, 0x86, 0x2f,
	0xa4, 0x6e, 0x68, 0xb3, 0x91, 0xab, 0x6e, 0x88, 0xa9, 0x71, 0xef, 0xed, 0xad, 0x28, 0xd5, 0x15,
	0x1b, 0x91, 0x34, 0x43, 0xd4, 0x12, 0x9b, 0x49, 0x4b, 0xdc, 0x87, 0xea, 0x98, 0xba, 0x69, 0x1a,
	0x75, 0xcb, 0xaf, 0x6a, 0x92, 0x3d, 0xc0, 0x31, 0x5c, 0x73, 0xb8, 0x7d, 0xc6, 0x82, 0x9f, 0xfe,
	0x70, 0x61, 0x5c, 0x50, 0x87, 0xdb, 0xe7, 0xf3, 0x05, 0xbe, 0x65, 0x70, 0xe4, 0x12, 0x3e, 0x1c,
	0x40, 0x8d, 0xa5, 0xf0, 0xd2, 0xa1, 0x1b, 0x2e, 0xa5, 0x5b, 0xb2, 0xb5, 0x1e, 0xe3, 0x17, 0x8c,
	0x27, 0xba, 0x3e, 0xf9, 0x5b, 0x28, 0xf0, 0x00, 0xca, 0x9c, 0x39, 0x06, 0x1d, 0x32, 0x37, 0x8c,
	0xba, 0x20, 0x7a, 0x74, 0xf1, 0x9b, 0x9e, 0xc1, 0xd5, 0x74, 0x28, 0xc9, 0x39, 0xc7, 0x27, 0xb0,
	0xe1, 0xad, 0x3e, 0xbc, 0x04, 0x06, 0x6f, 0xc0, 0xd6, 0x98, 0xba, 0xcf, 0xc3, 0xb1, 0x15, 0x4f,
	0x96, 0x50, 0x58, 0x3b, 0x84, 0x6a, 0x36, 0x55, 0x08, 0x1b, 0x16, 0x35, 0x03, 0x7b, 0x05, 0x22,
	0x9e, 0xb1, 0x0e, 0x45, 0x8d, 0xb9, 0x43, 0xae, 0x8b, 0x89, 0x24, 0x8a, 0xb8, 0x40, 0x64, 0x51,
	0xe3, 0x8f, 0x0a, 0x5c, 0x9d, 0xb7, 0x68, 0xf1, 0x3e, 0x94, 0x5f, 0x33, 0xe6, 0xf4, 0x3c, 0x6a,
	0x69, 0xd4, 0xb0, 0x2d, 0x9f, 0xd8, 0x77, 0x65, 0xc3, 0xe3, 0x13, 0x46, 0x66, 0xce, 0xf0, 0x07,
	0xa8, 0x98, 0xd4, 0x1b, 0x8e, 0x75, 0xeb, 0x3c, 0x62, 0x08, 0x57, 0xc6, 0xc3, 0x45, 0x2b, 0xbd,
	0x79, 0x3c, 0x03, 0x24, 0x19, 0x2a, 0xa4, 0x50, 0x75, 0x7c, 0x19, 0xd3, 0xc2, 0x88, 0x75, 0xe6,
	0x8a, 0xc9, 0x5d, 0xdc, 0x7b, 0xb4, 0x90, 0x3f, 0x9d, 0xaa, 0x13, 0x6a, 0x32, 0x92, 0x65, 0x43,
	0x02, 0xdb, 0xa1, 0xf0, 0x99, 0xce, 0x0c, 0x2d, 0x6a, 0xb3, 0xfb, 0x4b, 0xd2, 0x0b, 0x10, 0x49,
	0x53, 0x60, 0x3f, 0xb9, 0xf5, 0xe9, 0xcc, 0x5d, 0x7d, 0x03, 0xb4, 0x72, 0xaa, 0x42, 0x66, 0x29,
	0x70, 0x04, 0x55, 0x49, 0x94, 0xba, 0x4d, 0x3e, 0x5e, 0xe8, 0xed, 0x7e, 0xfa, 0xfa, 0x18, 0xe7,
	0x3c, 0x4b, 0x89, 0x1c, 0x3e, 0x90, 0x84, 0x03, 0xd7, 0x36, 0xb4, 0x81, 0x19, 0xbd, 0xdc, 0xa0,
	0xd1, 0xbf, 0x5c, 0xde, 0x9e, 0xef, 0x7a, 0x6c, 0xed, 0xfa, 0x4c, 0x4c, 0xd1, 0x41, 0xed, 0xe7,
	0x75, 0xa8, 0xcc, 0xd6, 0x03, 0x3e, 0x07, 0xe0, 0xcc, 0x9b, 0x70, 0x4b, 0xba, 0x0c, 0xdc, 0x5b,
	0x68, 0x99, 0xc4, 0x10, 0x22, 0xc1, 0xf1, 0x05, 0x94, 0xa2, 0xf2, 0x6a, 0x07, 0x55, 0xea, 0x07,
	0xf2, 0x60, 0xe9, 0x2a, 0xf5, 0x41, 0x24, 0x45, 0x81, 0xe7, 0xa0, 0xa6, 0x27, 0x4c, 0x62, 0x3a,
	0x1c, 0xfa, 0x2b, 0x79, 0x7b, 0x29, 0x19, 0x4e, 0xe0, 0x66, 0xfa, 0x2c, 0x72, 0x2a, 0x2a, 0xee,
	0xb0, 0x68, 0x57, 0x8c, 0x66, 0x01, 0x69, 0xed, 0xef, 0x1c, 0x94, 0x64, 0x00, 0x9e, 0x41, 0x35,
	0x4a, 0xc0, 0xc0, 0x89, 0x4c, 0x6b, 0xe2, 0x06, 0xff, 0x2e, 0xed, 0x78, 0xb0, 0x96, 0xb4, 0x7c,
	0x24, 0xc7, 0x6f, 0xa1, 0x1c, 0xdb, 0x18, 0xf9, 0xed, 0xa4, 0x32, 0x61, 0x60, 0xa5, 0x86, 0x3c,
	0x58, 0x23, 0xdb, 0x11, 0x8b, 0x10, 0xe0, 0xf7, 0xf0, 0x5e, 0x4c, 0xcb, 0x84, 0xe2, 0xc0, 0xd6,
	0x35, 0x75, 0x24, 0xb8, 0xef, 0x2e, 0xc9, 0xdd, 0xd5, 0x7d, 0xe6, 0x38, 0x07, 0xb1, 0x10, 0x6f,
	0x40, 0x41, 0x63, 0x86, 0x6e, 0xea, 0x1e, 0xe3, 0xea, 0x5f, 0x8a, 0xd8, 0xaf, 0x89, 0xa4, 0xb5,
	0x03, 0xb1, 0x37, 0x03, 0x51, 0xee, 0x8f, 0x01, 0xb3, 0xe9, 0xc0, 0x86, 0xb8, 0x93, 0xc5, 0xbf,
	0xc3, 0x89, 0x9e, 0x92, 0xd5, 0x8e, 0xa1, 0x28, 0xc5, 0xe9, 0x0f, 0x7a, 0x93, 0xb9, 0x2e, 0x3d,
	0x67, 0xa7, 0xd4, 0x1b, 0x8b, 0xcf, 0x9c, 0x02, 0x91, 0x45, 0xf8, 0x21, 0x14, 0x44, 0x1a, 0x05,
	0x63, 0xb0, 0x08, 0x12, 0x41, 0xad, 0x08, 0x85, 0x38, 0x8a, 0xda, 0x4f, 0xb9, 0xe0, 0x73, 0x6a,
	0xce, 0x9c, 0xc0, 0xf6, 0xcc, 0x7d, 0x71, 0xd9, 0x6b, 0x55, 0xfa, 0xba, 0x78, 0x04, 0x95, 0x68,
	0x7b, 0x46, 0x37, 0x1f, 0xb1, 0xe9, 0x96, 0x61, 0xca, 0x20, 0xb1, 0x9f, 0x0c, 0xc4, 0xf8, 0x4d,
	0xad, 0x78, 0xaf, 0xcf, 0x12, 0xd4, 0xfe, 0x51, 0xe0, 0xfd, 0xb9, 0xd3, 0x0b, 0x8f, 0xa1, 0x1c,
	0xab, 0x0f, 0xc2, 0x1d, 0xaf, 0xbc, 0xfb, 0x07, 0xca, 0x43, 0xa8, 0xea, 0xe7, 0x96, 0xcd, 0xd9,
	0x40, 0x1f, 0x0d, 0x1c, 0xce, 0x5c, 0x66, 0x79, 0xe9, 0xbd, 0xbf, 0x13, 0x9c, 0x1f, 0x8e, 0x4e,
	0x83, 0x53, 0xec, 0x41, 0x39, 0xdc, 0x34, 0x41, 0x6f, 0x44, 0xcb, 0xf0, 0xbf, 0x6c, 0xab, 0xc6,
	0xa7, 0x00, 0xd2, 0xac, 0x01, 0xd8, 0xea, 0xf5, 0x89, 0x7f, 0xe1, 0x56, 0x70, 0x07, 0x8a, 0x47,
	0x87, 0xbd, 0xfe, 0x20, 0x14, 0xe4, 0x5a, 0x4d, 0xb8, 0x35, 0xb4, 0xcd, 0xe6, 0x85, 0xe9, 0x4d,
	0xf8, 0x99, 0xdd, 0xf4, 0xbf, 0x27, 0x46, 0x36, 0x37, 0x43, 0xeb, 0x4d, 0xcd, 0xb3, 0x5b, 0x45,
	0xe9, 0x4f, 0xa3, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xa0, 0x94, 0x8c, 0x0e, 0x42, 0x12, 0x00,
	0x00,
}
