// Code generated by protoc-gen-go.
// source: CommonDTO.proto
// DO NOT EDIT!

package proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Enumerates supported DTO types
type UpdateType int32

const (
	// The DTO represents complete state of a new or existing entity.
	UpdateType_UPDATED UpdateType = 0
	// Entity was deleted. DTO must contain only identifying property that are necessary
	// to locate the entity on the server side.
	UpdateType_DELETED UpdateType = 1
	// The DTO represents partial data (related to performance) for existing entities.
	UpdateType_PARTIAL UpdateType = 2
)

var UpdateType_name = map[int32]string{
	0: "UPDATED",
	1: "DELETED",
	2: "PARTIAL",
}
var UpdateType_value = map[string]int32{
	"UPDATED": 0,
	"DELETED": 1,
	"PARTIAL": 2,
}

func (x UpdateType) Enum() *UpdateType {
	p := new(UpdateType)
	*p = x
	return p
}
func (x UpdateType) String() string {
	return proto.EnumName(UpdateType_name, int32(x))
}
func (x *UpdateType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UpdateType_value, data, "UpdateType")
	if err != nil {
		return err
	}
	*x = UpdateType(value)
	return nil
}
func (UpdateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

type EntityDTO_EntityType int32

const (
	EntityDTO_SWITCH                          EntityDTO_EntityType = 0
	EntityDTO_VIRTUAL_DATACENTER              EntityDTO_EntityType = 1
	EntityDTO_STORAGE                         EntityDTO_EntityType = 2
	EntityDTO_SERVICE                         EntityDTO_EntityType = 3
	EntityDTO_DATABASE_SERVER                 EntityDTO_EntityType = 4
	EntityDTO_SAVINGS                         EntityDTO_EntityType = 5
	EntityDTO_OPERATOR                        EntityDTO_EntityType = 6
	EntityDTO_WEB_SERVER                      EntityDTO_EntityType = 7
	EntityDTO_RIGHT_SIZER                     EntityDTO_EntityType = 8
	EntityDTO_THREE_TIER_APPLICATION          EntityDTO_EntityType = 9
	EntityDTO_VIRTUAL_MACHINE                 EntityDTO_EntityType = 10
	EntityDTO_DISK_ARRAY                      EntityDTO_EntityType = 11
	EntityDTO_DATACENTER                      EntityDTO_EntityType = 12
	EntityDTO_INFRASTRUCTURE                  EntityDTO_EntityType = 13
	EntityDTO_PHYSICAL_MACHINE                EntityDTO_EntityType = 14
	EntityDTO_CHASSIS                         EntityDTO_EntityType = 15
	EntityDTO_LICENSING_SERVICE               EntityDTO_EntityType = 16
	EntityDTO_BUSINESS_USER                   EntityDTO_EntityType = 17
	EntityDTO_STORAGE_CONTROLLER              EntityDTO_EntityType = 18
	EntityDTO_HYPERVISOR_SERVER               EntityDTO_EntityType = 19
	EntityDTO_BUSINESS_ENTITY                 EntityDTO_EntityType = 20
	EntityDTO_IO_MODULE                       EntityDTO_EntityType = 21
	EntityDTO_ACTION_MANAGER                  EntityDTO_EntityType = 22
	EntityDTO_VLAN                            EntityDTO_EntityType = 23
	EntityDTO_APPLICATION_SERVER              EntityDTO_EntityType = 24
	EntityDTO_BUSINESS                        EntityDTO_EntityType = 25
	EntityDTO_VIRTUAL_APPLICATION             EntityDTO_EntityType = 26
	EntityDTO_NETWORKING_ENDPOINT             EntityDTO_EntityType = 27
	EntityDTO_BUSINESS_ACCOUNT                EntityDTO_EntityType = 28
	EntityDTO_IP                              EntityDTO_EntityType = 29
	EntityDTO_SERVICE_ENTITY_TEMPLATE         EntityDTO_EntityType = 30
	EntityDTO_PORT                            EntityDTO_EntityType = 31
	EntityDTO_NETWORK                         EntityDTO_EntityType = 32
	EntityDTO_APPLICATION                     EntityDTO_EntityType = 33
	EntityDTO_THIS_ENTITY                     EntityDTO_EntityType = 34
	EntityDTO_COMPUTE_RESOURCE                EntityDTO_EntityType = 35
	EntityDTO_MAC                             EntityDTO_EntityType = 36
	EntityDTO_INTERNET                        EntityDTO_EntityType = 37
	EntityDTO_MOVER                           EntityDTO_EntityType = 38
	EntityDTO_DISTRIBUTED_VIRTUAL_PORTGROUP   EntityDTO_EntityType = 39
	EntityDTO_CONTAINER                       EntityDTO_EntityType = 40
	EntityDTO_CONTAINER_POD                   EntityDTO_EntityType = 41
	EntityDTO_LOGICAL_POOL                    EntityDTO_EntityType = 42
	EntityDTO_CLOUD_SERVICE                   EntityDTO_EntityType = 43
	EntityDTO_DPOD                            EntityDTO_EntityType = 44
	EntityDTO_VPOD                            EntityDTO_EntityType = 45
	EntityDTO_DATABASE                        EntityDTO_EntityType = 46
	EntityDTO_LOAD_BALANCER                   EntityDTO_EntityType = 47
	EntityDTO_BUSINESS_APPLICATION            EntityDTO_EntityType = 48
	EntityDTO_PROCESSOR_POOL                  EntityDTO_EntityType = 49
	EntityDTO_STORAGE_VOLUME                  EntityDTO_EntityType = 50
	EntityDTO_RESERVED_INSTANCE               EntityDTO_EntityType = 51
	EntityDTO_RESERVED_INSTANCE_SPECIFICATION EntityDTO_EntityType = 52
	EntityDTO_DESIRED_RESERVED_INSTANCE       EntityDTO_EntityType = 53
	EntityDTO_REGION                          EntityDTO_EntityType = 54
	EntityDTO_AVAILABILITY_ZONE               EntityDTO_EntityType = 55
	EntityDTO_COMPUTE_TIER                    EntityDTO_EntityType = 56
	EntityDTO_STORAGE_TIER                    EntityDTO_EntityType = 57
	EntityDTO_DATABASE_TIER                   EntityDTO_EntityType = 58
	EntityDTO_DATABASE_SERVER_TIER            EntityDTO_EntityType = 59
	EntityDTO_VIRTUAL_VOLUME                  EntityDTO_EntityType = 60
	EntityDTO_VIEW_POD                        EntityDTO_EntityType = 61
	EntityDTO_DESKTOP_POOL                    EntityDTO_EntityType = 62
	// 2047 is the largest tag value encoded in 2 bytes
	EntityDTO_UNKNOWN EntityDTO_EntityType = 2047
)

var EntityDTO_EntityType_name = map[int32]string{
	0:    "SWITCH",
	1:    "VIRTUAL_DATACENTER",
	2:    "STORAGE",
	3:    "SERVICE",
	4:    "DATABASE_SERVER",
	5:    "SAVINGS",
	6:    "OPERATOR",
	7:    "WEB_SERVER",
	8:    "RIGHT_SIZER",
	9:    "THREE_TIER_APPLICATION",
	10:   "VIRTUAL_MACHINE",
	11:   "DISK_ARRAY",
	12:   "DATACENTER",
	13:   "INFRASTRUCTURE",
	14:   "PHYSICAL_MACHINE",
	15:   "CHASSIS",
	16:   "LICENSING_SERVICE",
	17:   "BUSINESS_USER",
	18:   "STORAGE_CONTROLLER",
	19:   "HYPERVISOR_SERVER",
	20:   "BUSINESS_ENTITY",
	21:   "IO_MODULE",
	22:   "ACTION_MANAGER",
	23:   "VLAN",
	24:   "APPLICATION_SERVER",
	25:   "BUSINESS",
	26:   "VIRTUAL_APPLICATION",
	27:   "NETWORKING_ENDPOINT",
	28:   "BUSINESS_ACCOUNT",
	29:   "IP",
	30:   "SERVICE_ENTITY_TEMPLATE",
	31:   "PORT",
	32:   "NETWORK",
	33:   "APPLICATION",
	34:   "THIS_ENTITY",
	35:   "COMPUTE_RESOURCE",
	36:   "MAC",
	37:   "INTERNET",
	38:   "MOVER",
	39:   "DISTRIBUTED_VIRTUAL_PORTGROUP",
	40:   "CONTAINER",
	41:   "CONTAINER_POD",
	42:   "LOGICAL_POOL",
	43:   "CLOUD_SERVICE",
	44:   "DPOD",
	45:   "VPOD",
	46:   "DATABASE",
	47:   "LOAD_BALANCER",
	48:   "BUSINESS_APPLICATION",
	49:   "PROCESSOR_POOL",
	50:   "STORAGE_VOLUME",
	51:   "RESERVED_INSTANCE",
	52:   "RESERVED_INSTANCE_SPECIFICATION",
	53:   "DESIRED_RESERVED_INSTANCE",
	54:   "REGION",
	55:   "AVAILABILITY_ZONE",
	56:   "COMPUTE_TIER",
	57:   "STORAGE_TIER",
	58:   "DATABASE_TIER",
	59:   "DATABASE_SERVER_TIER",
	60:   "VIRTUAL_VOLUME",
	61:   "VIEW_POD",
	62:   "DESKTOP_POOL",
	2047: "UNKNOWN",
}
var EntityDTO_EntityType_value = map[string]int32{
	"SWITCH":                          0,
	"VIRTUAL_DATACENTER":              1,
	"STORAGE":                         2,
	"SERVICE":                         3,
	"DATABASE_SERVER":                 4,
	"SAVINGS":                         5,
	"OPERATOR":                        6,
	"WEB_SERVER":                      7,
	"RIGHT_SIZER":                     8,
	"THREE_TIER_APPLICATION":          9,
	"VIRTUAL_MACHINE":                 10,
	"DISK_ARRAY":                      11,
	"DATACENTER":                      12,
	"INFRASTRUCTURE":                  13,
	"PHYSICAL_MACHINE":                14,
	"CHASSIS":                         15,
	"LICENSING_SERVICE":               16,
	"BUSINESS_USER":                   17,
	"STORAGE_CONTROLLER":              18,
	"HYPERVISOR_SERVER":               19,
	"BUSINESS_ENTITY":                 20,
	"IO_MODULE":                       21,
	"ACTION_MANAGER":                  22,
	"VLAN":                            23,
	"APPLICATION_SERVER":              24,
	"BUSINESS":                        25,
	"VIRTUAL_APPLICATION":             26,
	"NETWORKING_ENDPOINT":             27,
	"BUSINESS_ACCOUNT":                28,
	"IP":                              29,
	"SERVICE_ENTITY_TEMPLATE":         30,
	"PORT":                            31,
	"NETWORK":                         32,
	"APPLICATION":                     33,
	"THIS_ENTITY":                     34,
	"COMPUTE_RESOURCE":                35,
	"MAC":                             36,
	"INTERNET":                        37,
	"MOVER":                           38,
	"DISTRIBUTED_VIRTUAL_PORTGROUP":   39,
	"CONTAINER":                       40,
	"CONTAINER_POD":                   41,
	"LOGICAL_POOL":                    42,
	"CLOUD_SERVICE":                   43,
	"DPOD":                            44,
	"VPOD":                            45,
	"DATABASE":                        46,
	"LOAD_BALANCER":                   47,
	"BUSINESS_APPLICATION":            48,
	"PROCESSOR_POOL":                  49,
	"STORAGE_VOLUME":                  50,
	"RESERVED_INSTANCE":               51,
	"RESERVED_INSTANCE_SPECIFICATION": 52,
	"DESIRED_RESERVED_INSTANCE":       53,
	"REGION":                          54,
	"AVAILABILITY_ZONE":               55,
	"COMPUTE_TIER":                    56,
	"STORAGE_TIER":                    57,
	"DATABASE_TIER":                   58,
	"DATABASE_SERVER_TIER":            59,
	"VIRTUAL_VOLUME":                  60,
	"VIEW_POD":                        61,
	"DESKTOP_POOL":                    62,
	"UNKNOWN":                         2047,
}

func (x EntityDTO_EntityType) Enum() *EntityDTO_EntityType {
	p := new(EntityDTO_EntityType)
	*p = x
	return p
}
func (x EntityDTO_EntityType) String() string {
	return proto.EnumName(EntityDTO_EntityType_name, int32(x))
}
func (x *EntityDTO_EntityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_EntityType_value, data, "EntityDTO_EntityType")
	if err != nil {
		return err
	}
	*x = EntityDTO_EntityType(value)
	return nil
}
func (EntityDTO_EntityType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 0} }

// Enum for power state.
type EntityDTO_PowerState int32

const (
	EntityDTO_POWERED_ON         EntityDTO_PowerState = 1
	EntityDTO_POWERED_OFF        EntityDTO_PowerState = 2
	EntityDTO_SUSPENDED          EntityDTO_PowerState = 3
	EntityDTO_POWERSTATE_UNKNOWN EntityDTO_PowerState = 4
)

var EntityDTO_PowerState_name = map[int32]string{
	1: "POWERED_ON",
	2: "POWERED_OFF",
	3: "SUSPENDED",
	4: "POWERSTATE_UNKNOWN",
}
var EntityDTO_PowerState_value = map[string]int32{
	"POWERED_ON":         1,
	"POWERED_OFF":        2,
	"SUSPENDED":          3,
	"POWERSTATE_UNKNOWN": 4,
}

func (x EntityDTO_PowerState) Enum() *EntityDTO_PowerState {
	p := new(EntityDTO_PowerState)
	*p = x
	return p
}
func (x EntityDTO_PowerState) String() string {
	return proto.EnumName(EntityDTO_PowerState_name, int32(x))
}
func (x *EntityDTO_PowerState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_PowerState_value, data, "EntityDTO_PowerState")
	if err != nil {
		return err
	}
	*x = EntityDTO_PowerState(value)
	return nil
}
func (EntityDTO_PowerState) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 1} }

type EntityDTO_StorageRedundancyMethod int32

const (
	EntityDTO_RAID0 EntityDTO_StorageRedundancyMethod = 0
	EntityDTO_RAID1 EntityDTO_StorageRedundancyMethod = 1
	EntityDTO_RAID5 EntityDTO_StorageRedundancyMethod = 5
	EntityDTO_RAID6 EntityDTO_StorageRedundancyMethod = 6
)

var EntityDTO_StorageRedundancyMethod_name = map[int32]string{
	0: "RAID0",
	1: "RAID1",
	5: "RAID5",
	6: "RAID6",
}
var EntityDTO_StorageRedundancyMethod_value = map[string]int32{
	"RAID0": 0,
	"RAID1": 1,
	"RAID5": 5,
	"RAID6": 6,
}

func (x EntityDTO_StorageRedundancyMethod) Enum() *EntityDTO_StorageRedundancyMethod {
	p := new(EntityDTO_StorageRedundancyMethod)
	*p = x
	return p
}
func (x EntityDTO_StorageRedundancyMethod) String() string {
	return proto.EnumName(EntityDTO_StorageRedundancyMethod_name, int32(x))
}
func (x *EntityDTO_StorageRedundancyMethod) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_StorageRedundancyMethod_value, data, "EntityDTO_StorageRedundancyMethod")
	if err != nil {
		return err
	}
	*x = EntityDTO_StorageRedundancyMethod(value)
	return nil
}
func (EntityDTO_StorageRedundancyMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 2}
}

// Enum for storage type.
type EntityDTO_StorageType int32

const (
	EntityDTO_GENERIC_BLOCK       EntityDTO_StorageType = 1
	EntityDTO_ISCSI               EntityDTO_StorageType = 2
	EntityDTO_FIBER_CHANNEL       EntityDTO_StorageType = 3
	EntityDTO_FCOE                EntityDTO_StorageType = 4
	EntityDTO_OBJECT              EntityDTO_StorageType = 5
	EntityDTO_GENERIC_FILE_SYSTEM EntityDTO_StorageType = 6
	EntityDTO_NFS                 EntityDTO_StorageType = 7
	EntityDTO_CIFS_SMB            EntityDTO_StorageType = 8
	EntityDTO_LOCAL               EntityDTO_StorageType = 9
	EntityDTO_OTHER               EntityDTO_StorageType = 10
	EntityDTO_VMFS                EntityDTO_StorageType = 11
	EntityDTO_VSAN                EntityDTO_StorageType = 12
)

var EntityDTO_StorageType_name = map[int32]string{
	1:  "GENERIC_BLOCK",
	2:  "ISCSI",
	3:  "FIBER_CHANNEL",
	4:  "FCOE",
	5:  "OBJECT",
	6:  "GENERIC_FILE_SYSTEM",
	7:  "NFS",
	8:  "CIFS_SMB",
	9:  "LOCAL",
	10: "OTHER",
	11: "VMFS",
	12: "VSAN",
}
var EntityDTO_StorageType_value = map[string]int32{
	"GENERIC_BLOCK":       1,
	"ISCSI":               2,
	"FIBER_CHANNEL":       3,
	"FCOE":                4,
	"OBJECT":              5,
	"GENERIC_FILE_SYSTEM": 6,
	"NFS":                 7,
	"CIFS_SMB":            8,
	"LOCAL":               9,
	"OTHER":               10,
	"VMFS":                11,
	"VSAN":                12,
}

func (x EntityDTO_StorageType) Enum() *EntityDTO_StorageType {
	p := new(EntityDTO_StorageType)
	*p = x
	return p
}
func (x EntityDTO_StorageType) String() string {
	return proto.EnumName(EntityDTO_StorageType_name, int32(x))
}
func (x *EntityDTO_StorageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_StorageType_value, data, "EntityDTO_StorageType")
	if err != nil {
		return err
	}
	*x = EntityDTO_StorageType(value)
	return nil
}
func (EntityDTO_StorageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 3} }

// Type of a file in use by the virtual machine
type EntityDTO_VirtualMachineFileType int32

const (
	EntityDTO_CONFIGURATION EntityDTO_VirtualMachineFileType = 1
	EntityDTO_DISK          EntityDTO_VirtualMachineFileType = 2
	EntityDTO_SNAPSHOT      EntityDTO_VirtualMachineFileType = 3
	EntityDTO_MEMORY        EntityDTO_VirtualMachineFileType = 4
	EntityDTO_SWAP          EntityDTO_VirtualMachineFileType = 5
	EntityDTO_LOG           EntityDTO_VirtualMachineFileType = 6
	EntityDTO_ISO           EntityDTO_VirtualMachineFileType = 7
	EntityDTO_ESXCONSOLE    EntityDTO_VirtualMachineFileType = 8
)

var EntityDTO_VirtualMachineFileType_name = map[int32]string{
	1: "CONFIGURATION",
	2: "DISK",
	3: "SNAPSHOT",
	4: "MEMORY",
	5: "SWAP",
	6: "LOG",
	7: "ISO",
	8: "ESXCONSOLE",
}
var EntityDTO_VirtualMachineFileType_value = map[string]int32{
	"CONFIGURATION": 1,
	"DISK":          2,
	"SNAPSHOT":      3,
	"MEMORY":        4,
	"SWAP":          5,
	"LOG":           6,
	"ISO":           7,
	"ESXCONSOLE":    8,
}

func (x EntityDTO_VirtualMachineFileType) Enum() *EntityDTO_VirtualMachineFileType {
	p := new(EntityDTO_VirtualMachineFileType)
	*p = x
	return p
}
func (x EntityDTO_VirtualMachineFileType) String() string {
	return proto.EnumName(EntityDTO_VirtualMachineFileType_name, int32(x))
}
func (x *EntityDTO_VirtualMachineFileType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_VirtualMachineFileType_value, data, "EntityDTO_VirtualMachineFileType")
	if err != nil {
		return err
	}
	*x = EntityDTO_VirtualMachineFileType(value)
	return nil
}
func (EntityDTO_VirtualMachineFileType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 4}
}

// disk type for Ephemeral storages
type EntityDTO_InstanceDiskType int32

const (
	EntityDTO_NONE EntityDTO_InstanceDiskType = 1
	// AWS HDD
	EntityDTO_HDD EntityDTO_InstanceDiskType = 2
	// AWS SSD
	EntityDTO_SSD EntityDTO_InstanceDiskType = 3
	// AWS  non-volatile memory express
	EntityDTO_NVME_SSD EntityDTO_InstanceDiskType = 4
	// Azure standard storage
	EntityDTO_AZURE_HDD EntityDTO_InstanceDiskType = 10
	// Azure premium storage
	EntityDTO_AZURE_SSD EntityDTO_InstanceDiskType = 11
)

var EntityDTO_InstanceDiskType_name = map[int32]string{
	1:  "NONE",
	2:  "HDD",
	3:  "SSD",
	4:  "NVME_SSD",
	10: "AZURE_HDD",
	11: "AZURE_SSD",
}
var EntityDTO_InstanceDiskType_value = map[string]int32{
	"NONE":      1,
	"HDD":       2,
	"SSD":       3,
	"NVME_SSD":  4,
	"AZURE_HDD": 10,
	"AZURE_SSD": 11,
}

func (x EntityDTO_InstanceDiskType) Enum() *EntityDTO_InstanceDiskType {
	p := new(EntityDTO_InstanceDiskType)
	*p = x
	return p
}
func (x EntityDTO_InstanceDiskType) String() string {
	return proto.EnumName(EntityDTO_InstanceDiskType_name, int32(x))
}
func (x *EntityDTO_InstanceDiskType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_InstanceDiskType_value, data, "EntityDTO_InstanceDiskType")
	if err != nil {
		return err
	}
	*x = EntityDTO_InstanceDiskType(value)
	return nil
}
func (EntityDTO_InstanceDiskType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 5}
}

// Type of license model (BYOL or license included)
type EntityDTO_LicenseModel int32

const (
	// the license price is included in the total compute price
	EntityDTO_LICENSE_INCLUDED EntityDTO_LicenseModel = 1
	// Azure Hybrid Benefit - Windows Bring Your Own License
	EntityDTO_AHUB EntityDTO_LicenseModel = 2
)

var EntityDTO_LicenseModel_name = map[int32]string{
	1: "LICENSE_INCLUDED",
	2: "AHUB",
}
var EntityDTO_LicenseModel_value = map[string]int32{
	"LICENSE_INCLUDED": 1,
	"AHUB":             2,
}

func (x EntityDTO_LicenseModel) Enum() *EntityDTO_LicenseModel {
	p := new(EntityDTO_LicenseModel)
	*p = x
	return p
}
func (x EntityDTO_LicenseModel) String() string {
	return proto.EnumName(EntityDTO_LicenseModel_name, int32(x))
}
func (x *EntityDTO_LicenseModel) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_LicenseModel_value, data, "EntityDTO_LicenseModel")
	if err != nil {
		return err
	}
	*x = EntityDTO_LicenseModel(value)
	return nil
}
func (EntityDTO_LicenseModel) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 6} }

// A virtual datacenter may be either a consumer or producer
type EntityDTO_VirtualDatacenterRole int32

const (
	EntityDTO_CONSUMER EntityDTO_VirtualDatacenterRole = 1
	EntityDTO_PRODUCER EntityDTO_VirtualDatacenterRole = 2
)

var EntityDTO_VirtualDatacenterRole_name = map[int32]string{
	1: "CONSUMER",
	2: "PRODUCER",
}
var EntityDTO_VirtualDatacenterRole_value = map[string]int32{
	"CONSUMER": 1,
	"PRODUCER": 2,
}

func (x EntityDTO_VirtualDatacenterRole) Enum() *EntityDTO_VirtualDatacenterRole {
	p := new(EntityDTO_VirtualDatacenterRole)
	*p = x
	return p
}
func (x EntityDTO_VirtualDatacenterRole) String() string {
	return proto.EnumName(EntityDTO_VirtualDatacenterRole_name, int32(x))
}
func (x *EntityDTO_VirtualDatacenterRole) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_VirtualDatacenterRole_value, data, "EntityDTO_VirtualDatacenterRole")
	if err != nil {
		return err
	}
	*x = EntityDTO_VirtualDatacenterRole(value)
	return nil
}
func (EntityDTO_VirtualDatacenterRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 7}
}

// A virtual datacenter allocation model may be either allocationpool, payasyougo, or
// reservationpool
type EntityDTO_VirtualDatacenterAllocationModel int32

const (
	EntityDTO_ALLOCATION_POOL  EntityDTO_VirtualDatacenterAllocationModel = 1
	EntityDTO_PAY_AS_YOU_GO    EntityDTO_VirtualDatacenterAllocationModel = 2
	EntityDTO_RESERVATION_POOL EntityDTO_VirtualDatacenterAllocationModel = 3
)

var EntityDTO_VirtualDatacenterAllocationModel_name = map[int32]string{
	1: "ALLOCATION_POOL",
	2: "PAY_AS_YOU_GO",
	3: "RESERVATION_POOL",
}
var EntityDTO_VirtualDatacenterAllocationModel_value = map[string]int32{
	"ALLOCATION_POOL":  1,
	"PAY_AS_YOU_GO":    2,
	"RESERVATION_POOL": 3,
}

func (x EntityDTO_VirtualDatacenterAllocationModel) Enum() *EntityDTO_VirtualDatacenterAllocationModel {
	p := new(EntityDTO_VirtualDatacenterAllocationModel)
	*p = x
	return p
}
func (x EntityDTO_VirtualDatacenterAllocationModel) String() string {
	return proto.EnumName(EntityDTO_VirtualDatacenterAllocationModel_name, int32(x))
}
func (x *EntityDTO_VirtualDatacenterAllocationModel) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_VirtualDatacenterAllocationModel_value, data, "EntityDTO_VirtualDatacenterAllocationModel")
	if err != nil {
		return err
	}
	*x = EntityDTO_VirtualDatacenterAllocationModel(value)
	return nil
}
func (EntityDTO_VirtualDatacenterAllocationModel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 8}
}

// Represents the role of a disk in providing actual storage capacity or
// providing cache.  Only capacity disk will increase the capacity of the
// Storage array.
type EntityDTO_DiskRole int32

const (
	// This is a cache disk
	EntityDTO_ROLE_CACHE EntityDTO_DiskRole = 1
	// This is a capacity disk
	EntityDTO_ROLE_CAPACITY EntityDTO_DiskRole = 2
)

var EntityDTO_DiskRole_name = map[int32]string{
	1: "ROLE_CACHE",
	2: "ROLE_CAPACITY",
}
var EntityDTO_DiskRole_value = map[string]int32{
	"ROLE_CACHE":    1,
	"ROLE_CAPACITY": 2,
}

func (x EntityDTO_DiskRole) Enum() *EntityDTO_DiskRole {
	p := new(EntityDTO_DiskRole)
	*p = x
	return p
}
func (x EntityDTO_DiskRole) String() string {
	return proto.EnumName(EntityDTO_DiskRole_name, int32(x))
}
func (x *EntityDTO_DiskRole) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_DiskRole_value, data, "EntityDTO_DiskRole")
	if err != nil {
		return err
	}
	*x = EntityDTO_DiskRole(value)
	return nil
}
func (EntityDTO_DiskRole) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 9} }

// Names for communicating the number of various types of disks.
type EntityDTO_IopsItemNames int32

const (
	// Number of discovered solid state drives.
	EntityDTO_NUM_SSD EntityDTO_IopsItemNames = 1
	// Number of discovered 7200 RPM disks.
	EntityDTO_NUM_7200_DISKS EntityDTO_IopsItemNames = 2
	// Number of discovered 10000 RPM disks.
	EntityDTO_NUM_10K_DISKS EntityDTO_IopsItemNames = 3
	// Number of discovered 15000 RPM disks.
	EntityDTO_NUM_15K_DISKS EntityDTO_IopsItemNames = 4
	// Number of discovered VSeries disks.
	EntityDTO_NUM_VSERIES_DISKS EntityDTO_IopsItemNames = 5
	// Number of IOPS Supported, as discovered by probe, to replace old iopsCapacity field
	EntityDTO_NUM_IOPS_SUPPORTED EntityDTO_IopsItemNames = 6
)

var EntityDTO_IopsItemNames_name = map[int32]string{
	1: "NUM_SSD",
	2: "NUM_7200_DISKS",
	3: "NUM_10K_DISKS",
	4: "NUM_15K_DISKS",
	5: "NUM_VSERIES_DISKS",
	6: "NUM_IOPS_SUPPORTED",
}
var EntityDTO_IopsItemNames_value = map[string]int32{
	"NUM_SSD":            1,
	"NUM_7200_DISKS":     2,
	"NUM_10K_DISKS":      3,
	"NUM_15K_DISKS":      4,
	"NUM_VSERIES_DISKS":  5,
	"NUM_IOPS_SUPPORTED": 6,
}

func (x EntityDTO_IopsItemNames) Enum() *EntityDTO_IopsItemNames {
	p := new(EntityDTO_IopsItemNames)
	*p = x
	return p
}
func (x EntityDTO_IopsItemNames) String() string {
	return proto.EnumName(EntityDTO_IopsItemNames_name, int32(x))
}
func (x *EntityDTO_IopsItemNames) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_IopsItemNames_value, data, "EntityDTO_IopsItemNames")
	if err != nil {
		return err
	}
	*x = EntityDTO_IopsItemNames(value)
	return nil
}
func (EntityDTO_IopsItemNames) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 10} }

// Specifies the origin of an entity, either DISCOVERED or PROXY
// DISCOVERED: An entity discovered by the probe that maps to a real resource found
// when probing the target.
// PROXY: An entity supplied by the probe to fill out a required part of the supply chain.
// For example, a probe discovering Virtual Machines may supply a Guestload Application proxy
// to complete its supply chain.
// Some proxy entities may be replaced by discovered entities found by another probe."
type EntityDTO_EntityOrigin int32

const (
	EntityDTO_DISCOVERED  EntityDTO_EntityOrigin = 1
	EntityDTO_PROXY       EntityDTO_EntityOrigin = 2
	EntityDTO_REPLACEABLE EntityDTO_EntityOrigin = 3
)

var EntityDTO_EntityOrigin_name = map[int32]string{
	1: "DISCOVERED",
	2: "PROXY",
	3: "REPLACEABLE",
}
var EntityDTO_EntityOrigin_value = map[string]int32{
	"DISCOVERED":  1,
	"PROXY":       2,
	"REPLACEABLE": 3,
}

func (x EntityDTO_EntityOrigin) Enum() *EntityDTO_EntityOrigin {
	p := new(EntityDTO_EntityOrigin)
	*p = x
	return p
}
func (x EntityDTO_EntityOrigin) String() string {
	return proto.EnumName(EntityDTO_EntityOrigin_name, int32(x))
}
func (x *EntityDTO_EntityOrigin) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_EntityOrigin_value, data, "EntityDTO_EntityOrigin")
	if err != nil {
		return err
	}
	*x = EntityDTO_EntityOrigin(value)
	return nil
}
func (EntityDTO_EntityOrigin) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 11} }

type EntityDTO_ComputeTierData_DedicatedStorageNetworkState int32

const (
	// Dedicated storage network is not supported by compute tier
	EntityDTO_ComputeTierData_NOT_SUPPORTED EntityDTO_ComputeTierData_DedicatedStorageNetworkState = 1
	// Dedicated storage network is supported by compute tier and is configured as disabled.
	EntityDTO_ComputeTierData_CONFIGURED_DISABLED EntityDTO_ComputeTierData_DedicatedStorageNetworkState = 2
	// Dedicated storage network is supported by compute tier and is configured as enabled.
	EntityDTO_ComputeTierData_CONFIGURED_ENABLED EntityDTO_ComputeTierData_DedicatedStorageNetworkState = 3
	// Dedicated storage network is enabled by compute tier by default and is not changeable.
	EntityDTO_ComputeTierData_ENABLED_BY_DEFAULT EntityDTO_ComputeTierData_DedicatedStorageNetworkState = 4
)

var EntityDTO_ComputeTierData_DedicatedStorageNetworkState_name = map[int32]string{
	1: "NOT_SUPPORTED",
	2: "CONFIGURED_DISABLED",
	3: "CONFIGURED_ENABLED",
	4: "ENABLED_BY_DEFAULT",
}
var EntityDTO_ComputeTierData_DedicatedStorageNetworkState_value = map[string]int32{
	"NOT_SUPPORTED":       1,
	"CONFIGURED_DISABLED": 2,
	"CONFIGURED_ENABLED":  3,
	"ENABLED_BY_DEFAULT":  4,
}

func (x EntityDTO_ComputeTierData_DedicatedStorageNetworkState) Enum() *EntityDTO_ComputeTierData_DedicatedStorageNetworkState {
	p := new(EntityDTO_ComputeTierData_DedicatedStorageNetworkState)
	*p = x
	return p
}
func (x EntityDTO_ComputeTierData_DedicatedStorageNetworkState) String() string {
	return proto.EnumName(EntityDTO_ComputeTierData_DedicatedStorageNetworkState_name, int32(x))
}
func (x *EntityDTO_ComputeTierData_DedicatedStorageNetworkState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_ComputeTierData_DedicatedStorageNetworkState_value, data, "EntityDTO_ComputeTierData_DedicatedStorageNetworkState")
	if err != nil {
		return err
	}
	*x = EntityDTO_ComputeTierData_DedicatedStorageNetworkState(value)
	return nil
}
func (EntityDTO_ComputeTierData_DedicatedStorageNetworkState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 13, 0}
}

// Description of a volume's relationship with VM or lack thereof
type EntityDTO_VirtualVolumeData_AttachmentState int32

const (
	// in use by a (potentially undiscovered) VM
	EntityDTO_VirtualVolumeData_ATTACHED EntityDTO_VirtualVolumeData_AttachmentState = 0
	// unused by any VM
	EntityDTO_VirtualVolumeData_UNATTACHED EntityDTO_VirtualVolumeData_AttachmentState = 1
)

var EntityDTO_VirtualVolumeData_AttachmentState_name = map[int32]string{
	0: "ATTACHED",
	1: "UNATTACHED",
}
var EntityDTO_VirtualVolumeData_AttachmentState_value = map[string]int32{
	"ATTACHED":   0,
	"UNATTACHED": 1,
}

func (x EntityDTO_VirtualVolumeData_AttachmentState) Enum() *EntityDTO_VirtualVolumeData_AttachmentState {
	p := new(EntityDTO_VirtualVolumeData_AttachmentState)
	*p = x
	return p
}
func (x EntityDTO_VirtualVolumeData_AttachmentState) String() string {
	return proto.EnumName(EntityDTO_VirtualVolumeData_AttachmentState_name, int32(x))
}
func (x *EntityDTO_VirtualVolumeData_AttachmentState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_VirtualVolumeData_AttachmentState_value, data, "EntityDTO_VirtualVolumeData_AttachmentState")
	if err != nil {
		return err
	}
	*x = EntityDTO_VirtualVolumeData_AttachmentState(value)
	return nil
}
func (EntityDTO_VirtualVolumeData_AttachmentState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 14, 0}
}

// different replication options supported by Azure storage, more details:
// https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy
type EntityDTO_VirtualVolumeData_RedundancyType int32

const (
	// Locally redundant storage
	EntityDTO_VirtualVolumeData_LRS EntityDTO_VirtualVolumeData_RedundancyType = 1
	// Zone-redundant storage
	EntityDTO_VirtualVolumeData_ZRS EntityDTO_VirtualVolumeData_RedundancyType = 2
	// Geo-redundant storage
	EntityDTO_VirtualVolumeData_GRS EntityDTO_VirtualVolumeData_RedundancyType = 3
	// Read-access geo-redundant storage
	EntityDTO_VirtualVolumeData_RAGRS EntityDTO_VirtualVolumeData_RedundancyType = 4
)

var EntityDTO_VirtualVolumeData_RedundancyType_name = map[int32]string{
	1: "LRS",
	2: "ZRS",
	3: "GRS",
	4: "RAGRS",
}
var EntityDTO_VirtualVolumeData_RedundancyType_value = map[string]int32{
	"LRS":   1,
	"ZRS":   2,
	"GRS":   3,
	"RAGRS": 4,
}

func (x EntityDTO_VirtualVolumeData_RedundancyType) Enum() *EntityDTO_VirtualVolumeData_RedundancyType {
	p := new(EntityDTO_VirtualVolumeData_RedundancyType)
	*p = x
	return p
}
func (x EntityDTO_VirtualVolumeData_RedundancyType) String() string {
	return proto.EnumName(EntityDTO_VirtualVolumeData_RedundancyType_name, int32(x))
}
func (x *EntityDTO_VirtualVolumeData_RedundancyType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_VirtualVolumeData_RedundancyType_value, data, "EntityDTO_VirtualVolumeData_RedundancyType")
	if err != nil {
		return err
	}
	*x = EntityDTO_VirtualVolumeData_RedundancyType(value)
	return nil
}
func (EntityDTO_VirtualVolumeData_RedundancyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 14, 1}
}

type EntityDTO_VirtualMachineData_VMBillingType int32

const (
	// Regular on-demand VMs - this is the default type.
	//
	EntityDTO_VirtualMachineData_ONDEMAND EntityDTO_VirtualMachineData_VMBillingType = 0
	// VM bids for compute resources but could be interrupted - lower pricing.
	// In AWS, it is called fleet Spot Instances.
	// In Azure, it is called low priority VMs.
	// In GCE, it is called preemptible VMs.
	//
	EntityDTO_VirtualMachineData_BIDDING EntityDTO_VirtualMachineData_VMBillingType = 1
	// VM runs on a dedicated host - higher pricing.
	//
	EntityDTO_VirtualMachineData_DEDICATED EntityDTO_VirtualMachineData_VMBillingType = 2
	// Reserved in advance - great pricing.
	//
	EntityDTO_VirtualMachineData_RESERVED EntityDTO_VirtualMachineData_VMBillingType = 3
	// A hybrid of different cost types. For example, partial ONDEMAND and partial RESERVED
	//
	EntityDTO_VirtualMachineData_HYBRID EntityDTO_VirtualMachineData_VMBillingType = 4
)

var EntityDTO_VirtualMachineData_VMBillingType_name = map[int32]string{
	0: "ONDEMAND",
	1: "BIDDING",
	2: "DEDICATED",
	3: "RESERVED",
	4: "HYBRID",
}
var EntityDTO_VirtualMachineData_VMBillingType_value = map[string]int32{
	"ONDEMAND":  0,
	"BIDDING":   1,
	"DEDICATED": 2,
	"RESERVED":  3,
	"HYBRID":    4,
}

func (x EntityDTO_VirtualMachineData_VMBillingType) Enum() *EntityDTO_VirtualMachineData_VMBillingType {
	p := new(EntityDTO_VirtualMachineData_VMBillingType)
	*p = x
	return p
}
func (x EntityDTO_VirtualMachineData_VMBillingType) String() string {
	return proto.EnumName(EntityDTO_VirtualMachineData_VMBillingType_name, int32(x))
}
func (x *EntityDTO_VirtualMachineData_VMBillingType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_VirtualMachineData_VMBillingType_value, data, "EntityDTO_VirtualMachineData_VMBillingType")
	if err != nil {
		return err
	}
	*x = EntityDTO_VirtualMachineData_VMBillingType(value)
	return nil
}
func (EntityDTO_VirtualMachineData_VMBillingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 15, 0}
}

// when desktops are created
type EntityDTO_DesktopPoolData_DesktopPoolProvisionType int32

const (
	// when users connect
	EntityDTO_DesktopPoolData_ON_DEMAND EntityDTO_DesktopPoolData_DesktopPoolProvisionType = 0
	// when pool is created
	EntityDTO_DesktopPoolData_UPFRONT EntityDTO_DesktopPoolData_DesktopPoolProvisionType = 1
)

var EntityDTO_DesktopPoolData_DesktopPoolProvisionType_name = map[int32]string{
	0: "ON_DEMAND",
	1: "UPFRONT",
}
var EntityDTO_DesktopPoolData_DesktopPoolProvisionType_value = map[string]int32{
	"ON_DEMAND": 0,
	"UPFRONT":   1,
}

func (x EntityDTO_DesktopPoolData_DesktopPoolProvisionType) Enum() *EntityDTO_DesktopPoolData_DesktopPoolProvisionType {
	p := new(EntityDTO_DesktopPoolData_DesktopPoolProvisionType)
	*p = x
	return p
}
func (x EntityDTO_DesktopPoolData_DesktopPoolProvisionType) String() string {
	return proto.EnumName(EntityDTO_DesktopPoolData_DesktopPoolProvisionType_name, int32(x))
}
func (x *EntityDTO_DesktopPoolData_DesktopPoolProvisionType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_DesktopPoolData_DesktopPoolProvisionType_value, data, "EntityDTO_DesktopPoolData_DesktopPoolProvisionType")
	if err != nil {
		return err
	}
	*x = EntityDTO_DesktopPoolData_DesktopPoolProvisionType(value)
	return nil
}
func (EntityDTO_DesktopPoolData_DesktopPoolProvisionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 25, 0}
}

// type (engine) of a desktop created in the pool
type EntityDTO_DesktopPoolData_DesktopPoolCloneType int32

const (
	EntityDTO_DesktopPoolData_FULL    EntityDTO_DesktopPoolData_DesktopPoolCloneType = 0
	EntityDTO_DesktopPoolData_LINKED  EntityDTO_DesktopPoolData_DesktopPoolCloneType = 1
	EntityDTO_DesktopPoolData_INSTANT EntityDTO_DesktopPoolData_DesktopPoolCloneType = 2
)

var EntityDTO_DesktopPoolData_DesktopPoolCloneType_name = map[int32]string{
	0: "FULL",
	1: "LINKED",
	2: "INSTANT",
}
var EntityDTO_DesktopPoolData_DesktopPoolCloneType_value = map[string]int32{
	"FULL":    0,
	"LINKED":  1,
	"INSTANT": 2,
}

func (x EntityDTO_DesktopPoolData_DesktopPoolCloneType) Enum() *EntityDTO_DesktopPoolData_DesktopPoolCloneType {
	p := new(EntityDTO_DesktopPoolData_DesktopPoolCloneType)
	*p = x
	return p
}
func (x EntityDTO_DesktopPoolData_DesktopPoolCloneType) String() string {
	return proto.EnumName(EntityDTO_DesktopPoolData_DesktopPoolCloneType_name, int32(x))
}
func (x *EntityDTO_DesktopPoolData_DesktopPoolCloneType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_DesktopPoolData_DesktopPoolCloneType_value, data, "EntityDTO_DesktopPoolData_DesktopPoolCloneType")
	if err != nil {
		return err
	}
	*x = EntityDTO_DesktopPoolData_DesktopPoolCloneType(value)
	return nil
}
func (EntityDTO_DesktopPoolData_DesktopPoolCloneType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 25, 1}
}

// how desktops are allocated to users
type EntityDTO_DesktopPoolData_DesktopPoolAssignmentType int32

const (
	// random desktop is assigned
	EntityDTO_DesktopPoolData_DYNAMIC EntityDTO_DesktopPoolData_DesktopPoolAssignmentType = 0
	// same desktop every time after re-connect
	EntityDTO_DesktopPoolData_PERSISTENT EntityDTO_DesktopPoolData_DesktopPoolAssignmentType = 1
)

var EntityDTO_DesktopPoolData_DesktopPoolAssignmentType_name = map[int32]string{
	0: "DYNAMIC",
	1: "PERSISTENT",
}
var EntityDTO_DesktopPoolData_DesktopPoolAssignmentType_value = map[string]int32{
	"DYNAMIC":    0,
	"PERSISTENT": 1,
}

func (x EntityDTO_DesktopPoolData_DesktopPoolAssignmentType) Enum() *EntityDTO_DesktopPoolData_DesktopPoolAssignmentType {
	p := new(EntityDTO_DesktopPoolData_DesktopPoolAssignmentType)
	*p = x
	return p
}
func (x EntityDTO_DesktopPoolData_DesktopPoolAssignmentType) String() string {
	return proto.EnumName(EntityDTO_DesktopPoolData_DesktopPoolAssignmentType_name, int32(x))
}
func (x *EntityDTO_DesktopPoolData_DesktopPoolAssignmentType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_DesktopPoolData_DesktopPoolAssignmentType_value, data, "EntityDTO_DesktopPoolData_DesktopPoolAssignmentType")
	if err != nil {
		return err
	}
	*x = EntityDTO_DesktopPoolData_DesktopPoolAssignmentType(value)
	return nil
}
func (EntityDTO_DesktopPoolData_DesktopPoolAssignmentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 25, 2}
}

type EntityDTO_ReservedInstanceData_InstanceTenancy int32

const (
	EntityDTO_ReservedInstanceData_DEFAULT   EntityDTO_ReservedInstanceData_InstanceTenancy = 1
	EntityDTO_ReservedInstanceData_DEDICATED EntityDTO_ReservedInstanceData_InstanceTenancy = 2
	EntityDTO_ReservedInstanceData_HOST      EntityDTO_ReservedInstanceData_InstanceTenancy = 3
)

var EntityDTO_ReservedInstanceData_InstanceTenancy_name = map[int32]string{
	1: "DEFAULT",
	2: "DEDICATED",
	3: "HOST",
}
var EntityDTO_ReservedInstanceData_InstanceTenancy_value = map[string]int32{
	"DEFAULT":   1,
	"DEDICATED": 2,
	"HOST":      3,
}

func (x EntityDTO_ReservedInstanceData_InstanceTenancy) Enum() *EntityDTO_ReservedInstanceData_InstanceTenancy {
	p := new(EntityDTO_ReservedInstanceData_InstanceTenancy)
	*p = x
	return p
}
func (x EntityDTO_ReservedInstanceData_InstanceTenancy) String() string {
	return proto.EnumName(EntityDTO_ReservedInstanceData_InstanceTenancy_name, int32(x))
}
func (x *EntityDTO_ReservedInstanceData_InstanceTenancy) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_ReservedInstanceData_InstanceTenancy_value, data, "EntityDTO_ReservedInstanceData_InstanceTenancy")
	if err != nil {
		return err
	}
	*x = EntityDTO_ReservedInstanceData_InstanceTenancy(value)
	return nil
}
func (EntityDTO_ReservedInstanceData_InstanceTenancy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 43, 0}
}

type EntityDTO_ReservedInstanceData_OfferingClass int32

const (
	EntityDTO_ReservedInstanceData_STANDARD    EntityDTO_ReservedInstanceData_OfferingClass = 1
	EntityDTO_ReservedInstanceData_CONVERTIBLE EntityDTO_ReservedInstanceData_OfferingClass = 2
)

var EntityDTO_ReservedInstanceData_OfferingClass_name = map[int32]string{
	1: "STANDARD",
	2: "CONVERTIBLE",
}
var EntityDTO_ReservedInstanceData_OfferingClass_value = map[string]int32{
	"STANDARD":    1,
	"CONVERTIBLE": 2,
}

func (x EntityDTO_ReservedInstanceData_OfferingClass) Enum() *EntityDTO_ReservedInstanceData_OfferingClass {
	p := new(EntityDTO_ReservedInstanceData_OfferingClass)
	*p = x
	return p
}
func (x EntityDTO_ReservedInstanceData_OfferingClass) String() string {
	return proto.EnumName(EntityDTO_ReservedInstanceData_OfferingClass_name, int32(x))
}
func (x *EntityDTO_ReservedInstanceData_OfferingClass) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_ReservedInstanceData_OfferingClass_value, data, "EntityDTO_ReservedInstanceData_OfferingClass")
	if err != nil {
		return err
	}
	*x = EntityDTO_ReservedInstanceData_OfferingClass(value)
	return nil
}
func (EntityDTO_ReservedInstanceData_OfferingClass) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 43, 1}
}

type EntityDTO_ReservedInstanceData_OfferingType int32

const (
	EntityDTO_ReservedInstanceData_ALL_UPFRONT     EntityDTO_ReservedInstanceData_OfferingType = 1
	EntityDTO_ReservedInstanceData_PARTIAL_UPFRONT EntityDTO_ReservedInstanceData_OfferingType = 2
	EntityDTO_ReservedInstanceData_NO_UPFRONT      EntityDTO_ReservedInstanceData_OfferingType = 3
)

var EntityDTO_ReservedInstanceData_OfferingType_name = map[int32]string{
	1: "ALL_UPFRONT",
	2: "PARTIAL_UPFRONT",
	3: "NO_UPFRONT",
}
var EntityDTO_ReservedInstanceData_OfferingType_value = map[string]int32{
	"ALL_UPFRONT":     1,
	"PARTIAL_UPFRONT": 2,
	"NO_UPFRONT":      3,
}

func (x EntityDTO_ReservedInstanceData_OfferingType) Enum() *EntityDTO_ReservedInstanceData_OfferingType {
	p := new(EntityDTO_ReservedInstanceData_OfferingType)
	*p = x
	return p
}
func (x EntityDTO_ReservedInstanceData_OfferingType) String() string {
	return proto.EnumName(EntityDTO_ReservedInstanceData_OfferingType_name, int32(x))
}
func (x *EntityDTO_ReservedInstanceData_OfferingType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_ReservedInstanceData_OfferingType_value, data, "EntityDTO_ReservedInstanceData_OfferingType")
	if err != nil {
		return err
	}
	*x = EntityDTO_ReservedInstanceData_OfferingType(value)
	return nil
}
func (EntityDTO_ReservedInstanceData_OfferingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 43, 2}
}

type EntityDTO_ReservedInstanceData_Platform int32

const (
	EntityDTO_ReservedInstanceData_UNKNOWN                            EntityDTO_ReservedInstanceData_Platform = 1
	EntityDTO_ReservedInstanceData_LINUX                              EntityDTO_ReservedInstanceData_Platform = 2
	EntityDTO_ReservedInstanceData_RHEL                               EntityDTO_ReservedInstanceData_Platform = 3
	EntityDTO_ReservedInstanceData_SUSE                               EntityDTO_ReservedInstanceData_Platform = 4
	EntityDTO_ReservedInstanceData_WINDOWS                            EntityDTO_ReservedInstanceData_Platform = 5
	EntityDTO_ReservedInstanceData_WINDOWS_WITH_SQL_STANDARD          EntityDTO_ReservedInstanceData_Platform = 6
	EntityDTO_ReservedInstanceData_WINDOWS_WITH_SQL_WEB               EntityDTO_ReservedInstanceData_Platform = 7
	EntityDTO_ReservedInstanceData_WINDOWS_WITH_SQL_SERVER_ENTERPRISE EntityDTO_ReservedInstanceData_Platform = 8
	EntityDTO_ReservedInstanceData_LINUX_WITH_SQL_STANDARD            EntityDTO_ReservedInstanceData_Platform = 9
	EntityDTO_ReservedInstanceData_LINUX_WITH_SQL_WEB                 EntityDTO_ReservedInstanceData_Platform = 10
	EntityDTO_ReservedInstanceData_LINUX_WITH_SQL_SERVER_ENTERPRISE   EntityDTO_ReservedInstanceData_Platform = 11
)

var EntityDTO_ReservedInstanceData_Platform_name = map[int32]string{
	1:  "UNKNOWN",
	2:  "LINUX",
	3:  "RHEL",
	4:  "SUSE",
	5:  "WINDOWS",
	6:  "WINDOWS_WITH_SQL_STANDARD",
	7:  "WINDOWS_WITH_SQL_WEB",
	8:  "WINDOWS_WITH_SQL_SERVER_ENTERPRISE",
	9:  "LINUX_WITH_SQL_STANDARD",
	10: "LINUX_WITH_SQL_WEB",
	11: "LINUX_WITH_SQL_SERVER_ENTERPRISE",
}
var EntityDTO_ReservedInstanceData_Platform_value = map[string]int32{
	"UNKNOWN":                            1,
	"LINUX":                              2,
	"RHEL":                               3,
	"SUSE":                               4,
	"WINDOWS":                            5,
	"WINDOWS_WITH_SQL_STANDARD":          6,
	"WINDOWS_WITH_SQL_WEB":               7,
	"WINDOWS_WITH_SQL_SERVER_ENTERPRISE": 8,
	"LINUX_WITH_SQL_STANDARD":            9,
	"LINUX_WITH_SQL_WEB":                 10,
	"LINUX_WITH_SQL_SERVER_ENTERPRISE":   11,
}

func (x EntityDTO_ReservedInstanceData_Platform) Enum() *EntityDTO_ReservedInstanceData_Platform {
	p := new(EntityDTO_ReservedInstanceData_Platform)
	*p = x
	return p
}
func (x EntityDTO_ReservedInstanceData_Platform) String() string {
	return proto.EnumName(EntityDTO_ReservedInstanceData_Platform_name, int32(x))
}
func (x *EntityDTO_ReservedInstanceData_Platform) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_ReservedInstanceData_Platform_value, data, "EntityDTO_ReservedInstanceData_Platform")
	if err != nil {
		return err
	}
	*x = EntityDTO_ReservedInstanceData_Platform(value)
	return nil
}
func (EntityDTO_ReservedInstanceData_Platform) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 43, 3}
}

type PricingIdentifier_PricingIdentifierName int32

const (
	// The id of a price offering an Azure account is using; used to identify Azure
	// subscriptions pricing
	PricingIdentifier_OFFER_ID PricingIdentifier_PricingIdentifierName = 1
	// The number associated with an Azure enterprise agreement; used to identify
	// Azure subscriptions pricing
	PricingIdentifier_ENROLLMENT_NUMBER PricingIdentifier_PricingIdentifierName = 2
)

var PricingIdentifier_PricingIdentifierName_name = map[int32]string{
	1: "OFFER_ID",
	2: "ENROLLMENT_NUMBER",
}
var PricingIdentifier_PricingIdentifierName_value = map[string]int32{
	"OFFER_ID":          1,
	"ENROLLMENT_NUMBER": 2,
}

func (x PricingIdentifier_PricingIdentifierName) Enum() *PricingIdentifier_PricingIdentifierName {
	p := new(PricingIdentifier_PricingIdentifierName)
	*p = x
	return p
}
func (x PricingIdentifier_PricingIdentifierName) String() string {
	return proto.EnumName(PricingIdentifier_PricingIdentifierName_name, int32(x))
}
func (x *PricingIdentifier_PricingIdentifierName) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PricingIdentifier_PricingIdentifierName_value, data, "PricingIdentifier_PricingIdentifierName")
	if err != nil {
		return err
	}
	*x = PricingIdentifier_PricingIdentifierName(value)
	return nil
}
func (PricingIdentifier_PricingIdentifierName) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{1, 0}
}

type CommodityDTO_CommodityType int32

const (
	CommodityDTO_CLUSTER                    CommodityDTO_CommodityType = 0
	CommodityDTO_THREADS                    CommodityDTO_CommodityType = 1
	CommodityDTO_CPU_ALLOCATION             CommodityDTO_CommodityType = 2
	CommodityDTO_NUMBER_CONSUMERS           CommodityDTO_CommodityType = 3
	CommodityDTO_FLOW_ALLOCATION            CommodityDTO_CommodityType = 4
	CommodityDTO_Q1_VCPU                    CommodityDTO_CommodityType = 5
	CommodityDTO_STORAGE_PROVISIONED        CommodityDTO_CommodityType = 6
	CommodityDTO_LICENSE_COMMODITY          CommodityDTO_CommodityType = 7
	CommodityDTO_STORAGE_AMOUNT             CommodityDTO_CommodityType = 8
	CommodityDTO_Q16_VCPU                   CommodityDTO_CommodityType = 9
	CommodityDTO_Q32_VCPU                   CommodityDTO_CommodityType = 10
	CommodityDTO_SAME_CLUSTER_MOVE_SVC      CommodityDTO_CommodityType = 11
	CommodityDTO_Q3_VCPU                    CommodityDTO_CommodityType = 12
	CommodityDTO_SLA_COMMODITY              CommodityDTO_CommodityType = 13
	CommodityDTO_CROSS_CLUSTER_MOVE_SVC     CommodityDTO_CommodityType = 14
	CommodityDTO_NUMBER_CONSUMERS_PM        CommodityDTO_CommodityType = 15
	CommodityDTO_STORAGE_ALLOCATION         CommodityDTO_CommodityType = 16
	CommodityDTO_Q8_VCPU                    CommodityDTO_CommodityType = 17
	CommodityDTO_SPACE                      CommodityDTO_CommodityType = 18
	CommodityDTO_Q6_VCPU                    CommodityDTO_CommodityType = 19
	CommodityDTO_POWER                      CommodityDTO_CommodityType = 20
	CommodityDTO_MEM                        CommodityDTO_CommodityType = 21
	CommodityDTO_STORAGE_LATENCY            CommodityDTO_CommodityType = 22
	CommodityDTO_Q7_VCPU                    CommodityDTO_CommodityType = 23
	CommodityDTO_COOLING                    CommodityDTO_CommodityType = 24
	CommodityDTO_PORT_CHANEL                CommodityDTO_CommodityType = 25
	CommodityDTO_VCPU                       CommodityDTO_CommodityType = 26
	CommodityDTO_QN_VCPU                    CommodityDTO_CommodityType = 27
	CommodityDTO_CPU_PROVISIONED            CommodityDTO_CommodityType = 28
	CommodityDTO_RIGHT_SIZE_SVC             CommodityDTO_CommodityType = 29
	CommodityDTO_MOVE                       CommodityDTO_CommodityType = 30
	CommodityDTO_Q2_VCPU                    CommodityDTO_CommodityType = 31
	CommodityDTO_Q5_VCPU                    CommodityDTO_CommodityType = 32
	CommodityDTO_SWAPPING                   CommodityDTO_CommodityType = 33
	CommodityDTO_SEGMENTATION               CommodityDTO_CommodityType = 34
	CommodityDTO_FLOW                       CommodityDTO_CommodityType = 35
	CommodityDTO_DATASTORE                  CommodityDTO_CommodityType = 36
	CommodityDTO_CROSS_CLOUD_MOVE_SVC       CommodityDTO_CommodityType = 37
	CommodityDTO_RIGHT_SIZE_DOWN            CommodityDTO_CommodityType = 38
	CommodityDTO_IO_THROUGHPUT              CommodityDTO_CommodityType = 39
	CommodityDTO_CPU                        CommodityDTO_CommodityType = 40
	CommodityDTO_BALLOONING                 CommodityDTO_CommodityType = 41
	CommodityDTO_VDC                        CommodityDTO_CommodityType = 42
	CommodityDTO_Q64_VCPU                   CommodityDTO_CommodityType = 43
	CommodityDTO_CONNECTION                 CommodityDTO_CommodityType = 44
	CommodityDTO_MEM_PROVISIONED            CommodityDTO_CommodityType = 45
	CommodityDTO_STORAGE                    CommodityDTO_CommodityType = 46
	CommodityDTO_NET_THROUGHPUT             CommodityDTO_CommodityType = 47
	CommodityDTO_NUMBER_CONSUMERS_STORAGE   CommodityDTO_CommodityType = 48
	CommodityDTO_TRANSACTION                CommodityDTO_CommodityType = 49
	CommodityDTO_MEM_ALLOCATION             CommodityDTO_CommodityType = 50
	CommodityDTO_DSPM_ACCESS                CommodityDTO_CommodityType = 51
	CommodityDTO_RESPONSE_TIME              CommodityDTO_CommodityType = 52
	CommodityDTO_VMEM                       CommodityDTO_CommodityType = 53
	CommodityDTO_ACTION_PERMIT              CommodityDTO_CommodityType = 54
	CommodityDTO_DATACENTER                 CommodityDTO_CommodityType = 55
	CommodityDTO_APPLICATION                CommodityDTO_CommodityType = 56
	CommodityDTO_NETWORK                    CommodityDTO_CommodityType = 57
	CommodityDTO_Q4_VCPU                    CommodityDTO_CommodityType = 58
	CommodityDTO_STORAGE_CLUSTER            CommodityDTO_CommodityType = 59
	CommodityDTO_EXTENT                     CommodityDTO_CommodityType = 60
	CommodityDTO_ACCESS                     CommodityDTO_CommodityType = 61
	CommodityDTO_RIGHT_SIZE_UP              CommodityDTO_CommodityType = 62
	CommodityDTO_VAPP_ACCESS                CommodityDTO_CommodityType = 63
	CommodityDTO_STORAGE_ACCESS             CommodityDTO_CommodityType = 64
	CommodityDTO_VSTORAGE                   CommodityDTO_CommodityType = 65
	CommodityDTO_DRS_SEGMENTATION           CommodityDTO_CommodityType = 66
	CommodityDTO_DB_MEM                     CommodityDTO_CommodityType = 67
	CommodityDTO_TRANSACTION_LOG            CommodityDTO_CommodityType = 68
	CommodityDTO_DB_CACHE_HIT_RATE          CommodityDTO_CommodityType = 69
	CommodityDTO_HOT_STORAGE                CommodityDTO_CommodityType = 70
	CommodityDTO_COLLECTION_TIME            CommodityDTO_CommodityType = 71
	CommodityDTO_BUFFER_COMMODITY           CommodityDTO_CommodityType = 72
	CommodityDTO_SOFTWARE_LICENSE_COMMODITY CommodityDTO_CommodityType = 73
	CommodityDTO_VMPM_ACCESS                CommodityDTO_CommodityType = 74
	CommodityDTO_HA_COMMODITY               CommodityDTO_CommodityType = 75
	CommodityDTO_NETWORK_POLICY             CommodityDTO_CommodityType = 76
	CommodityDTO_HEAP                       CommodityDTO_CommodityType = 77
	CommodityDTO_DISK_ARRAY_ACCESS          CommodityDTO_CommodityType = 78
	CommodityDTO_SERVICE_LEVEL_CLUSTER      CommodityDTO_CommodityType = 79
	CommodityDTO_PROCESSING_UNITS           CommodityDTO_CommodityType = 80
	CommodityDTO_HOST_LUN_ACCESS            CommodityDTO_CommodityType = 81
	CommodityDTO_COUPON                     CommodityDTO_CommodityType = 82
	CommodityDTO_TENANCY_ACCESS             CommodityDTO_CommodityType = 83
	CommodityDTO_LICENSE_ACCESS             CommodityDTO_CommodityType = 84
	CommodityDTO_TEMPLATE_ACCESS            CommodityDTO_CommodityType = 85
	CommodityDTO_NUM_DISK                   CommodityDTO_CommodityType = 86
	CommodityDTO_ZONE                       CommodityDTO_CommodityType = 87
	CommodityDTO_ACTIVE_SESSIONS            CommodityDTO_CommodityType = 88
	CommodityDTO_POOL_CPU                   CommodityDTO_CommodityType = 89
	CommodityDTO_POOL_MEM                   CommodityDTO_CommodityType = 90
	CommodityDTO_POOL_STORAGE               CommodityDTO_CommodityType = 91
	CommodityDTO_IMAGE_CPU                  CommodityDTO_CommodityType = 92
	CommodityDTO_IMAGE_MEM                  CommodityDTO_CommodityType = 93
	CommodityDTO_IMAGE_STORAGE              CommodityDTO_CommodityType = 94
	CommodityDTO_INSTANCE_DISK_SIZE         CommodityDTO_CommodityType = 95
	CommodityDTO_INSTANCE_DISK_TYPE         CommodityDTO_CommodityType = 96
	CommodityDTO_BURST_BALANCE              CommodityDTO_CommodityType = 97
	CommodityDTO_TEMPLATE_FAMILY            CommodityDTO_CommodityType = 98
	CommodityDTO_DESIRED_COUPON             CommodityDTO_CommodityType = 99
	CommodityDTO_VCPU_REQUEST               CommodityDTO_CommodityType = 100
	CommodityDTO_VMEM_REQUEST               CommodityDTO_CommodityType = 101
	CommodityDTO_CPU_REQUEST_ALLOCATION     CommodityDTO_CommodityType = 102
	CommodityDTO_MEM_REQUEST_ALLOCATION     CommodityDTO_CommodityType = 103
	CommodityDTO_NETWORK_INTERFACE_COUNT    CommodityDTO_CommodityType = 104
	CommodityDTO_BICLIQUE                   CommodityDTO_CommodityType = 105
	// 2047 is the largest tag value encoded in 2 bytes
	CommodityDTO_UNKNOWN CommodityDTO_CommodityType = 2047
)

var CommodityDTO_CommodityType_name = map[int32]string{
	0:    "CLUSTER",
	1:    "THREADS",
	2:    "CPU_ALLOCATION",
	3:    "NUMBER_CONSUMERS",
	4:    "FLOW_ALLOCATION",
	5:    "Q1_VCPU",
	6:    "STORAGE_PROVISIONED",
	7:    "LICENSE_COMMODITY",
	8:    "STORAGE_AMOUNT",
	9:    "Q16_VCPU",
	10:   "Q32_VCPU",
	11:   "SAME_CLUSTER_MOVE_SVC",
	12:   "Q3_VCPU",
	13:   "SLA_COMMODITY",
	14:   "CROSS_CLUSTER_MOVE_SVC",
	15:   "NUMBER_CONSUMERS_PM",
	16:   "STORAGE_ALLOCATION",
	17:   "Q8_VCPU",
	18:   "SPACE",
	19:   "Q6_VCPU",
	20:   "POWER",
	21:   "MEM",
	22:   "STORAGE_LATENCY",
	23:   "Q7_VCPU",
	24:   "COOLING",
	25:   "PORT_CHANEL",
	26:   "VCPU",
	27:   "QN_VCPU",
	28:   "CPU_PROVISIONED",
	29:   "RIGHT_SIZE_SVC",
	30:   "MOVE",
	31:   "Q2_VCPU",
	32:   "Q5_VCPU",
	33:   "SWAPPING",
	34:   "SEGMENTATION",
	35:   "FLOW",
	36:   "DATASTORE",
	37:   "CROSS_CLOUD_MOVE_SVC",
	38:   "RIGHT_SIZE_DOWN",
	39:   "IO_THROUGHPUT",
	40:   "CPU",
	41:   "BALLOONING",
	42:   "VDC",
	43:   "Q64_VCPU",
	44:   "CONNECTION",
	45:   "MEM_PROVISIONED",
	46:   "STORAGE",
	47:   "NET_THROUGHPUT",
	48:   "NUMBER_CONSUMERS_STORAGE",
	49:   "TRANSACTION",
	50:   "MEM_ALLOCATION",
	51:   "DSPM_ACCESS",
	52:   "RESPONSE_TIME",
	53:   "VMEM",
	54:   "ACTION_PERMIT",
	55:   "DATACENTER",
	56:   "APPLICATION",
	57:   "NETWORK",
	58:   "Q4_VCPU",
	59:   "STORAGE_CLUSTER",
	60:   "EXTENT",
	61:   "ACCESS",
	62:   "RIGHT_SIZE_UP",
	63:   "VAPP_ACCESS",
	64:   "STORAGE_ACCESS",
	65:   "VSTORAGE",
	66:   "DRS_SEGMENTATION",
	67:   "DB_MEM",
	68:   "TRANSACTION_LOG",
	69:   "DB_CACHE_HIT_RATE",
	70:   "HOT_STORAGE",
	71:   "COLLECTION_TIME",
	72:   "BUFFER_COMMODITY",
	73:   "SOFTWARE_LICENSE_COMMODITY",
	74:   "VMPM_ACCESS",
	75:   "HA_COMMODITY",
	76:   "NETWORK_POLICY",
	77:   "HEAP",
	78:   "DISK_ARRAY_ACCESS",
	79:   "SERVICE_LEVEL_CLUSTER",
	80:   "PROCESSING_UNITS",
	81:   "HOST_LUN_ACCESS",
	82:   "COUPON",
	83:   "TENANCY_ACCESS",
	84:   "LICENSE_ACCESS",
	85:   "TEMPLATE_ACCESS",
	86:   "NUM_DISK",
	87:   "ZONE",
	88:   "ACTIVE_SESSIONS",
	89:   "POOL_CPU",
	90:   "POOL_MEM",
	91:   "POOL_STORAGE",
	92:   "IMAGE_CPU",
	93:   "IMAGE_MEM",
	94:   "IMAGE_STORAGE",
	95:   "INSTANCE_DISK_SIZE",
	96:   "INSTANCE_DISK_TYPE",
	97:   "BURST_BALANCE",
	98:   "TEMPLATE_FAMILY",
	99:   "DESIRED_COUPON",
	100:  "VCPU_REQUEST",
	101:  "VMEM_REQUEST",
	102:  "CPU_REQUEST_ALLOCATION",
	103:  "MEM_REQUEST_ALLOCATION",
	104:  "NETWORK_INTERFACE_COUNT",
	105:  "BICLIQUE",
	2047: "UNKNOWN",
}
var CommodityDTO_CommodityType_value = map[string]int32{
	"CLUSTER":                    0,
	"THREADS":                    1,
	"CPU_ALLOCATION":             2,
	"NUMBER_CONSUMERS":           3,
	"FLOW_ALLOCATION":            4,
	"Q1_VCPU":                    5,
	"STORAGE_PROVISIONED":        6,
	"LICENSE_COMMODITY":          7,
	"STORAGE_AMOUNT":             8,
	"Q16_VCPU":                   9,
	"Q32_VCPU":                   10,
	"SAME_CLUSTER_MOVE_SVC":      11,
	"Q3_VCPU":                    12,
	"SLA_COMMODITY":              13,
	"CROSS_CLUSTER_MOVE_SVC":     14,
	"NUMBER_CONSUMERS_PM":        15,
	"STORAGE_ALLOCATION":         16,
	"Q8_VCPU":                    17,
	"SPACE":                      18,
	"Q6_VCPU":                    19,
	"POWER":                      20,
	"MEM":                        21,
	"STORAGE_LATENCY":            22,
	"Q7_VCPU":                    23,
	"COOLING":                    24,
	"PORT_CHANEL":                25,
	"VCPU":                       26,
	"QN_VCPU":                    27,
	"CPU_PROVISIONED":            28,
	"RIGHT_SIZE_SVC":             29,
	"MOVE":                       30,
	"Q2_VCPU":                    31,
	"Q5_VCPU":                    32,
	"SWAPPING":                   33,
	"SEGMENTATION":               34,
	"FLOW":                       35,
	"DATASTORE":                  36,
	"CROSS_CLOUD_MOVE_SVC":       37,
	"RIGHT_SIZE_DOWN":            38,
	"IO_THROUGHPUT":              39,
	"CPU":                        40,
	"BALLOONING":                 41,
	"VDC":                        42,
	"Q64_VCPU":                   43,
	"CONNECTION":                 44,
	"MEM_PROVISIONED":            45,
	"STORAGE":                    46,
	"NET_THROUGHPUT":             47,
	"NUMBER_CONSUMERS_STORAGE":   48,
	"TRANSACTION":                49,
	"MEM_ALLOCATION":             50,
	"DSPM_ACCESS":                51,
	"RESPONSE_TIME":              52,
	"VMEM":                       53,
	"ACTION_PERMIT":              54,
	"DATACENTER":                 55,
	"APPLICATION":                56,
	"NETWORK":                    57,
	"Q4_VCPU":                    58,
	"STORAGE_CLUSTER":            59,
	"EXTENT":                     60,
	"ACCESS":                     61,
	"RIGHT_SIZE_UP":              62,
	"VAPP_ACCESS":                63,
	"STORAGE_ACCESS":             64,
	"VSTORAGE":                   65,
	"DRS_SEGMENTATION":           66,
	"DB_MEM":                     67,
	"TRANSACTION_LOG":            68,
	"DB_CACHE_HIT_RATE":          69,
	"HOT_STORAGE":                70,
	"COLLECTION_TIME":            71,
	"BUFFER_COMMODITY":           72,
	"SOFTWARE_LICENSE_COMMODITY": 73,
	"VMPM_ACCESS":                74,
	"HA_COMMODITY":               75,
	"NETWORK_POLICY":             76,
	"HEAP":                       77,
	"DISK_ARRAY_ACCESS":          78,
	"SERVICE_LEVEL_CLUSTER":      79,
	"PROCESSING_UNITS":           80,
	"HOST_LUN_ACCESS":            81,
	"COUPON":                     82,
	"TENANCY_ACCESS":             83,
	"LICENSE_ACCESS":             84,
	"TEMPLATE_ACCESS":            85,
	"NUM_DISK":                   86,
	"ZONE":                       87,
	"ACTIVE_SESSIONS":            88,
	"POOL_CPU":                   89,
	"POOL_MEM":                   90,
	"POOL_STORAGE":               91,
	"IMAGE_CPU":                  92,
	"IMAGE_MEM":                  93,
	"IMAGE_STORAGE":              94,
	"INSTANCE_DISK_SIZE":         95,
	"INSTANCE_DISK_TYPE":         96,
	"BURST_BALANCE":              97,
	"TEMPLATE_FAMILY":            98,
	"DESIRED_COUPON":             99,
	"VCPU_REQUEST":               100,
	"VMEM_REQUEST":               101,
	"CPU_REQUEST_ALLOCATION":     102,
	"MEM_REQUEST_ALLOCATION":     103,
	"NETWORK_INTERFACE_COUNT":    104,
	"BICLIQUE":                   105,
	"UNKNOWN":                    2047,
}

func (x CommodityDTO_CommodityType) Enum() *CommodityDTO_CommodityType {
	p := new(CommodityDTO_CommodityType)
	*p = x
	return p
}
func (x CommodityDTO_CommodityType) String() string {
	return proto.EnumName(CommodityDTO_CommodityType_name, int32(x))
}
func (x *CommodityDTO_CommodityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CommodityDTO_CommodityType_value, data, "CommodityDTO_CommodityType")
	if err != nil {
		return err
	}
	*x = CommodityDTO_CommodityType(value)
	return nil
}
func (CommodityDTO_CommodityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{2, 0}
}

// Enumerates supported Group types
type GroupDTO_GroupType int32

const (
	GroupDTO_REGULAR  GroupDTO_GroupType = 0
	GroupDTO_RESOURCE GroupDTO_GroupType = 2
	// A host compute cluster is comprised of physical machines.
	GroupDTO_COMPUTE_HOST_CLUSTER GroupDTO_GroupType = 3
	// A virtual machine compute cluster is comprised of virtual machines.
	GroupDTO_COMPUTE_VIRTUAL_MACHINE_CLUSTER GroupDTO_GroupType = 4
	// A storage cluster is comprised of storages.
	GroupDTO_STORAGE_CLUSTER GroupDTO_GroupType = 5
	// A billing family is comprised of billing accounts.
	GroupDTO_BILLING_FAMILY GroupDTO_GroupType = 6
)

var GroupDTO_GroupType_name = map[int32]string{
	0: "REGULAR",
	2: "RESOURCE",
	3: "COMPUTE_HOST_CLUSTER",
	4: "COMPUTE_VIRTUAL_MACHINE_CLUSTER",
	5: "STORAGE_CLUSTER",
	6: "BILLING_FAMILY",
}
var GroupDTO_GroupType_value = map[string]int32{
	"REGULAR":                         0,
	"RESOURCE":                        2,
	"COMPUTE_HOST_CLUSTER":            3,
	"COMPUTE_VIRTUAL_MACHINE_CLUSTER": 4,
	"STORAGE_CLUSTER":                 5,
	"BILLING_FAMILY":                  6,
}

func (x GroupDTO_GroupType) Enum() *GroupDTO_GroupType {
	p := new(GroupDTO_GroupType)
	*p = x
	return p
}
func (x GroupDTO_GroupType) String() string {
	return proto.EnumName(GroupDTO_GroupType_name, int32(x))
}
func (x *GroupDTO_GroupType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GroupDTO_GroupType_value, data, "GroupDTO_GroupType")
	if err != nil {
		return err
	}
	*x = GroupDTO_GroupType(value)
	return nil
}
func (GroupDTO_GroupType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{4, 0} }

// Enum type notifying constraint's type
type GroupDTO_ConstraintType int32

const (
	GroupDTO_BUYER_SELLER_AFFINITY      GroupDTO_ConstraintType = 0
	GroupDTO_BUYER_SELLER_ANTI_AFFINITY GroupDTO_ConstraintType = 1
	GroupDTO_BUYER_BUYER_AFFINITY       GroupDTO_ConstraintType = 2
	GroupDTO_BUYER_BUYER_ANTI_AFFINITY  GroupDTO_ConstraintType = 3
	GroupDTO_CLUSTER                    GroupDTO_ConstraintType = 4
	GroupDTO_MERGE                      GroupDTO_ConstraintType = 5
	GroupDTO_SERVICE_LEVEL_CLUSTER      GroupDTO_ConstraintType = 6
	GroupDTO_TEMPLATE_EXCLUSION         GroupDTO_ConstraintType = 7
)

var GroupDTO_ConstraintType_name = map[int32]string{
	0: "BUYER_SELLER_AFFINITY",
	1: "BUYER_SELLER_ANTI_AFFINITY",
	2: "BUYER_BUYER_AFFINITY",
	3: "BUYER_BUYER_ANTI_AFFINITY",
	4: "CLUSTER",
	5: "MERGE",
	6: "SERVICE_LEVEL_CLUSTER",
	7: "TEMPLATE_EXCLUSION",
}
var GroupDTO_ConstraintType_value = map[string]int32{
	"BUYER_SELLER_AFFINITY":      0,
	"BUYER_SELLER_ANTI_AFFINITY": 1,
	"BUYER_BUYER_AFFINITY":       2,
	"BUYER_BUYER_ANTI_AFFINITY":  3,
	"CLUSTER":                    4,
	"MERGE":                      5,
	"SERVICE_LEVEL_CLUSTER":      6,
	"TEMPLATE_EXCLUSION":         7,
}

func (x GroupDTO_ConstraintType) Enum() *GroupDTO_ConstraintType {
	p := new(GroupDTO_ConstraintType)
	*p = x
	return p
}
func (x GroupDTO_ConstraintType) String() string {
	return proto.EnumName(GroupDTO_ConstraintType_name, int32(x))
}
func (x *GroupDTO_ConstraintType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GroupDTO_ConstraintType_value, data, "GroupDTO_ConstraintType")
	if err != nil {
		return err
	}
	*x = GroupDTO_ConstraintType(value)
	return nil
}
func (GroupDTO_ConstraintType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{4, 1} }

// Enum notifying expression type used to match entities' property value
// with target value in SelectionSpec
type GroupDTO_SelectionSpec_ExpressionType int32

const (
	GroupDTO_SelectionSpec_EQUAL_TO                 GroupDTO_SelectionSpec_ExpressionType = 0
	GroupDTO_SelectionSpec_NOT_EQUAL_TO             GroupDTO_SelectionSpec_ExpressionType = 1
	GroupDTO_SelectionSpec_LARGER_THAN              GroupDTO_SelectionSpec_ExpressionType = 2
	GroupDTO_SelectionSpec_LARGER_THAN_OR_EQUAL_TO  GroupDTO_SelectionSpec_ExpressionType = 3
	GroupDTO_SelectionSpec_SMALLER_THAN             GroupDTO_SelectionSpec_ExpressionType = 4
	GroupDTO_SelectionSpec_SMALLER_THAN_OR_EQUAL_TO GroupDTO_SelectionSpec_ExpressionType = 5
	GroupDTO_SelectionSpec_CONTAINS                 GroupDTO_SelectionSpec_ExpressionType = 6
	GroupDTO_SelectionSpec_NOT_CONTAINS             GroupDTO_SelectionSpec_ExpressionType = 7
	GroupDTO_SelectionSpec_CONTAINED_BY             GroupDTO_SelectionSpec_ExpressionType = 8
	GroupDTO_SelectionSpec_NOT_CONTAINED_BY         GroupDTO_SelectionSpec_ExpressionType = 9
	GroupDTO_SelectionSpec_REGEX                    GroupDTO_SelectionSpec_ExpressionType = 10
	GroupDTO_SelectionSpec_LIST_OVERLAP             GroupDTO_SelectionSpec_ExpressionType = 11
	GroupDTO_SelectionSpec_LIST_NOT_OVERLAP         GroupDTO_SelectionSpec_ExpressionType = 12
	GroupDTO_SelectionSpec_LIST_FULL_CONTAINS       GroupDTO_SelectionSpec_ExpressionType = 13
	GroupDTO_SelectionSpec_LIST_FULL_CONTAINED_BY   GroupDTO_SelectionSpec_ExpressionType = 14
)

var GroupDTO_SelectionSpec_ExpressionType_name = map[int32]string{
	0:  "EQUAL_TO",
	1:  "NOT_EQUAL_TO",
	2:  "LARGER_THAN",
	3:  "LARGER_THAN_OR_EQUAL_TO",
	4:  "SMALLER_THAN",
	5:  "SMALLER_THAN_OR_EQUAL_TO",
	6:  "CONTAINS",
	7:  "NOT_CONTAINS",
	8:  "CONTAINED_BY",
	9:  "NOT_CONTAINED_BY",
	10: "REGEX",
	11: "LIST_OVERLAP",
	12: "LIST_NOT_OVERLAP",
	13: "LIST_FULL_CONTAINS",
	14: "LIST_FULL_CONTAINED_BY",
}
var GroupDTO_SelectionSpec_ExpressionType_value = map[string]int32{
	"EQUAL_TO":                 0,
	"NOT_EQUAL_TO":             1,
	"LARGER_THAN":              2,
	"LARGER_THAN_OR_EQUAL_TO":  3,
	"SMALLER_THAN":             4,
	"SMALLER_THAN_OR_EQUAL_TO": 5,
	"CONTAINS":                 6,
	"NOT_CONTAINS":             7,
	"CONTAINED_BY":             8,
	"NOT_CONTAINED_BY":         9,
	"REGEX":                    10,
	"LIST_OVERLAP":             11,
	"LIST_NOT_OVERLAP":         12,
	"LIST_FULL_CONTAINS":       13,
	"LIST_FULL_CONTAINED_BY":   14,
}

func (x GroupDTO_SelectionSpec_ExpressionType) Enum() *GroupDTO_SelectionSpec_ExpressionType {
	p := new(GroupDTO_SelectionSpec_ExpressionType)
	*p = x
	return p
}
func (x GroupDTO_SelectionSpec_ExpressionType) String() string {
	return proto.EnumName(GroupDTO_SelectionSpec_ExpressionType_name, int32(x))
}
func (x *GroupDTO_SelectionSpec_ExpressionType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GroupDTO_SelectionSpec_ExpressionType_value, data, "GroupDTO_SelectionSpec_ExpressionType")
	if err != nil {
		return err
	}
	*x = GroupDTO_SelectionSpec_ExpressionType(value)
	return nil
}
func (GroupDTO_SelectionSpec_ExpressionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{4, 7, 0}
}

type NotificationDTO_Severity int32

const (
	NotificationDTO_UNKNOWN  NotificationDTO_Severity = 0
	NotificationDTO_NORMAL   NotificationDTO_Severity = 1
	NotificationDTO_MINOR    NotificationDTO_Severity = 2
	NotificationDTO_MAJOR    NotificationDTO_Severity = 3
	NotificationDTO_CRITICAL NotificationDTO_Severity = 4
)

var NotificationDTO_Severity_name = map[int32]string{
	0: "UNKNOWN",
	1: "NORMAL",
	2: "MINOR",
	3: "MAJOR",
	4: "CRITICAL",
}
var NotificationDTO_Severity_value = map[string]int32{
	"UNKNOWN":  0,
	"NORMAL":   1,
	"MINOR":    2,
	"MAJOR":    3,
	"CRITICAL": 4,
}

func (x NotificationDTO_Severity) Enum() *NotificationDTO_Severity {
	p := new(NotificationDTO_Severity)
	*p = x
	return p
}
func (x NotificationDTO_Severity) String() string {
	return proto.EnumName(NotificationDTO_Severity_name, int32(x))
}
func (x *NotificationDTO_Severity) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NotificationDTO_Severity_value, data, "NotificationDTO_Severity")
	if err != nil {
		return err
	}
	*x = NotificationDTO_Severity(value)
	return nil
}
func (NotificationDTO_Severity) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{6, 0} }

type CustomTypeDef_MetadataNamespace int32

const (
	CustomTypeDef_UNKNOWN            CustomTypeDef_MetadataNamespace = 0
	CustomTypeDef_NETWORK_POLICY_EPG CustomTypeDef_MetadataNamespace = 1
)

var CustomTypeDef_MetadataNamespace_name = map[int32]string{
	0: "UNKNOWN",
	1: "NETWORK_POLICY_EPG",
}
var CustomTypeDef_MetadataNamespace_value = map[string]int32{
	"UNKNOWN":            0,
	"NETWORK_POLICY_EPG": 1,
}

func (x CustomTypeDef_MetadataNamespace) Enum() *CustomTypeDef_MetadataNamespace {
	p := new(CustomTypeDef_MetadataNamespace)
	*p = x
	return p
}
func (x CustomTypeDef_MetadataNamespace) String() string {
	return proto.EnumName(CustomTypeDef_MetadataNamespace_name, int32(x))
}
func (x *CustomTypeDef_MetadataNamespace) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CustomTypeDef_MetadataNamespace_value, data, "CustomTypeDef_MetadataNamespace")
	if err != nil {
		return err
	}
	*x = CustomTypeDef_MetadataNamespace(value)
	return nil
}
func (CustomTypeDef_MetadataNamespace) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{7, 0}
}

// Only TCP and UDP are supported.
type FlowDTO_Protocol int32

const (
	FlowDTO_TCP           FlowDTO_Protocol = 1
	FlowDTO_UDP           FlowDTO_Protocol = 2
	FlowDTO_UNKNOWN_PROTO FlowDTO_Protocol = 1000
)

var FlowDTO_Protocol_name = map[int32]string{
	1:    "TCP",
	2:    "UDP",
	1000: "UNKNOWN_PROTO",
}
var FlowDTO_Protocol_value = map[string]int32{
	"TCP":           1,
	"UDP":           2,
	"UNKNOWN_PROTO": 1000,
}

func (x FlowDTO_Protocol) Enum() *FlowDTO_Protocol {
	p := new(FlowDTO_Protocol)
	*p = x
	return p
}
func (x FlowDTO_Protocol) String() string {
	return proto.EnumName(FlowDTO_Protocol_name, int32(x))
}
func (x *FlowDTO_Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FlowDTO_Protocol_value, data, "FlowDTO_Protocol")
	if err != nil {
		return err
	}
	*x = FlowDTO_Protocol(value)
	return nil
}
func (FlowDTO_Protocol) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{11, 0} }

//
// The EntityDTO message represents an Entity discovered in the target that your probe is
// monitoring
//
// Each entity must have a unique ID to identify it in the Operations Manager market.
// Many targets provide unique IDs for their entities, or you can generate your own.
// To guarantee that it's unique, you can give the ID a prefix that identifies your
// probe and the given target.
//
// Specify entity type by setting an 'EntityType' value to the 'entity' field.
//
// The 'displayName' value appears in the product GUI and in reports to identify the entity.
//
// An entity can maintain a list of commodities that it sells (see 'CommodityDTO').
//
// An entity can maintain a map of commodities bought (see {@code CommodityDTO}). Each map key is the unique ID of the
// provider entity. For each provider, the map entry is a list of the commodities bought from that provider.
//
// The entity's list of properties stores metadata about the entity - for example, you would store
// the entity's IP address as a property. To stitch this entity into the Operations Manager topology,
// you will create an ExternalEntityLink. That link includes the properties
// that Operations Manager can use to match the discovered entity and stitch it in.
//
type EntityDTO struct {
	EntityType  *EntityDTO_EntityType `protobuf:"varint,1,req,name=entityType,enum=common_dto.EntityDTO_EntityType" json:"entityType,omitempty"`
	Id          *string               `protobuf:"bytes,2,req,name=id" json:"id,omitempty"`
	DisplayName *string               `protobuf:"bytes,3,opt,name=displayName" json:"displayName,omitempty"`
	// The {@link CommodityDTO} items this entity sells to its consumers.
	// This is a map of sold commodities where
	CommoditiesSold []*CommodityDTO `protobuf:"bytes,4,rep,name=commoditiesSold" json:"commoditiesSold,omitempty"`
	// The {@link CommodityDTO} items this entity buys from the different providers.
	// This is a map of bought commodities where:<ul>
	CommoditiesBought []*EntityDTO_CommodityBought `protobuf:"bytes,5,rep,name=commoditiesBought" json:"commoditiesBought,omitempty"`
	// List of the IDs of the entities that this entity is underlying. For example, an IO Module can underly
	// physical machines, or a physical machine can underly datastores.
	Underlying []string `protobuf:"bytes,6,rep,name=underlying" json:"underlying,omitempty"`
	// list of <string, string, string> namespace, key, value triplets
	EntityProperties []*EntityDTO_EntityProperty `protobuf:"bytes,7,rep,name=entityProperties" json:"entityProperties,omitempty"`
	// Specifies the source of the entity (ie DISCOVERED or PROXY).
	// For further details see the comments for EntityOrigin.
	Origin *EntityDTO_EntityOrigin `protobuf:"varint,8,opt,name=origin,enum=common_dto.EntityDTO_EntityOrigin,def=1" json:"origin,omitempty"`
	// Proxy entities may be replaced by entities discovered by another probe.
	// Some proxy entities are aware of the entity replacing them based on a set of property values.
	// Before replacing they may also transfer the commodity data to the server entity
	ReplacementEntityData *EntityDTO_ReplacementEntityMetaData `protobuf:"bytes,9,opt,name=replacementEntityData" json:"replacementEntityData,omitempty"`
	// Specifies if the entity is monitored or not.
	// If this field is false, state of the entity will be set to NOT_MONITORED in server.
	// NOT_MONITORED state will imply that the entity is not participating in the Market Analysis.
	Monitored *bool `protobuf:"varint,10,opt,name=monitored,def=1" json:"monitored,omitempty"`
	// Specifies the power state of the entity.
	PowerState *EntityDTO_PowerState `protobuf:"varint,11,opt,name=powerState,enum=common_dto.EntityDTO_PowerState,def=1" json:"powerState,omitempty"`
	// Specified properties required for the behavior of the entity as a consumer.
	ConsumerPolicy *EntityDTO_ConsumerPolicy `protobuf:"bytes,12,opt,name=consumerPolicy" json:"consumerPolicy,omitempty"`
	// Specified properties required for the behavior of the entity as a provider.
	ProviderPolicy *EntityDTO_ProviderPolicy `protobuf:"bytes,13,opt,name=providerPolicy" json:"providerPolicy,omitempty"`
	// Specifies ID of the entity that this entity is owned by. For example, an Chassis is
	// owned by Network.
	OwnedBy *string `protobuf:"bytes,14,opt,name=ownedBy" json:"ownedBy,omitempty"`
	// Notifications associated with the entity
	Notification []*NotificationDTO `protobuf:"bytes,15,rep,name=notification" json:"notification,omitempty"`
	// This flag indicates if proxy entity should be kept in repository if it cannot be merged
	// with any real entity. The flag has effect on proxy entities only.
	KeepStandalone *bool `protobuf:"varint,16,opt,name=keepStandalone,def=1" json:"keepStandalone,omitempty"`
	// If there is a related profile, the id can be specified here
	ProfileId *string `protobuf:"bytes,17,opt,name=profileId" json:"profileId,omitempty"`
	// Specifies entity DTO type (can be a new/existing entity or deleted entity).
	UpdateType *UpdateType `protobuf:"varint,18,opt,name=updateType,enum=common_dto.UpdateType,def=0" json:"updateType,omitempty"`
	// List of the IDs of the entities that this entity is layeredOver. For example, a datastore
	// can be layeredOver physical machines; a physical machine can be layeredOver IO Module.
	LayeredOver []string `protobuf:"bytes,19,rep,name=layeredOver" json:"layeredOver,omitempty"`
	// An entity may replace one or more other entities in the topology
	// This attribute allows specification of specific entity or entities to replace based on
	// their id. For example - a VDC may replace a set of resource pools
	ReplacesEntityId []string `protobuf:"bytes,20,rep,name=replacesEntityId" json:"replacesEntityId,omitempty"`
	// Notifies if the entity is in maintenance.
	Maintenance *bool `protobuf:"varint,21,opt,name=maintenance,def=0" json:"maintenance,omitempty"`
	// List of the IDs of the entities that this entity consists of. For example, a
	// master account consists of sub accounts.
	ConsistsOf []string `protobuf:"bytes,22,rep,name=consistsOf" json:"consistsOf,omitempty"`
	// Contains all settings regarding the eligibility of the entity for different actions.
	ActionEligibility *EntityDTO_ActionEligibility `protobuf:"bytes,23,opt,name=actionEligibility" json:"actionEligibility,omitempty"`
	// Collection of entity type's specific data
	//
	// Types that are valid to be assigned to EntityData:
	//	*EntityDTO_StorageData_
	//	*EntityDTO_DiskArrayData_
	//	*EntityDTO_ApplicationData_
	//	*EntityDTO_VirtualMachineData_
	//	*EntityDTO_PhysicalMachineData_
	//	*EntityDTO_VirtualDatacenterData_
	//	*EntityDTO_StorageControllerData_
	//	*EntityDTO_LogicalPoolData_
	//	*EntityDTO_VirtualApplicationData_
	//	*EntityDTO_ProcessorPoolData_
	//	*EntityDTO_ReservedInstanceData_
	//	*EntityDTO_ContainerPodData_
	//	*EntityDTO_ContainerData_
	//	*EntityDTO_BusinessAccountData_
	//	*EntityDTO_ComputeTierData_
	//	*EntityDTO_VirtualVolumeData_
	//	*EntityDTO_BusinessUserData_
	//	*EntityDTO_RegionData_
	EntityData isEntityDTO_EntityData `protobuf_oneof:"entity_data"`
	// Data for entities related to the given entity but not specifically part of the
	// the market. For example, PhysicalMachines are related to
	// Memory, Processor, and IO entities through a composedOf relationship.
	//
	// Types that are valid to be assigned to RelatedEntityData:
	//	*EntityDTO_VirtualMachineRelatedData_
	//	*EntityDTO_PhysicalMachineRelatedData_
	//	*EntityDTO_StorageControllerRelatedData_
	RelatedEntityData isEntityDTO_RelatedEntityData `protobuf_oneof:"related_entity_data"`
	XXX_unrecognized  []byte                        `json:"-"`
}

func (m *EntityDTO) Reset()                    { *m = EntityDTO{} }
func (m *EntityDTO) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO) ProtoMessage()               {}
func (*EntityDTO) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

const Default_EntityDTO_Origin EntityDTO_EntityOrigin = EntityDTO_DISCOVERED
const Default_EntityDTO_Monitored bool = true
const Default_EntityDTO_PowerState EntityDTO_PowerState = EntityDTO_POWERED_ON
const Default_EntityDTO_KeepStandalone bool = true
const Default_EntityDTO_UpdateType UpdateType = UpdateType_UPDATED
const Default_EntityDTO_Maintenance bool = false

type isEntityDTO_EntityData interface {
	isEntityDTO_EntityData()
}
type isEntityDTO_RelatedEntityData interface {
	isEntityDTO_RelatedEntityData()
}

type EntityDTO_StorageData_ struct {
	StorageData *EntityDTO_StorageData `protobuf:"bytes,500,opt,name=storage_data,json=storageData,oneof"`
}
type EntityDTO_DiskArrayData_ struct {
	DiskArrayData *EntityDTO_DiskArrayData `protobuf:"bytes,501,opt,name=disk_array_data,json=diskArrayData,oneof"`
}
type EntityDTO_ApplicationData_ struct {
	ApplicationData *EntityDTO_ApplicationData `protobuf:"bytes,502,opt,name=application_data,json=applicationData,oneof"`
}
type EntityDTO_VirtualMachineData_ struct {
	VirtualMachineData *EntityDTO_VirtualMachineData `protobuf:"bytes,503,opt,name=virtual_machine_data,json=virtualMachineData,oneof"`
}
type EntityDTO_PhysicalMachineData_ struct {
	PhysicalMachineData *EntityDTO_PhysicalMachineData `protobuf:"bytes,504,opt,name=physical_machine_data,json=physicalMachineData,oneof"`
}
type EntityDTO_VirtualDatacenterData_ struct {
	VirtualDatacenterData *EntityDTO_VirtualDatacenterData `protobuf:"bytes,505,opt,name=virtual_datacenter_data,json=virtualDatacenterData,oneof"`
}
type EntityDTO_StorageControllerData_ struct {
	StorageControllerData *EntityDTO_StorageControllerData `protobuf:"bytes,506,opt,name=storage_controller_data,json=storageControllerData,oneof"`
}
type EntityDTO_LogicalPoolData_ struct {
	LogicalPoolData *EntityDTO_LogicalPoolData `protobuf:"bytes,507,opt,name=logical_pool_data,json=logicalPoolData,oneof"`
}
type EntityDTO_VirtualApplicationData_ struct {
	VirtualApplicationData *EntityDTO_VirtualApplicationData `protobuf:"bytes,508,opt,name=virtual_application_data,json=virtualApplicationData,oneof"`
}
type EntityDTO_ProcessorPoolData_ struct {
	ProcessorPoolData *EntityDTO_ProcessorPoolData `protobuf:"bytes,509,opt,name=processor_pool_data,json=processorPoolData,oneof"`
}
type EntityDTO_ReservedInstanceData_ struct {
	ReservedInstanceData *EntityDTO_ReservedInstanceData `protobuf:"bytes,510,opt,name=reserved_instance_data,json=reservedInstanceData,oneof"`
}
type EntityDTO_ContainerPodData_ struct {
	ContainerPodData *EntityDTO_ContainerPodData `protobuf:"bytes,511,opt,name=container_pod_data,json=containerPodData,oneof"`
}
type EntityDTO_ContainerData_ struct {
	ContainerData *EntityDTO_ContainerData `protobuf:"bytes,512,opt,name=container_data,json=containerData,oneof"`
}
type EntityDTO_BusinessAccountData_ struct {
	BusinessAccountData *EntityDTO_BusinessAccountData `protobuf:"bytes,513,opt,name=business_account_data,json=businessAccountData,oneof"`
}
type EntityDTO_ComputeTierData_ struct {
	ComputeTierData *EntityDTO_ComputeTierData `protobuf:"bytes,514,opt,name=compute_tier_data,json=computeTierData,oneof"`
}
type EntityDTO_VirtualVolumeData_ struct {
	VirtualVolumeData *EntityDTO_VirtualVolumeData `protobuf:"bytes,515,opt,name=virtual_volume_data,json=virtualVolumeData,oneof"`
}
type EntityDTO_BusinessUserData_ struct {
	BusinessUserData *EntityDTO_BusinessUserData `protobuf:"bytes,516,opt,name=business_user_data,json=businessUserData,oneof"`
}
type EntityDTO_RegionData_ struct {
	RegionData *EntityDTO_RegionData `protobuf:"bytes,517,opt,name=region_data,json=regionData,oneof"`
}
type EntityDTO_VirtualMachineRelatedData_ struct {
	VirtualMachineRelatedData *EntityDTO_VirtualMachineRelatedData `protobuf:"bytes,1000,opt,name=virtual_machine_related_data,json=virtualMachineRelatedData,oneof"`
}
type EntityDTO_PhysicalMachineRelatedData_ struct {
	PhysicalMachineRelatedData *EntityDTO_PhysicalMachineRelatedData `protobuf:"bytes,1001,opt,name=physical_machine_related_data,json=physicalMachineRelatedData,oneof"`
}
type EntityDTO_StorageControllerRelatedData_ struct {
	StorageControllerRelatedData *EntityDTO_StorageControllerRelatedData `protobuf:"bytes,1002,opt,name=storage_controller_related_data,json=storageControllerRelatedData,oneof"`
}

func (*EntityDTO_StorageData_) isEntityDTO_EntityData()                         {}
func (*EntityDTO_DiskArrayData_) isEntityDTO_EntityData()                       {}
func (*EntityDTO_ApplicationData_) isEntityDTO_EntityData()                     {}
func (*EntityDTO_VirtualMachineData_) isEntityDTO_EntityData()                  {}
func (*EntityDTO_PhysicalMachineData_) isEntityDTO_EntityData()                 {}
func (*EntityDTO_VirtualDatacenterData_) isEntityDTO_EntityData()               {}
func (*EntityDTO_StorageControllerData_) isEntityDTO_EntityData()               {}
func (*EntityDTO_LogicalPoolData_) isEntityDTO_EntityData()                     {}
func (*EntityDTO_VirtualApplicationData_) isEntityDTO_EntityData()              {}
func (*EntityDTO_ProcessorPoolData_) isEntityDTO_EntityData()                   {}
func (*EntityDTO_ReservedInstanceData_) isEntityDTO_EntityData()                {}
func (*EntityDTO_ContainerPodData_) isEntityDTO_EntityData()                    {}
func (*EntityDTO_ContainerData_) isEntityDTO_EntityData()                       {}
func (*EntityDTO_BusinessAccountData_) isEntityDTO_EntityData()                 {}
func (*EntityDTO_ComputeTierData_) isEntityDTO_EntityData()                     {}
func (*EntityDTO_VirtualVolumeData_) isEntityDTO_EntityData()                   {}
func (*EntityDTO_BusinessUserData_) isEntityDTO_EntityData()                    {}
func (*EntityDTO_RegionData_) isEntityDTO_EntityData()                          {}
func (*EntityDTO_VirtualMachineRelatedData_) isEntityDTO_RelatedEntityData()    {}
func (*EntityDTO_PhysicalMachineRelatedData_) isEntityDTO_RelatedEntityData()   {}
func (*EntityDTO_StorageControllerRelatedData_) isEntityDTO_RelatedEntityData() {}

func (m *EntityDTO) GetEntityData() isEntityDTO_EntityData {
	if m != nil {
		return m.EntityData
	}
	return nil
}
func (m *EntityDTO) GetRelatedEntityData() isEntityDTO_RelatedEntityData {
	if m != nil {
		return m.RelatedEntityData
	}
	return nil
}

func (m *EntityDTO) GetEntityType() EntityDTO_EntityType {
	if m != nil && m.EntityType != nil {
		return *m.EntityType
	}
	return EntityDTO_SWITCH
}

func (m *EntityDTO) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *EntityDTO) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityDTO) GetCommoditiesSold() []*CommodityDTO {
	if m != nil {
		return m.CommoditiesSold
	}
	return nil
}

func (m *EntityDTO) GetCommoditiesBought() []*EntityDTO_CommodityBought {
	if m != nil {
		return m.CommoditiesBought
	}
	return nil
}

func (m *EntityDTO) GetUnderlying() []string {
	if m != nil {
		return m.Underlying
	}
	return nil
}

func (m *EntityDTO) GetEntityProperties() []*EntityDTO_EntityProperty {
	if m != nil {
		return m.EntityProperties
	}
	return nil
}

func (m *EntityDTO) GetOrigin() EntityDTO_EntityOrigin {
	if m != nil && m.Origin != nil {
		return *m.Origin
	}
	return Default_EntityDTO_Origin
}

func (m *EntityDTO) GetReplacementEntityData() *EntityDTO_ReplacementEntityMetaData {
	if m != nil {
		return m.ReplacementEntityData
	}
	return nil
}

func (m *EntityDTO) GetMonitored() bool {
	if m != nil && m.Monitored != nil {
		return *m.Monitored
	}
	return Default_EntityDTO_Monitored
}

func (m *EntityDTO) GetPowerState() EntityDTO_PowerState {
	if m != nil && m.PowerState != nil {
		return *m.PowerState
	}
	return Default_EntityDTO_PowerState
}

func (m *EntityDTO) GetConsumerPolicy() *EntityDTO_ConsumerPolicy {
	if m != nil {
		return m.ConsumerPolicy
	}
	return nil
}

func (m *EntityDTO) GetProviderPolicy() *EntityDTO_ProviderPolicy {
	if m != nil {
		return m.ProviderPolicy
	}
	return nil
}

func (m *EntityDTO) GetOwnedBy() string {
	if m != nil && m.OwnedBy != nil {
		return *m.OwnedBy
	}
	return ""
}

func (m *EntityDTO) GetNotification() []*NotificationDTO {
	if m != nil {
		return m.Notification
	}
	return nil
}

func (m *EntityDTO) GetKeepStandalone() bool {
	if m != nil && m.KeepStandalone != nil {
		return *m.KeepStandalone
	}
	return Default_EntityDTO_KeepStandalone
}

func (m *EntityDTO) GetProfileId() string {
	if m != nil && m.ProfileId != nil {
		return *m.ProfileId
	}
	return ""
}

func (m *EntityDTO) GetUpdateType() UpdateType {
	if m != nil && m.UpdateType != nil {
		return *m.UpdateType
	}
	return Default_EntityDTO_UpdateType
}

func (m *EntityDTO) GetLayeredOver() []string {
	if m != nil {
		return m.LayeredOver
	}
	return nil
}

func (m *EntityDTO) GetReplacesEntityId() []string {
	if m != nil {
		return m.ReplacesEntityId
	}
	return nil
}

func (m *EntityDTO) GetMaintenance() bool {
	if m != nil && m.Maintenance != nil {
		return *m.Maintenance
	}
	return Default_EntityDTO_Maintenance
}

func (m *EntityDTO) GetConsistsOf() []string {
	if m != nil {
		return m.ConsistsOf
	}
	return nil
}

func (m *EntityDTO) GetActionEligibility() *EntityDTO_ActionEligibility {
	if m != nil {
		return m.ActionEligibility
	}
	return nil
}

func (m *EntityDTO) GetStorageData() *EntityDTO_StorageData {
	if x, ok := m.GetEntityData().(*EntityDTO_StorageData_); ok {
		return x.StorageData
	}
	return nil
}

func (m *EntityDTO) GetDiskArrayData() *EntityDTO_DiskArrayData {
	if x, ok := m.GetEntityData().(*EntityDTO_DiskArrayData_); ok {
		return x.DiskArrayData
	}
	return nil
}

func (m *EntityDTO) GetApplicationData() *EntityDTO_ApplicationData {
	if x, ok := m.GetEntityData().(*EntityDTO_ApplicationData_); ok {
		return x.ApplicationData
	}
	return nil
}

func (m *EntityDTO) GetVirtualMachineData() *EntityDTO_VirtualMachineData {
	if x, ok := m.GetEntityData().(*EntityDTO_VirtualMachineData_); ok {
		return x.VirtualMachineData
	}
	return nil
}

func (m *EntityDTO) GetPhysicalMachineData() *EntityDTO_PhysicalMachineData {
	if x, ok := m.GetEntityData().(*EntityDTO_PhysicalMachineData_); ok {
		return x.PhysicalMachineData
	}
	return nil
}

func (m *EntityDTO) GetVirtualDatacenterData() *EntityDTO_VirtualDatacenterData {
	if x, ok := m.GetEntityData().(*EntityDTO_VirtualDatacenterData_); ok {
		return x.VirtualDatacenterData
	}
	return nil
}

func (m *EntityDTO) GetStorageControllerData() *EntityDTO_StorageControllerData {
	if x, ok := m.GetEntityData().(*EntityDTO_StorageControllerData_); ok {
		return x.StorageControllerData
	}
	return nil
}

func (m *EntityDTO) GetLogicalPoolData() *EntityDTO_LogicalPoolData {
	if x, ok := m.GetEntityData().(*EntityDTO_LogicalPoolData_); ok {
		return x.LogicalPoolData
	}
	return nil
}

func (m *EntityDTO) GetVirtualApplicationData() *EntityDTO_VirtualApplicationData {
	if x, ok := m.GetEntityData().(*EntityDTO_VirtualApplicationData_); ok {
		return x.VirtualApplicationData
	}
	return nil
}

func (m *EntityDTO) GetProcessorPoolData() *EntityDTO_ProcessorPoolData {
	if x, ok := m.GetEntityData().(*EntityDTO_ProcessorPoolData_); ok {
		return x.ProcessorPoolData
	}
	return nil
}

func (m *EntityDTO) GetReservedInstanceData() *EntityDTO_ReservedInstanceData {
	if x, ok := m.GetEntityData().(*EntityDTO_ReservedInstanceData_); ok {
		return x.ReservedInstanceData
	}
	return nil
}

func (m *EntityDTO) GetContainerPodData() *EntityDTO_ContainerPodData {
	if x, ok := m.GetEntityData().(*EntityDTO_ContainerPodData_); ok {
		return x.ContainerPodData
	}
	return nil
}

func (m *EntityDTO) GetContainerData() *EntityDTO_ContainerData {
	if x, ok := m.GetEntityData().(*EntityDTO_ContainerData_); ok {
		return x.ContainerData
	}
	return nil
}

func (m *EntityDTO) GetBusinessAccountData() *EntityDTO_BusinessAccountData {
	if x, ok := m.GetEntityData().(*EntityDTO_BusinessAccountData_); ok {
		return x.BusinessAccountData
	}
	return nil
}

func (m *EntityDTO) GetComputeTierData() *EntityDTO_ComputeTierData {
	if x, ok := m.GetEntityData().(*EntityDTO_ComputeTierData_); ok {
		return x.ComputeTierData
	}
	return nil
}

func (m *EntityDTO) GetVirtualVolumeData() *EntityDTO_VirtualVolumeData {
	if x, ok := m.GetEntityData().(*EntityDTO_VirtualVolumeData_); ok {
		return x.VirtualVolumeData
	}
	return nil
}

func (m *EntityDTO) GetBusinessUserData() *EntityDTO_BusinessUserData {
	if x, ok := m.GetEntityData().(*EntityDTO_BusinessUserData_); ok {
		return x.BusinessUserData
	}
	return nil
}

func (m *EntityDTO) GetRegionData() *EntityDTO_RegionData {
	if x, ok := m.GetEntityData().(*EntityDTO_RegionData_); ok {
		return x.RegionData
	}
	return nil
}

func (m *EntityDTO) GetVirtualMachineRelatedData() *EntityDTO_VirtualMachineRelatedData {
	if x, ok := m.GetRelatedEntityData().(*EntityDTO_VirtualMachineRelatedData_); ok {
		return x.VirtualMachineRelatedData
	}
	return nil
}

func (m *EntityDTO) GetPhysicalMachineRelatedData() *EntityDTO_PhysicalMachineRelatedData {
	if x, ok := m.GetRelatedEntityData().(*EntityDTO_PhysicalMachineRelatedData_); ok {
		return x.PhysicalMachineRelatedData
	}
	return nil
}

func (m *EntityDTO) GetStorageControllerRelatedData() *EntityDTO_StorageControllerRelatedData {
	if x, ok := m.GetRelatedEntityData().(*EntityDTO_StorageControllerRelatedData_); ok {
		return x.StorageControllerRelatedData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EntityDTO) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EntityDTO_OneofMarshaler, _EntityDTO_OneofUnmarshaler, _EntityDTO_OneofSizer, []interface{}{
		(*EntityDTO_StorageData_)(nil),
		(*EntityDTO_DiskArrayData_)(nil),
		(*EntityDTO_ApplicationData_)(nil),
		(*EntityDTO_VirtualMachineData_)(nil),
		(*EntityDTO_PhysicalMachineData_)(nil),
		(*EntityDTO_VirtualDatacenterData_)(nil),
		(*EntityDTO_StorageControllerData_)(nil),
		(*EntityDTO_LogicalPoolData_)(nil),
		(*EntityDTO_VirtualApplicationData_)(nil),
		(*EntityDTO_ProcessorPoolData_)(nil),
		(*EntityDTO_ReservedInstanceData_)(nil),
		(*EntityDTO_ContainerPodData_)(nil),
		(*EntityDTO_ContainerData_)(nil),
		(*EntityDTO_BusinessAccountData_)(nil),
		(*EntityDTO_ComputeTierData_)(nil),
		(*EntityDTO_VirtualVolumeData_)(nil),
		(*EntityDTO_BusinessUserData_)(nil),
		(*EntityDTO_RegionData_)(nil),
		(*EntityDTO_VirtualMachineRelatedData_)(nil),
		(*EntityDTO_PhysicalMachineRelatedData_)(nil),
		(*EntityDTO_StorageControllerRelatedData_)(nil),
	}
}

func _EntityDTO_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EntityDTO)
	// entity_data
	switch x := m.EntityData.(type) {
	case *EntityDTO_StorageData_:
		b.EncodeVarint(500<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageData); err != nil {
			return err
		}
	case *EntityDTO_DiskArrayData_:
		b.EncodeVarint(501<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiskArrayData); err != nil {
			return err
		}
	case *EntityDTO_ApplicationData_:
		b.EncodeVarint(502<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ApplicationData); err != nil {
			return err
		}
	case *EntityDTO_VirtualMachineData_:
		b.EncodeVarint(503<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualMachineData); err != nil {
			return err
		}
	case *EntityDTO_PhysicalMachineData_:
		b.EncodeVarint(504<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PhysicalMachineData); err != nil {
			return err
		}
	case *EntityDTO_VirtualDatacenterData_:
		b.EncodeVarint(505<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualDatacenterData); err != nil {
			return err
		}
	case *EntityDTO_StorageControllerData_:
		b.EncodeVarint(506<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageControllerData); err != nil {
			return err
		}
	case *EntityDTO_LogicalPoolData_:
		b.EncodeVarint(507<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogicalPoolData); err != nil {
			return err
		}
	case *EntityDTO_VirtualApplicationData_:
		b.EncodeVarint(508<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualApplicationData); err != nil {
			return err
		}
	case *EntityDTO_ProcessorPoolData_:
		b.EncodeVarint(509<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProcessorPoolData); err != nil {
			return err
		}
	case *EntityDTO_ReservedInstanceData_:
		b.EncodeVarint(510<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReservedInstanceData); err != nil {
			return err
		}
	case *EntityDTO_ContainerPodData_:
		b.EncodeVarint(511<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ContainerPodData); err != nil {
			return err
		}
	case *EntityDTO_ContainerData_:
		b.EncodeVarint(512<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ContainerData); err != nil {
			return err
		}
	case *EntityDTO_BusinessAccountData_:
		b.EncodeVarint(513<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BusinessAccountData); err != nil {
			return err
		}
	case *EntityDTO_ComputeTierData_:
		b.EncodeVarint(514<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ComputeTierData); err != nil {
			return err
		}
	case *EntityDTO_VirtualVolumeData_:
		b.EncodeVarint(515<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualVolumeData); err != nil {
			return err
		}
	case *EntityDTO_BusinessUserData_:
		b.EncodeVarint(516<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BusinessUserData); err != nil {
			return err
		}
	case *EntityDTO_RegionData_:
		b.EncodeVarint(517<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RegionData); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EntityDTO.EntityData has unexpected type %T", x)
	}
	// related_entity_data
	switch x := m.RelatedEntityData.(type) {
	case *EntityDTO_VirtualMachineRelatedData_:
		b.EncodeVarint(1000<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualMachineRelatedData); err != nil {
			return err
		}
	case *EntityDTO_PhysicalMachineRelatedData_:
		b.EncodeVarint(1001<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PhysicalMachineRelatedData); err != nil {
			return err
		}
	case *EntityDTO_StorageControllerRelatedData_:
		b.EncodeVarint(1002<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageControllerRelatedData); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EntityDTO.RelatedEntityData has unexpected type %T", x)
	}
	return nil
}

func _EntityDTO_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EntityDTO)
	switch tag {
	case 500: // entity_data.storage_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_StorageData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_StorageData_{msg}
		return true, err
	case 501: // entity_data.disk_array_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_DiskArrayData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_DiskArrayData_{msg}
		return true, err
	case 502: // entity_data.application_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_ApplicationData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_ApplicationData_{msg}
		return true, err
	case 503: // entity_data.virtual_machine_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_VirtualMachineData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_VirtualMachineData_{msg}
		return true, err
	case 504: // entity_data.physical_machine_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_PhysicalMachineData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_PhysicalMachineData_{msg}
		return true, err
	case 505: // entity_data.virtual_datacenter_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_VirtualDatacenterData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_VirtualDatacenterData_{msg}
		return true, err
	case 506: // entity_data.storage_controller_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_StorageControllerData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_StorageControllerData_{msg}
		return true, err
	case 507: // entity_data.logical_pool_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_LogicalPoolData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_LogicalPoolData_{msg}
		return true, err
	case 508: // entity_data.virtual_application_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_VirtualApplicationData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_VirtualApplicationData_{msg}
		return true, err
	case 509: // entity_data.processor_pool_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_ProcessorPoolData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_ProcessorPoolData_{msg}
		return true, err
	case 510: // entity_data.reserved_instance_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_ReservedInstanceData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_ReservedInstanceData_{msg}
		return true, err
	case 511: // entity_data.container_pod_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_ContainerPodData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_ContainerPodData_{msg}
		return true, err
	case 512: // entity_data.container_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_ContainerData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_ContainerData_{msg}
		return true, err
	case 513: // entity_data.business_account_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_BusinessAccountData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_BusinessAccountData_{msg}
		return true, err
	case 514: // entity_data.compute_tier_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_ComputeTierData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_ComputeTierData_{msg}
		return true, err
	case 515: // entity_data.virtual_volume_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_VirtualVolumeData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_VirtualVolumeData_{msg}
		return true, err
	case 516: // entity_data.business_user_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_BusinessUserData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_BusinessUserData_{msg}
		return true, err
	case 517: // entity_data.region_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_RegionData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_RegionData_{msg}
		return true, err
	case 1000: // related_entity_data.virtual_machine_related_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_VirtualMachineRelatedData)
		err := b.DecodeMessage(msg)
		m.RelatedEntityData = &EntityDTO_VirtualMachineRelatedData_{msg}
		return true, err
	case 1001: // related_entity_data.physical_machine_related_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_PhysicalMachineRelatedData)
		err := b.DecodeMessage(msg)
		m.RelatedEntityData = &EntityDTO_PhysicalMachineRelatedData_{msg}
		return true, err
	case 1002: // related_entity_data.storage_controller_related_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_StorageControllerRelatedData)
		err := b.DecodeMessage(msg)
		m.RelatedEntityData = &EntityDTO_StorageControllerRelatedData_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EntityDTO_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EntityDTO)
	// entity_data
	switch x := m.EntityData.(type) {
	case *EntityDTO_StorageData_:
		s := proto.Size(x.StorageData)
		n += proto.SizeVarint(500<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_DiskArrayData_:
		s := proto.Size(x.DiskArrayData)
		n += proto.SizeVarint(501<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_ApplicationData_:
		s := proto.Size(x.ApplicationData)
		n += proto.SizeVarint(502<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_VirtualMachineData_:
		s := proto.Size(x.VirtualMachineData)
		n += proto.SizeVarint(503<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_PhysicalMachineData_:
		s := proto.Size(x.PhysicalMachineData)
		n += proto.SizeVarint(504<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_VirtualDatacenterData_:
		s := proto.Size(x.VirtualDatacenterData)
		n += proto.SizeVarint(505<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_StorageControllerData_:
		s := proto.Size(x.StorageControllerData)
		n += proto.SizeVarint(506<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_LogicalPoolData_:
		s := proto.Size(x.LogicalPoolData)
		n += proto.SizeVarint(507<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_VirtualApplicationData_:
		s := proto.Size(x.VirtualApplicationData)
		n += proto.SizeVarint(508<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_ProcessorPoolData_:
		s := proto.Size(x.ProcessorPoolData)
		n += proto.SizeVarint(509<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_ReservedInstanceData_:
		s := proto.Size(x.ReservedInstanceData)
		n += proto.SizeVarint(510<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_ContainerPodData_:
		s := proto.Size(x.ContainerPodData)
		n += proto.SizeVarint(511<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_ContainerData_:
		s := proto.Size(x.ContainerData)
		n += proto.SizeVarint(512<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_BusinessAccountData_:
		s := proto.Size(x.BusinessAccountData)
		n += proto.SizeVarint(513<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_ComputeTierData_:
		s := proto.Size(x.ComputeTierData)
		n += proto.SizeVarint(514<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_VirtualVolumeData_:
		s := proto.Size(x.VirtualVolumeData)
		n += proto.SizeVarint(515<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_BusinessUserData_:
		s := proto.Size(x.BusinessUserData)
		n += proto.SizeVarint(516<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_RegionData_:
		s := proto.Size(x.RegionData)
		n += proto.SizeVarint(517<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// related_entity_data
	switch x := m.RelatedEntityData.(type) {
	case *EntityDTO_VirtualMachineRelatedData_:
		s := proto.Size(x.VirtualMachineRelatedData)
		n += proto.SizeVarint(1000<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_PhysicalMachineRelatedData_:
		s := proto.Size(x.PhysicalMachineRelatedData)
		n += proto.SizeVarint(1001<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_StorageControllerRelatedData_:
		s := proto.Size(x.StorageControllerRelatedData)
		n += proto.SizeVarint(1002<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EntityDTO_CommodityBought struct {
	// ID of the provider entity
	ProviderId *string `protobuf:"bytes,1,req,name=providerId" json:"providerId,omitempty"`
	// list of CommodityDTO items bought from the provider entity
	Bought []*CommodityDTO `protobuf:"bytes,2,rep,name=bought" json:"bought,omitempty"`
	// The provider type should be specified along with the provider id
	ProviderType *EntityDTO_EntityType `protobuf:"varint,3,opt,name=providerType,enum=common_dto.EntityDTO_EntityType" json:"providerType,omitempty"`
	// Define a related sub division of the commodities bought - for example vDisk
	SubDivision *EntityDTO_SubDivisionData `protobuf:"bytes,4,opt,name=subDivision" json:"subDivision,omitempty"`
	// Eligibility for actions on this provider
	ActionEligibility *EntityDTO_ActionOnProviderEligibility `protobuf:"bytes,6,opt,name=actionEligibility" json:"actionEligibility,omitempty"`
	XXX_unrecognized  []byte                                 `json:"-"`
}

func (m *EntityDTO_CommodityBought) Reset()                    { *m = EntityDTO_CommodityBought{} }
func (m *EntityDTO_CommodityBought) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_CommodityBought) ProtoMessage()               {}
func (*EntityDTO_CommodityBought) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 0} }

func (m *EntityDTO_CommodityBought) GetProviderId() string {
	if m != nil && m.ProviderId != nil {
		return *m.ProviderId
	}
	return ""
}

func (m *EntityDTO_CommodityBought) GetBought() []*CommodityDTO {
	if m != nil {
		return m.Bought
	}
	return nil
}

func (m *EntityDTO_CommodityBought) GetProviderType() EntityDTO_EntityType {
	if m != nil && m.ProviderType != nil {
		return *m.ProviderType
	}
	return EntityDTO_SWITCH
}

func (m *EntityDTO_CommodityBought) GetSubDivision() *EntityDTO_SubDivisionData {
	if m != nil {
		return m.SubDivision
	}
	return nil
}

func (m *EntityDTO_CommodityBought) GetActionEligibility() *EntityDTO_ActionOnProviderEligibility {
	if m != nil {
		return m.ActionEligibility
	}
	return nil
}

// Setting to determine eligibility of the entity for various analysis actions that have an
// effect on the whole entity.
// It is defined as a member of the EntityDTO message.
// See also the ActionOnProviderEligibility setting for actions that have effect on the
// relationship/combination of the entity and a specific provider it is buying from.
// Therefore, there can be multiple ActionOnProviderEligibility on a single entity, possibly
// one per provider. It is defined as the member of the CommodityBought section.
//
// Note: The ProbeActionCapability has effect on all the entities of a specific type.
// Probe writer should use the correct option for action settings. The probe wide entity type
// action setting is usually preferred. However, the entity level action eligibility can be used
// if further granularity is required to control entity actions.
// In conjunction with the ProbeActionCapability, analysis will determine whether to recommend
// a particular action for an entity.
// If the probe has disabled the support for a particular action, then the action eligibility
// setting of the entity is ignored.
// Similarly, if the probe has indicated support for a particular action, but the action
// eligibility of the entity is false, then the action cannot be recommended by analysis.
// In summary, the most restrictive action setting will be applied by analysis.
//
// Note: the action eligibility section strictly pertains to the actions that can be applied on
// the entity by the Analysis engine. These settings in Consumer Policy apply to the state
// of the entity in the market.
type EntityDTO_ActionEligibility struct {
	// Whether the Market should generate suspend action for this entity
	Suspendable *bool `protobuf:"varint,1,opt,name=suspendable,def=1" json:"suspendable,omitempty"`
	// Whether the Market should generate clone or provision action this entity.
	Cloneable        *bool  `protobuf:"varint,2,opt,name=cloneable,def=1" json:"cloneable,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_ActionEligibility) Reset()                    { *m = EntityDTO_ActionEligibility{} }
func (m *EntityDTO_ActionEligibility) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ActionEligibility) ProtoMessage()               {}
func (*EntityDTO_ActionEligibility) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 1} }

const Default_EntityDTO_ActionEligibility_Suspendable bool = true
const Default_EntityDTO_ActionEligibility_Cloneable bool = true

func (m *EntityDTO_ActionEligibility) GetSuspendable() bool {
	if m != nil && m.Suspendable != nil {
		return *m.Suspendable
	}
	return Default_EntityDTO_ActionEligibility_Suspendable
}

func (m *EntityDTO_ActionEligibility) GetCloneable() bool {
	if m != nil && m.Cloneable != nil {
		return *m.Cloneable
	}
	return Default_EntityDTO_ActionEligibility_Cloneable
}

// Eligibility for actions that will have effect on the combination of the entity
// and a specific provider it is buying from.
// It is defined as the member of the CommodityBought section.
type EntityDTO_ActionOnProviderEligibility struct {
	// Whether the Market should generate a move for this entity to another provider of the same type.
	Movable *bool `protobuf:"varint,1,opt,name=movable" json:"movable,omitempty"`
	// Whether the entity should generate a start for this entity on this provider
	Startable *bool `protobuf:"varint,2,opt,name=startable,def=1" json:"startable,omitempty"`
	// Where the Market should generate scale action this entity, relevant for cloud entities
	Scalable         *bool  `protobuf:"varint,3,opt,name=scalable,def=1" json:"scalable,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_ActionOnProviderEligibility) Reset()         { *m = EntityDTO_ActionOnProviderEligibility{} }
func (m *EntityDTO_ActionOnProviderEligibility) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_ActionOnProviderEligibility) ProtoMessage()    {}
func (*EntityDTO_ActionOnProviderEligibility) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 2}
}

const Default_EntityDTO_ActionOnProviderEligibility_Startable bool = true
const Default_EntityDTO_ActionOnProviderEligibility_Scalable bool = true

func (m *EntityDTO_ActionOnProviderEligibility) GetMovable() bool {
	if m != nil && m.Movable != nil {
		return *m.Movable
	}
	return false
}

func (m *EntityDTO_ActionOnProviderEligibility) GetStartable() bool {
	if m != nil && m.Startable != nil {
		return *m.Startable
	}
	return Default_EntityDTO_ActionOnProviderEligibility_Startable
}

func (m *EntityDTO_ActionOnProviderEligibility) GetScalable() bool {
	if m != nil && m.Scalable != nil {
		return *m.Scalable
	}
	return Default_EntityDTO_ActionOnProviderEligibility_Scalable
}

// representation of a virtual disk (AWS EBS volume)
// A VM can have multiple virtual disks from the same storage
type EntityDTO_SubDivisionData struct {
	// id of the SubDivision
	SubDivisionId *string `protobuf:"bytes,1,req,name=subDivisionId" json:"subDivisionId,omitempty"`
	// String identifying the replication type needed for cost calculations
	RedundancyType *string `protobuf:"bytes,2,opt,name=redundancyType" json:"redundancyType,omitempty"`
	// float iops capacity of SubDivision needed for cost calculations
	StorageAccessCapacity *float32 `protobuf:"fixed32,3,opt,name=storageAccessCapacity" json:"storageAccessCapacity,omitempty"`
	// float storage capacity of SubDivision needed for cost calculations
	StorageAmountCapacity *float32 `protobuf:"fixed32,4,opt,name=storageAmountCapacity" json:"storageAmountCapacity,omitempty"`
	// display name for the SubDivision
	DisplayName      *string `protobuf:"bytes,5,opt,name=displayName" json:"displayName,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_SubDivisionData) Reset()                    { *m = EntityDTO_SubDivisionData{} }
func (m *EntityDTO_SubDivisionData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_SubDivisionData) ProtoMessage()               {}
func (*EntityDTO_SubDivisionData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 3} }

func (m *EntityDTO_SubDivisionData) GetSubDivisionId() string {
	if m != nil && m.SubDivisionId != nil {
		return *m.SubDivisionId
	}
	return ""
}

func (m *EntityDTO_SubDivisionData) GetRedundancyType() string {
	if m != nil && m.RedundancyType != nil {
		return *m.RedundancyType
	}
	return ""
}

func (m *EntityDTO_SubDivisionData) GetStorageAccessCapacity() float32 {
	if m != nil && m.StorageAccessCapacity != nil {
		return *m.StorageAccessCapacity
	}
	return 0
}

func (m *EntityDTO_SubDivisionData) GetStorageAmountCapacity() float32 {
	if m != nil && m.StorageAmountCapacity != nil {
		return *m.StorageAmountCapacity
	}
	return 0
}

func (m *EntityDTO_SubDivisionData) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

type EntityDTO_StorageData struct {
	StorageType    *EntityDTO_StorageType `protobuf:"varint,1,opt,name=storageType,enum=common_dto.EntityDTO_StorageType" json:"storageType,omitempty"`
	IpAddress      *string                `protobuf:"bytes,2,opt,name=ipAddress" json:"ipAddress,omitempty"`
	ExportPath     *string                `protobuf:"bytes,3,opt,name=exportPath" json:"exportPath,omitempty"`
	StorageId      *string                `protobuf:"bytes,4,opt,name=storageId" json:"storageId,omitempty"`
	LunUuid        *string                `protobuf:"bytes,5,opt,name=lunUuid" json:"lunUuid,omitempty"`
	LunId          *int32                 `protobuf:"varint,6,opt,name=lunId" json:"lunId,omitempty"`
	Wwn            *string                `protobuf:"bytes,7,opt,name=wwn" json:"wwn,omitempty"`
	NotClusterable *bool                  `protobuf:"varint,8,opt,name=notClusterable,def=0" json:"notClusterable,omitempty"`
	ExternalName   []string               `protobuf:"bytes,9,rep,name=externalName" json:"externalName,omitempty"`
	// Files residing on the storage, if available
	File             []*EntityDTO_StorageData_StorageFileDescriptor `protobuf:"bytes,10,rep,name=file" json:"file,omitempty"`
	StorageTier      *string                                        `protobuf:"bytes,11,opt,name=storageTier" json:"storageTier,omitempty"`
	Policy           *EntityDTO_StorageData_StoragePolicy           `protobuf:"bytes,12,opt,name=policy" json:"policy,omitempty"`
	RawCapacity      *EntityDTO_StorageData_RawCapacity             `protobuf:"bytes,13,opt,name=rawCapacity" json:"rawCapacity,omitempty"`
	XXX_unrecognized []byte                                         `json:"-"`
}

func (m *EntityDTO_StorageData) Reset()                    { *m = EntityDTO_StorageData{} }
func (m *EntityDTO_StorageData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_StorageData) ProtoMessage()               {}
func (*EntityDTO_StorageData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 4} }

const Default_EntityDTO_StorageData_NotClusterable bool = false

func (m *EntityDTO_StorageData) GetStorageType() EntityDTO_StorageType {
	if m != nil && m.StorageType != nil {
		return *m.StorageType
	}
	return EntityDTO_GENERIC_BLOCK
}

func (m *EntityDTO_StorageData) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *EntityDTO_StorageData) GetExportPath() string {
	if m != nil && m.ExportPath != nil {
		return *m.ExportPath
	}
	return ""
}

func (m *EntityDTO_StorageData) GetStorageId() string {
	if m != nil && m.StorageId != nil {
		return *m.StorageId
	}
	return ""
}

func (m *EntityDTO_StorageData) GetLunUuid() string {
	if m != nil && m.LunUuid != nil {
		return *m.LunUuid
	}
	return ""
}

func (m *EntityDTO_StorageData) GetLunId() int32 {
	if m != nil && m.LunId != nil {
		return *m.LunId
	}
	return 0
}

func (m *EntityDTO_StorageData) GetWwn() string {
	if m != nil && m.Wwn != nil {
		return *m.Wwn
	}
	return ""
}

func (m *EntityDTO_StorageData) GetNotClusterable() bool {
	if m != nil && m.NotClusterable != nil {
		return *m.NotClusterable
	}
	return Default_EntityDTO_StorageData_NotClusterable
}

func (m *EntityDTO_StorageData) GetExternalName() []string {
	if m != nil {
		return m.ExternalName
	}
	return nil
}

func (m *EntityDTO_StorageData) GetFile() []*EntityDTO_StorageData_StorageFileDescriptor {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *EntityDTO_StorageData) GetStorageTier() string {
	if m != nil && m.StorageTier != nil {
		return *m.StorageTier
	}
	return ""
}

func (m *EntityDTO_StorageData) GetPolicy() *EntityDTO_StorageData_StoragePolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *EntityDTO_StorageData) GetRawCapacity() *EntityDTO_StorageData_RawCapacity {
	if m != nil {
		return m.RawCapacity
	}
	return nil
}

type EntityDTO_StorageData_StorageFileDescriptor struct {
	// Full pathname with Unix-style separators
	Path *string `protobuf:"bytes,1,req,name=path" json:"path,omitempty"`
	// File size
	SizeKb *int64 `protobuf:"varint,2,req,name=sizeKb" json:"sizeKb,omitempty"`
	// Modification time in UTC milliseconds since epoch
	ModificationTimeMs *int64 `protobuf:"varint,3,req,name=modificationTimeMs" json:"modificationTimeMs,omitempty"`
	// Type of the file, if known
	Type *EntityDTO_VirtualMachineFileType `protobuf:"varint,4,opt,name=type,enum=common_dto.EntityDTO_VirtualMachineFileType" json:"type,omitempty"`
	// IOPS provisioned needed for cost calculations
	IopsProvisioned *int32 `protobuf:"varint,5,opt,name=iopsProvisioned" json:"iopsProvisioned,omitempty"`
	// String identifying the replication type needed for cost calculations
	RedundancyType *string `protobuf:"bytes,6,opt,name=redundancyType" json:"redundancyType,omitempty"`
	// String identifying the resource group
	ResourceGroup *string `protobuf:"bytes,7,opt,name=resourceGroup" json:"resourceGroup,omitempty"`
	// Boolean identifying if blob/metal/dedicated
	DoNotDelete *bool `protobuf:"varint,8,opt,name=doNotDelete,def=0" json:"doNotDelete,omitempty"`
	// Potentially empty list of otherPaths to the file, links in Unix terminology
	OtherPaths []string `protobuf:"bytes,9,rep,name=otherPaths" json:"otherPaths,omitempty"`
	// Cloud volumes creation time
	CreationTime *string `protobuf:"bytes,10,opt,name=creationTime" json:"creationTime,omitempty"`
	// Azure volumes skuName
	SkuName *string `protobuf:"bytes,11,opt,name=skuName" json:"skuName,omitempty"`
	// snapshot Id
	SnapshotId *string `protobuf:"bytes,12,opt,name=snapshotId" json:"snapshotId,omitempty"`
	// volume name
	VolumeName *string `protobuf:"bytes,13,opt,name=volumeName" json:"volumeName,omitempty"`
	// if the file represents a Volume entity, the tags for that entity
	VolumeProperties []*EntityDTO_EntityProperty `protobuf:"bytes,15,rep,name=volumeProperties" json:"volumeProperties,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) Reset() {
	*m = EntityDTO_StorageData_StorageFileDescriptor{}
}
func (m *EntityDTO_StorageData_StorageFileDescriptor) String() string {
	return proto.CompactTextString(m)
}
func (*EntityDTO_StorageData_StorageFileDescriptor) ProtoMessage() {}
func (*EntityDTO_StorageData_StorageFileDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 4, 0}
}

const Default_EntityDTO_StorageData_StorageFileDescriptor_DoNotDelete bool = false

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetSizeKb() int64 {
	if m != nil && m.SizeKb != nil {
		return *m.SizeKb
	}
	return 0
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetModificationTimeMs() int64 {
	if m != nil && m.ModificationTimeMs != nil {
		return *m.ModificationTimeMs
	}
	return 0
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetType() EntityDTO_VirtualMachineFileType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return EntityDTO_CONFIGURATION
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetIopsProvisioned() int32 {
	if m != nil && m.IopsProvisioned != nil {
		return *m.IopsProvisioned
	}
	return 0
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetRedundancyType() string {
	if m != nil && m.RedundancyType != nil {
		return *m.RedundancyType
	}
	return ""
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetResourceGroup() string {
	if m != nil && m.ResourceGroup != nil {
		return *m.ResourceGroup
	}
	return ""
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetDoNotDelete() bool {
	if m != nil && m.DoNotDelete != nil {
		return *m.DoNotDelete
	}
	return Default_EntityDTO_StorageData_StorageFileDescriptor_DoNotDelete
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetOtherPaths() []string {
	if m != nil {
		return m.OtherPaths
	}
	return nil
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetCreationTime() string {
	if m != nil && m.CreationTime != nil {
		return *m.CreationTime
	}
	return ""
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetSkuName() string {
	if m != nil && m.SkuName != nil {
		return *m.SkuName
	}
	return ""
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetSnapshotId() string {
	if m != nil && m.SnapshotId != nil {
		return *m.SnapshotId
	}
	return ""
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetVolumeName() string {
	if m != nil && m.VolumeName != nil {
		return *m.VolumeName
	}
	return ""
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetVolumeProperties() []*EntityDTO_EntityProperty {
	if m != nil {
		return m.VolumeProperties
	}
	return nil
}

type EntityDTO_StorageData_StoragePolicy struct {
	Redundancy          *EntityDTO_StorageRedundancyMethod `protobuf:"varint,1,opt,name=redundancy,enum=common_dto.EntityDTO_StorageRedundancyMethod" json:"redundancy,omitempty"`
	FailuresToTolerate  *int32                             `protobuf:"varint,2,opt,name=failuresToTolerate" json:"failuresToTolerate,omitempty"`
	SpaceReservationPct *int32                             `protobuf:"varint,3,opt,name=spaceReservationPct" json:"spaceReservationPct,omitempty"`
	RaidFactor          *float32                           `protobuf:"fixed32,4,opt,name=raidFactor" json:"raidFactor,omitempty"`
	XXX_unrecognized    []byte                             `json:"-"`
}

func (m *EntityDTO_StorageData_StoragePolicy) Reset()         { *m = EntityDTO_StorageData_StoragePolicy{} }
func (m *EntityDTO_StorageData_StoragePolicy) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_StorageData_StoragePolicy) ProtoMessage()    {}
func (*EntityDTO_StorageData_StoragePolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 4, 1}
}

func (m *EntityDTO_StorageData_StoragePolicy) GetRedundancy() EntityDTO_StorageRedundancyMethod {
	if m != nil && m.Redundancy != nil {
		return *m.Redundancy
	}
	return EntityDTO_RAID0
}

func (m *EntityDTO_StorageData_StoragePolicy) GetFailuresToTolerate() int32 {
	if m != nil && m.FailuresToTolerate != nil {
		return *m.FailuresToTolerate
	}
	return 0
}

func (m *EntityDTO_StorageData_StoragePolicy) GetSpaceReservationPct() int32 {
	if m != nil && m.SpaceReservationPct != nil {
		return *m.SpaceReservationPct
	}
	return 0
}

func (m *EntityDTO_StorageData_StoragePolicy) GetRaidFactor() float32 {
	if m != nil && m.RaidFactor != nil {
		return *m.RaidFactor
	}
	return 0
}

type EntityDTO_StorageData_RawCapacity struct {
	Capacity         *int64 `protobuf:"varint,1,opt,name=capacity" json:"capacity,omitempty"`
	Free             *int64 `protobuf:"varint,2,opt,name=free" json:"free,omitempty"`
	Uncommitted      *int64 `protobuf:"varint,3,opt,name=uncommitted" json:"uncommitted,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_StorageData_RawCapacity) Reset()         { *m = EntityDTO_StorageData_RawCapacity{} }
func (m *EntityDTO_StorageData_RawCapacity) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_StorageData_RawCapacity) ProtoMessage()    {}
func (*EntityDTO_StorageData_RawCapacity) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 4, 2}
}

func (m *EntityDTO_StorageData_RawCapacity) GetCapacity() int64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

func (m *EntityDTO_StorageData_RawCapacity) GetFree() int64 {
	if m != nil && m.Free != nil {
		return *m.Free
	}
	return 0
}

func (m *EntityDTO_StorageData_RawCapacity) GetUncommitted() int64 {
	if m != nil && m.Uncommitted != nil {
		return *m.Uncommitted
	}
	return 0
}

// business user details
type EntityDTO_BusinessUserData struct {
	// connection sessions, if any
	SessionData      []*EntityDTO_SessionData `protobuf:"bytes,1,rep,name=sessionData" json:"sessionData,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *EntityDTO_BusinessUserData) Reset()                    { *m = EntityDTO_BusinessUserData{} }
func (m *EntityDTO_BusinessUserData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_BusinessUserData) ProtoMessage()               {}
func (*EntityDTO_BusinessUserData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 5} }

func (m *EntityDTO_BusinessUserData) GetSessionData() []*EntityDTO_SessionData {
	if m != nil {
		return m.SessionData
	}
	return nil
}

// Specific data for region
type EntityDTO_RegionData struct {
	// region should have a geo data info
	GeoData          *GeoData `protobuf:"bytes,1,opt,name=geo_data,json=geoData" json:"geo_data,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityDTO_RegionData) Reset()                    { *m = EntityDTO_RegionData{} }
func (m *EntityDTO_RegionData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_RegionData) ProtoMessage()               {}
func (*EntityDTO_RegionData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 6} }

func (m *EntityDTO_RegionData) GetGeoData() *GeoData {
	if m != nil {
		return m.GeoData
	}
	return nil
}

// describes a session (remote connection) to virtual machine by a business user
type EntityDTO_SessionData struct {
	// virtual machine to which the business user has established a session
	VirtualMachine *string `protobuf:"bytes,1,req,name=virtualMachine" json:"virtualMachine,omitempty"`
	// session duration in milliseconds
	SessionDuration  *int64 `protobuf:"varint,2,req,name=sessionDuration" json:"sessionDuration,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_SessionData) Reset()                    { *m = EntityDTO_SessionData{} }
func (m *EntityDTO_SessionData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_SessionData) ProtoMessage()               {}
func (*EntityDTO_SessionData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 7} }

func (m *EntityDTO_SessionData) GetVirtualMachine() string {
	if m != nil && m.VirtualMachine != nil {
		return *m.VirtualMachine
	}
	return ""
}

func (m *EntityDTO_SessionData) GetSessionDuration() int64 {
	if m != nil && m.SessionDuration != nil {
		return *m.SessionDuration
	}
	return 0
}

type EntityDTO_DiskArrayData struct {
	StorageId []string `protobuf:"bytes,1,rep,name=storageId" json:"storageId,omitempty"`
	// Optionally provide information about the IOPS the disk array is capable of.
	// Either provide the estimated IOPS capacity directly, or supply
	// the counts for various types of disks so that it can be computed.
	//
	// Types that are valid to be assigned to IopsData:
	//	*EntityDTO_DiskArrayData_IopsCapacity
	//	*EntityDTO_DiskArrayData_IopsComputeData
	IopsData             isEntityDTO_DiskArrayData_IopsData `protobuf_oneof:"iops_data"`
	SupportsVolumeResize *bool                              `protobuf:"varint,4,opt,name=supportsVolumeResize,def=0" json:"supportsVolumeResize,omitempty"`
	XXX_unrecognized     []byte                             `json:"-"`
}

func (m *EntityDTO_DiskArrayData) Reset()                    { *m = EntityDTO_DiskArrayData{} }
func (m *EntityDTO_DiskArrayData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_DiskArrayData) ProtoMessage()               {}
func (*EntityDTO_DiskArrayData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 8} }

const Default_EntityDTO_DiskArrayData_SupportsVolumeResize bool = false

type isEntityDTO_DiskArrayData_IopsData interface {
	isEntityDTO_DiskArrayData_IopsData()
}

type EntityDTO_DiskArrayData_IopsCapacity struct {
	IopsCapacity int64 `protobuf:"varint,2,opt,name=iopsCapacity,oneof"`
}
type EntityDTO_DiskArrayData_IopsComputeData struct {
	IopsComputeData *EntityDTO_ComputeIopsData `protobuf:"bytes,3,opt,name=iopsComputeData,oneof"`
}

func (*EntityDTO_DiskArrayData_IopsCapacity) isEntityDTO_DiskArrayData_IopsData()    {}
func (*EntityDTO_DiskArrayData_IopsComputeData) isEntityDTO_DiskArrayData_IopsData() {}

func (m *EntityDTO_DiskArrayData) GetIopsData() isEntityDTO_DiskArrayData_IopsData {
	if m != nil {
		return m.IopsData
	}
	return nil
}

func (m *EntityDTO_DiskArrayData) GetStorageId() []string {
	if m != nil {
		return m.StorageId
	}
	return nil
}

func (m *EntityDTO_DiskArrayData) GetIopsCapacity() int64 {
	if x, ok := m.GetIopsData().(*EntityDTO_DiskArrayData_IopsCapacity); ok {
		return x.IopsCapacity
	}
	return 0
}

func (m *EntityDTO_DiskArrayData) GetIopsComputeData() *EntityDTO_ComputeIopsData {
	if x, ok := m.GetIopsData().(*EntityDTO_DiskArrayData_IopsComputeData); ok {
		return x.IopsComputeData
	}
	return nil
}

func (m *EntityDTO_DiskArrayData) GetSupportsVolumeResize() bool {
	if m != nil && m.SupportsVolumeResize != nil {
		return *m.SupportsVolumeResize
	}
	return Default_EntityDTO_DiskArrayData_SupportsVolumeResize
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EntityDTO_DiskArrayData) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EntityDTO_DiskArrayData_OneofMarshaler, _EntityDTO_DiskArrayData_OneofUnmarshaler, _EntityDTO_DiskArrayData_OneofSizer, []interface{}{
		(*EntityDTO_DiskArrayData_IopsCapacity)(nil),
		(*EntityDTO_DiskArrayData_IopsComputeData)(nil),
	}
}

func _EntityDTO_DiskArrayData_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EntityDTO_DiskArrayData)
	// iops_data
	switch x := m.IopsData.(type) {
	case *EntityDTO_DiskArrayData_IopsCapacity:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.IopsCapacity))
	case *EntityDTO_DiskArrayData_IopsComputeData:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IopsComputeData); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EntityDTO_DiskArrayData.IopsData has unexpected type %T", x)
	}
	return nil
}

func _EntityDTO_DiskArrayData_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EntityDTO_DiskArrayData)
	switch tag {
	case 2: // iops_data.iopsCapacity
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.IopsData = &EntityDTO_DiskArrayData_IopsCapacity{int64(x)}
		return true, err
	case 3: // iops_data.iopsComputeData
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_ComputeIopsData)
		err := b.DecodeMessage(msg)
		m.IopsData = &EntityDTO_DiskArrayData_IopsComputeData{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EntityDTO_DiskArrayData_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EntityDTO_DiskArrayData)
	// iops_data
	switch x := m.IopsData.(type) {
	case *EntityDTO_DiskArrayData_IopsCapacity:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IopsCapacity))
	case *EntityDTO_DiskArrayData_IopsComputeData:
		s := proto.Size(x.IopsComputeData)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EntityDTO_LogicalPoolData struct {
	StorageId             []string `protobuf:"bytes,1,rep,name=storageId" json:"storageId,omitempty"`
	ServiceLevelObjective *string  `protobuf:"bytes,2,opt,name=serviceLevelObjective" json:"serviceLevelObjective,omitempty"`
	// Optionally provide information about the IOPS the logical pool is capable of.
	// Either provide the estimated IOPS capacity directly, or supply
	// the counts for various types of disks so that it can be computed.
	//
	// Types that are valid to be assigned to IopsData:
	//	*EntityDTO_LogicalPoolData_IopsCapacity
	//	*EntityDTO_LogicalPoolData_IopsComputeData
	IopsData         isEntityDTO_LogicalPoolData_IopsData `protobuf_oneof:"iops_data"`
	XXX_unrecognized []byte                               `json:"-"`
}

func (m *EntityDTO_LogicalPoolData) Reset()                    { *m = EntityDTO_LogicalPoolData{} }
func (m *EntityDTO_LogicalPoolData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_LogicalPoolData) ProtoMessage()               {}
func (*EntityDTO_LogicalPoolData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 9} }

type isEntityDTO_LogicalPoolData_IopsData interface {
	isEntityDTO_LogicalPoolData_IopsData()
}

type EntityDTO_LogicalPoolData_IopsCapacity struct {
	IopsCapacity int64 `protobuf:"varint,3,opt,name=iopsCapacity,oneof"`
}
type EntityDTO_LogicalPoolData_IopsComputeData struct {
	IopsComputeData *EntityDTO_ComputeIopsData `protobuf:"bytes,4,opt,name=iopsComputeData,oneof"`
}

func (*EntityDTO_LogicalPoolData_IopsCapacity) isEntityDTO_LogicalPoolData_IopsData()    {}
func (*EntityDTO_LogicalPoolData_IopsComputeData) isEntityDTO_LogicalPoolData_IopsData() {}

func (m *EntityDTO_LogicalPoolData) GetIopsData() isEntityDTO_LogicalPoolData_IopsData {
	if m != nil {
		return m.IopsData
	}
	return nil
}

func (m *EntityDTO_LogicalPoolData) GetStorageId() []string {
	if m != nil {
		return m.StorageId
	}
	return nil
}

func (m *EntityDTO_LogicalPoolData) GetServiceLevelObjective() string {
	if m != nil && m.ServiceLevelObjective != nil {
		return *m.ServiceLevelObjective
	}
	return ""
}

func (m *EntityDTO_LogicalPoolData) GetIopsCapacity() int64 {
	if x, ok := m.GetIopsData().(*EntityDTO_LogicalPoolData_IopsCapacity); ok {
		return x.IopsCapacity
	}
	return 0
}

func (m *EntityDTO_LogicalPoolData) GetIopsComputeData() *EntityDTO_ComputeIopsData {
	if x, ok := m.GetIopsData().(*EntityDTO_LogicalPoolData_IopsComputeData); ok {
		return x.IopsComputeData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EntityDTO_LogicalPoolData) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EntityDTO_LogicalPoolData_OneofMarshaler, _EntityDTO_LogicalPoolData_OneofUnmarshaler, _EntityDTO_LogicalPoolData_OneofSizer, []interface{}{
		(*EntityDTO_LogicalPoolData_IopsCapacity)(nil),
		(*EntityDTO_LogicalPoolData_IopsComputeData)(nil),
	}
}

func _EntityDTO_LogicalPoolData_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EntityDTO_LogicalPoolData)
	// iops_data
	switch x := m.IopsData.(type) {
	case *EntityDTO_LogicalPoolData_IopsCapacity:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.IopsCapacity))
	case *EntityDTO_LogicalPoolData_IopsComputeData:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IopsComputeData); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EntityDTO_LogicalPoolData.IopsData has unexpected type %T", x)
	}
	return nil
}

func _EntityDTO_LogicalPoolData_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EntityDTO_LogicalPoolData)
	switch tag {
	case 3: // iops_data.iopsCapacity
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.IopsData = &EntityDTO_LogicalPoolData_IopsCapacity{int64(x)}
		return true, err
	case 4: // iops_data.iopsComputeData
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_ComputeIopsData)
		err := b.DecodeMessage(msg)
		m.IopsData = &EntityDTO_LogicalPoolData_IopsComputeData{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EntityDTO_LogicalPoolData_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EntityDTO_LogicalPoolData)
	// iops_data
	switch x := m.IopsData.(type) {
	case *EntityDTO_LogicalPoolData_IopsCapacity:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IopsCapacity))
	case *EntityDTO_LogicalPoolData_IopsComputeData:
		s := proto.Size(x.IopsComputeData)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EntityDTO_ApplicationData struct {
	Type      *string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	IpAddress *string `protobuf:"bytes,2,opt,name=ipAddress" json:"ipAddress,omitempty"`
	Port      *string `protobuf:"bytes,3,opt,name=port" json:"port,omitempty"`
	// IP address of related application/VM. E.g. it can be database IP for application server.
	RelatedIpAddress *string `protobuf:"bytes,4,opt,name=relatedIpAddress" json:"relatedIpAddress,omitempty"`
	// Information related to database applications
	DbData           *EntityDTO_DatabaseData `protobuf:"bytes,5,opt,name=dbData" json:"dbData,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *EntityDTO_ApplicationData) Reset()                    { *m = EntityDTO_ApplicationData{} }
func (m *EntityDTO_ApplicationData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ApplicationData) ProtoMessage()               {}
func (*EntityDTO_ApplicationData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 10} }

func (m *EntityDTO_ApplicationData) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *EntityDTO_ApplicationData) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *EntityDTO_ApplicationData) GetPort() string {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return ""
}

func (m *EntityDTO_ApplicationData) GetRelatedIpAddress() string {
	if m != nil && m.RelatedIpAddress != nil {
		return *m.RelatedIpAddress
	}
	return ""
}

func (m *EntityDTO_ApplicationData) GetDbData() *EntityDTO_DatabaseData {
	if m != nil {
		return m.DbData
	}
	return nil
}

type EntityDTO_VirtualApplicationData struct {
	Type             *string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	IpAddress        *string `protobuf:"bytes,2,opt,name=ipAddress" json:"ipAddress,omitempty"`
	Port             *int32  `protobuf:"varint,3,opt,name=port" json:"port,omitempty"`
	ServiceType      *string `protobuf:"bytes,4,opt,name=serviceType" json:"serviceType,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_VirtualApplicationData) Reset()         { *m = EntityDTO_VirtualApplicationData{} }
func (m *EntityDTO_VirtualApplicationData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualApplicationData) ProtoMessage()    {}
func (*EntityDTO_VirtualApplicationData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 11}
}

func (m *EntityDTO_VirtualApplicationData) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *EntityDTO_VirtualApplicationData) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *EntityDTO_VirtualApplicationData) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *EntityDTO_VirtualApplicationData) GetServiceType() string {
	if m != nil && m.ServiceType != nil {
		return *m.ServiceType
	}
	return ""
}

type EntityDTO_BusinessAccountData struct {
	// Indicates whether data for this business account was discovered by the probe who is
	// creating this business account EntityDTO
	DataDiscovered *bool `protobuf:"varint,1,opt,name=dataDiscovered,def=0" json:"dataDiscovered,omitempty"`
	// The account id given by a 3rd party provider. e.g. in Azure its the subscription ID
	AccountId *string `protobuf:"bytes,2,opt,name=account_id,json=accountId" json:"account_id,omitempty"`
	// Provider-specific account attributes that together identify the pricing used by an
	// account. e.g. in Azure, the offer ID and enrollment number associated with an account
	// to determine its pricing
	PricingIdentifiers []*PricingIdentifier `protobuf:"bytes,3,rep,name=pricing_identifiers,json=pricingIdentifiers" json:"pricing_identifiers,omitempty"`
	// Information used to uniquely associate this business account with a price table.
	PriceTableKeys   []*PricingIdentifier `protobuf:"bytes,4,rep,name=price_table_keys,json=priceTableKeys" json:"price_table_keys,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *EntityDTO_BusinessAccountData) Reset()         { *m = EntityDTO_BusinessAccountData{} }
func (m *EntityDTO_BusinessAccountData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_BusinessAccountData) ProtoMessage()    {}
func (*EntityDTO_BusinessAccountData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 12}
}

const Default_EntityDTO_BusinessAccountData_DataDiscovered bool = false

func (m *EntityDTO_BusinessAccountData) GetDataDiscovered() bool {
	if m != nil && m.DataDiscovered != nil {
		return *m.DataDiscovered
	}
	return Default_EntityDTO_BusinessAccountData_DataDiscovered
}

func (m *EntityDTO_BusinessAccountData) GetAccountId() string {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return ""
}

func (m *EntityDTO_BusinessAccountData) GetPricingIdentifiers() []*PricingIdentifier {
	if m != nil {
		return m.PricingIdentifiers
	}
	return nil
}

func (m *EntityDTO_BusinessAccountData) GetPriceTableKeys() []*PricingIdentifier {
	if m != nil {
		return m.PriceTableKeys
	}
	return nil
}

// specific data for compute tier
type EntityDTO_ComputeTierData struct {
	// An identifier for matching compute tiers that belong to the same family.
	// TODO(OM-50516): Rename field to instanceSizeFamily.
	Family *string `protobuf:"bytes,1,opt,name=family" json:"family,omitempty"`
	// Quota family is the group that comprises of profiles that count towards the usage limit for
	// a defined category imposed on a Business Account.
	QuotaFamily *string `protobuf:"bytes,5,opt,name=quota_family,json=quotaFamily" json:"quota_family,omitempty"`
	// Specifies the dedicated storage configuration state for the compute tier.
	// Market uses this to decide whether or not to combine IOThroughput and NetThroughput that
	// vm is buying and add them together as consumption, then check with compute tier.
	DedicatedStorageNetworkState *EntityDTO_ComputeTierData_DedicatedStorageNetworkState `protobuf:"varint,2,opt,name=dedicated_storage_network_state,json=dedicatedStorageNetworkState,enum=common_dto.EntityDTO_ComputeTierData_DedicatedStorageNetworkState" json:"dedicated_storage_network_state,omitempty"`
	// A quantitative way to compare different tiers in a family. Each tier provides a certain
	// number of coupons, with the smallest tier in a family providing 1. Coupon is a our
	// internal way compare different tiers in a family. AWS defines Normalization
	// Factor (NFU) for different tier size:
	// https://aws.amazon.com/blogs/aws/new-instance-size-flexibility-for-ec2-reserved-instances/
	// In our internal mode, we defined the coupon to be NFU * 4. For example, "nano" has a NFU
	// of 0.25, so its coupon size is 0.25 * 4 = 1.
	NumCoupons *int32 `protobuf:"varint,3,opt,name=num_coupons,json=numCoupons" json:"num_coupons,omitempty"`
	// Specifies the number of cores that matches the tier
	// This is used for license price calculation (since not all templates are used by VMs)
	NumCores *int32 `protobuf:"varint,4,opt,name=num_cores,json=numCores" json:"num_cores,omitempty"`
	// Number of Ephemeral disks supported by this tier
	NumInstanceDisks *int32 `protobuf:"varint,6,opt,name=num_instance_disks,json=numInstanceDisks" json:"num_instance_disks,omitempty"`
	// Size of each Ephemeral disk supported by this tier in GB.
	InstanceDiskSizeGb *int32 `protobuf:"varint,7,opt,name=instance_disk_size_gb,json=instanceDiskSizeGb" json:"instance_disk_size_gb,omitempty"`
	// disk type of Ephemeral storage
	InstanceDiskType *EntityDTO_InstanceDiskType `protobuf:"varint,8,opt,name=instance_disk_type,json=instanceDiskType,enum=common_dto.EntityDTO_InstanceDiskType" json:"instance_disk_type,omitempty"`
	// property to determine if this ComputeTier supports burstable CPUs.
	BurstableCPU     *bool  `protobuf:"varint,9,opt,name=burstableCPU" json:"burstableCPU,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_ComputeTierData) Reset()                    { *m = EntityDTO_ComputeTierData{} }
func (m *EntityDTO_ComputeTierData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ComputeTierData) ProtoMessage()               {}
func (*EntityDTO_ComputeTierData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 13} }

func (m *EntityDTO_ComputeTierData) GetFamily() string {
	if m != nil && m.Family != nil {
		return *m.Family
	}
	return ""
}

func (m *EntityDTO_ComputeTierData) GetQuotaFamily() string {
	if m != nil && m.QuotaFamily != nil {
		return *m.QuotaFamily
	}
	return ""
}

func (m *EntityDTO_ComputeTierData) GetDedicatedStorageNetworkState() EntityDTO_ComputeTierData_DedicatedStorageNetworkState {
	if m != nil && m.DedicatedStorageNetworkState != nil {
		return *m.DedicatedStorageNetworkState
	}
	return EntityDTO_ComputeTierData_NOT_SUPPORTED
}

func (m *EntityDTO_ComputeTierData) GetNumCoupons() int32 {
	if m != nil && m.NumCoupons != nil {
		return *m.NumCoupons
	}
	return 0
}

func (m *EntityDTO_ComputeTierData) GetNumCores() int32 {
	if m != nil && m.NumCores != nil {
		return *m.NumCores
	}
	return 0
}

func (m *EntityDTO_ComputeTierData) GetNumInstanceDisks() int32 {
	if m != nil && m.NumInstanceDisks != nil {
		return *m.NumInstanceDisks
	}
	return 0
}

func (m *EntityDTO_ComputeTierData) GetInstanceDiskSizeGb() int32 {
	if m != nil && m.InstanceDiskSizeGb != nil {
		return *m.InstanceDiskSizeGb
	}
	return 0
}

func (m *EntityDTO_ComputeTierData) GetInstanceDiskType() EntityDTO_InstanceDiskType {
	if m != nil && m.InstanceDiskType != nil {
		return *m.InstanceDiskType
	}
	return EntityDTO_NONE
}

func (m *EntityDTO_ComputeTierData) GetBurstableCPU() bool {
	if m != nil && m.BurstableCPU != nil {
		return *m.BurstableCPU
	}
	return false
}

// specific data for virtual volume
type EntityDTO_VirtualVolumeData struct {
	// float iops capacity of volume needed for cost calculations
	StorageAccessCapacity *float32 `protobuf:"fixed32,1,opt,name=storage_access_capacity,json=storageAccessCapacity" json:"storage_access_capacity,omitempty"`
	// float storage capacity (MB) of volume needed for cost calculations
	StorageAmountCapacity *float32 `protobuf:"fixed32,2,opt,name=storage_amount_capacity,json=storageAmountCapacity" json:"storage_amount_capacity,omitempty"`
	// enum identifying the replication type needed for cost calculations
	RedundancyType *EntityDTO_VirtualVolumeData_RedundancyType `protobuf:"varint,3,opt,name=redundancy_type,json=redundancyType,enum=common_dto.EntityDTO_VirtualVolumeData_RedundancyType" json:"redundancy_type,omitempty"`
	// files associated with this Virtual Volume
	File []*EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor `protobuf:"bytes,4,rep,name=file" json:"file,omitempty"`
	// string snapshot ID of volume needed for entity details
	SnapshotId *string `protobuf:"bytes,5,opt,name=snapshotId" json:"snapshotId,omitempty"`
	// Creation time (Unix ms)
	CreationTime *int64 `protobuf:"varint,6,opt,name=creation_time,json=creationTime" json:"creation_time,omitempty"`
	// volume's IO Throughput capacity
	IoThroughputCapacity *float64 `protobuf:"fixed64,7,opt,name=io_throughput_capacity,json=ioThroughputCapacity" json:"io_throughput_capacity,omitempty"`
	// volume's IO Throughput used
	IoThroughputUsage *float64 `protobuf:"fixed64,8,opt,name=io_throughput_usage,json=ioThroughputUsage" json:"io_throughput_usage,omitempty"`
	// Whether the volume belongs to a VM
	AttachmentState *EntityDTO_VirtualVolumeData_AttachmentState `protobuf:"varint,9,opt,name=attachment_state,json=attachmentState,enum=common_dto.EntityDTO_VirtualVolumeData_AttachmentState" json:"attachment_state,omitempty"`
	// Whether the volume is encrypted
	Encrypted *bool `protobuf:"varint,10,opt,name=encrypted" json:"encrypted,omitempty"`
	// Whether the volume is Ephemeral
	IsEphemeral      *bool  `protobuf:"varint,11,opt,name=isEphemeral" json:"isEphemeral,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_VirtualVolumeData) Reset()                    { *m = EntityDTO_VirtualVolumeData{} }
func (m *EntityDTO_VirtualVolumeData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualVolumeData) ProtoMessage()               {}
func (*EntityDTO_VirtualVolumeData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 14} }

func (m *EntityDTO_VirtualVolumeData) GetStorageAccessCapacity() float32 {
	if m != nil && m.StorageAccessCapacity != nil {
		return *m.StorageAccessCapacity
	}
	return 0
}

func (m *EntityDTO_VirtualVolumeData) GetStorageAmountCapacity() float32 {
	if m != nil && m.StorageAmountCapacity != nil {
		return *m.StorageAmountCapacity
	}
	return 0
}

func (m *EntityDTO_VirtualVolumeData) GetRedundancyType() EntityDTO_VirtualVolumeData_RedundancyType {
	if m != nil && m.RedundancyType != nil {
		return *m.RedundancyType
	}
	return EntityDTO_VirtualVolumeData_LRS
}

func (m *EntityDTO_VirtualVolumeData) GetFile() []*EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *EntityDTO_VirtualVolumeData) GetSnapshotId() string {
	if m != nil && m.SnapshotId != nil {
		return *m.SnapshotId
	}
	return ""
}

func (m *EntityDTO_VirtualVolumeData) GetCreationTime() int64 {
	if m != nil && m.CreationTime != nil {
		return *m.CreationTime
	}
	return 0
}

func (m *EntityDTO_VirtualVolumeData) GetIoThroughputCapacity() float64 {
	if m != nil && m.IoThroughputCapacity != nil {
		return *m.IoThroughputCapacity
	}
	return 0
}

func (m *EntityDTO_VirtualVolumeData) GetIoThroughputUsage() float64 {
	if m != nil && m.IoThroughputUsage != nil {
		return *m.IoThroughputUsage
	}
	return 0
}

func (m *EntityDTO_VirtualVolumeData) GetAttachmentState() EntityDTO_VirtualVolumeData_AttachmentState {
	if m != nil && m.AttachmentState != nil {
		return *m.AttachmentState
	}
	return EntityDTO_VirtualVolumeData_ATTACHED
}

func (m *EntityDTO_VirtualVolumeData) GetEncrypted() bool {
	if m != nil && m.Encrypted != nil {
		return *m.Encrypted
	}
	return false
}

func (m *EntityDTO_VirtualVolumeData) GetIsEphemeral() bool {
	if m != nil && m.IsEphemeral != nil {
		return *m.IsEphemeral
	}
	return false
}

// We can have multiple files inside a virtual volume.  For example, for VC Storage
// Browsing in XL. This message describes the file
type EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor struct {
	// Full pathname with Unix-style separators
	Path *string `protobuf:"bytes,1,req,name=path" json:"path,omitempty"`
	// Size of the file
	SizeKb *int64 `protobuf:"varint,2,opt,name=sizeKb" json:"sizeKb,omitempty"`
	// Type of the file, if available
	Type *EntityDTO_VirtualMachineFileType `protobuf:"varint,3,opt,name=type,enum=common_dto.EntityDTO_VirtualMachineFileType" json:"type,omitempty"`
	// Modification time in UTC milliseconds since epoch
	ModificationTimeMs *int64 `protobuf:"varint,4,opt,name=modificationTimeMs" json:"modificationTimeMs,omitempty"`
	// Potentially empty list of other paths to the file, links in Unix terminology
	// VSAN has first level directory symbolic links with user friendly names,
	// which are what we want to match the ignore directory patterns against.
	LinkedPaths      []string `protobuf:"bytes,5,rep,name=linkedPaths" json:"linkedPaths,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor) Reset() {
	*m = EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor{}
}
func (m *EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor) String() string {
	return proto.CompactTextString(m)
}
func (*EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor) ProtoMessage() {}
func (*EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 14, 0}
}

func (m *EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor) GetSizeKb() int64 {
	if m != nil && m.SizeKb != nil {
		return *m.SizeKb
	}
	return 0
}

func (m *EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor) GetType() EntityDTO_VirtualMachineFileType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return EntityDTO_CONFIGURATION
}

func (m *EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor) GetModificationTimeMs() int64 {
	if m != nil && m.ModificationTimeMs != nil {
		return *m.ModificationTimeMs
	}
	return 0
}

func (m *EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor) GetLinkedPaths() []string {
	if m != nil {
		return m.LinkedPaths
	}
	return nil
}

type EntityDTO_VirtualMachineData struct {
	IpAddress []string `protobuf:"bytes,1,rep,name=ipAddress" json:"ipAddress,omitempty"`
	// Carries specific properties for setting Entity State of this VM.
	VmState   *EntityDTO_VMState `protobuf:"bytes,2,opt,name=vmState" json:"vmState,omitempty"`
	GuestName *string            `protobuf:"bytes,3,opt,name=guestName" json:"guestName,omitempty"`
	// Annotation notes
	AnnotationNote []*EntityDTO_VirtualMachineData_AnnotationNote `protobuf:"bytes,4,rep,name=annotationNote" json:"annotationNote,omitempty"`
	// Files in use by vm
	File []*EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor `protobuf:"bytes,5,rep,name=file" json:"file,omitempty"`
	// Total number of CPUs for the VM
	NumCpus *int32 `protobuf:"varint,6,opt,name=numCpus" json:"numCpus,omitempty"`
	// Billing type of a cloud VM -
	// on-demand vs bidding vs dedicated vs reserved
	// Please see {@link VMBillingType}
	//
	BillingType *EntityDTO_VirtualMachineData_VMBillingType `protobuf:"varint,7,opt,name=billingType,enum=common_dto.EntityDTO_VirtualMachineData_VMBillingType" json:"billingType,omitempty"`
	// Cloud bidding VM product description -
	// which is one of the factors contributing to cloud VM cost
	//
	BiddingProductDescription *string `protobuf:"bytes,8,opt,name=biddingProductDescription" json:"biddingProductDescription,omitempty"`
	// Number of Elastic Ips
	//
	NumElasticIps *int32 `protobuf:"varint,9,opt,name=numElasticIps" json:"numElasticIps,omitempty"`
	// Display name list of the connected networks, this field is
	// current for XL only.
	ConnectedNetwork []string `protobuf:"bytes,10,rep,name=connectedNetwork" json:"connectedNetwork,omitempty"`
	// VM Disk ID to Storage ID mapping. Multiple disks can point to the same storage.
	DiskToStorage map[string]string `protobuf:"bytes,11,rep,name=diskToStorage" json:"diskToStorage,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The licensing model of the VM (license included in compute price vs. BYOL)
	LicenseModel *EntityDTO_LicenseModel `protobuf:"varint,12,opt,name=licenseModel,enum=common_dto.EntityDTO_LicenseModel,def=1" json:"licenseModel,omitempty"`
	// The number of ephemeral storages attached to this VM
	NumEphemeralStorages *int32 `protobuf:"varint,13,opt,name=numEphemeralStorages" json:"numEphemeralStorages,omitempty"`
	XXX_unrecognized     []byte `json:"-"`
}

func (m *EntityDTO_VirtualMachineData) Reset()         { *m = EntityDTO_VirtualMachineData{} }
func (m *EntityDTO_VirtualMachineData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualMachineData) ProtoMessage()    {}
func (*EntityDTO_VirtualMachineData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 15}
}

const Default_EntityDTO_VirtualMachineData_LicenseModel EntityDTO_LicenseModel = EntityDTO_LICENSE_INCLUDED

func (m *EntityDTO_VirtualMachineData) GetIpAddress() []string {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *EntityDTO_VirtualMachineData) GetVmState() *EntityDTO_VMState {
	if m != nil {
		return m.VmState
	}
	return nil
}

func (m *EntityDTO_VirtualMachineData) GetGuestName() string {
	if m != nil && m.GuestName != nil {
		return *m.GuestName
	}
	return ""
}

func (m *EntityDTO_VirtualMachineData) GetAnnotationNote() []*EntityDTO_VirtualMachineData_AnnotationNote {
	if m != nil {
		return m.AnnotationNote
	}
	return nil
}

func (m *EntityDTO_VirtualMachineData) GetFile() []*EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *EntityDTO_VirtualMachineData) GetNumCpus() int32 {
	if m != nil && m.NumCpus != nil {
		return *m.NumCpus
	}
	return 0
}

func (m *EntityDTO_VirtualMachineData) GetBillingType() EntityDTO_VirtualMachineData_VMBillingType {
	if m != nil && m.BillingType != nil {
		return *m.BillingType
	}
	return EntityDTO_VirtualMachineData_ONDEMAND
}

func (m *EntityDTO_VirtualMachineData) GetBiddingProductDescription() string {
	if m != nil && m.BiddingProductDescription != nil {
		return *m.BiddingProductDescription
	}
	return ""
}

func (m *EntityDTO_VirtualMachineData) GetNumElasticIps() int32 {
	if m != nil && m.NumElasticIps != nil {
		return *m.NumElasticIps
	}
	return 0
}

func (m *EntityDTO_VirtualMachineData) GetConnectedNetwork() []string {
	if m != nil {
		return m.ConnectedNetwork
	}
	return nil
}

func (m *EntityDTO_VirtualMachineData) GetDiskToStorage() map[string]string {
	if m != nil {
		return m.DiskToStorage
	}
	return nil
}

func (m *EntityDTO_VirtualMachineData) GetLicenseModel() EntityDTO_LicenseModel {
	if m != nil && m.LicenseModel != nil {
		return *m.LicenseModel
	}
	return Default_EntityDTO_VirtualMachineData_LicenseModel
}

func (m *EntityDTO_VirtualMachineData) GetNumEphemeralStorages() int32 {
	if m != nil && m.NumEphemeralStorages != nil {
		return *m.NumEphemeralStorages
	}
	return 0
}

// Annotation note (currently used in VC only)
type EntityDTO_VirtualMachineData_AnnotationNote struct {
	// Annotation key
	Key *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	// Annotation value
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_VirtualMachineData_AnnotationNote) Reset() {
	*m = EntityDTO_VirtualMachineData_AnnotationNote{}
}
func (m *EntityDTO_VirtualMachineData_AnnotationNote) String() string {
	return proto.CompactTextString(m)
}
func (*EntityDTO_VirtualMachineData_AnnotationNote) ProtoMessage() {}
func (*EntityDTO_VirtualMachineData_AnnotationNote) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 15, 0}
}

func (m *EntityDTO_VirtualMachineData_AnnotationNote) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *EntityDTO_VirtualMachineData_AnnotationNote) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor struct {
	// Id of the storage on which the file resides
	StorageId *string `protobuf:"bytes,1,req,name=storageId" json:"storageId,omitempty"`
	// Full pathname with Unix-style separators
	Path *string `protobuf:"bytes,2,req,name=path" json:"path,omitempty"`
	// Size of the file
	SizeKb *int64 `protobuf:"varint,3,opt,name=sizeKb" json:"sizeKb,omitempty"`
	// Type of the file, if available
	Type             *EntityDTO_VirtualMachineFileType `protobuf:"varint,4,opt,name=type,enum=common_dto.EntityDTO_VirtualMachineFileType" json:"type,omitempty"`
	XXX_unrecognized []byte                            `json:"-"`
}

func (m *EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) Reset() {
	*m = EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor{}
}
func (m *EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) String() string {
	return proto.CompactTextString(m)
}
func (*EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) ProtoMessage() {}
func (*EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 15, 1}
}

func (m *EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) GetStorageId() string {
	if m != nil && m.StorageId != nil {
		return *m.StorageId
	}
	return ""
}

func (m *EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) GetSizeKb() int64 {
	if m != nil && m.SizeKb != nil {
		return *m.SizeKb
	}
	return 0
}

func (m *EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) GetType() EntityDTO_VirtualMachineFileType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return EntityDTO_CONFIGURATION
}

// Describes information related to cloud database/database server information
type EntityDTO_DatabaseData struct {
	// Engine type of the related entity
	Engine *string `protobuf:"bytes,1,opt,name=engine" json:"engine,omitempty"`
	// Edition type of the specified database engine
	Edition *string `protobuf:"bytes,2,opt,name=edition" json:"edition,omitempty"`
	// Version of the specified database engine
	Version *string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
	// deployment type of database server; e.g. Single-AZ or Multi-AZ
	DeploymentType *string `protobuf:"bytes,4,opt,name=deploymentType" json:"deploymentType,omitempty"`
	// license model of database server; e.g. BYOL or license included
	LicenseModel     *string `protobuf:"bytes,5,opt,name=licenseModel" json:"licenseModel,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_DatabaseData) Reset()                    { *m = EntityDTO_DatabaseData{} }
func (m *EntityDTO_DatabaseData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_DatabaseData) ProtoMessage()               {}
func (*EntityDTO_DatabaseData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 16} }

func (m *EntityDTO_DatabaseData) GetEngine() string {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return ""
}

func (m *EntityDTO_DatabaseData) GetEdition() string {
	if m != nil && m.Edition != nil {
		return *m.Edition
	}
	return ""
}

func (m *EntityDTO_DatabaseData) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *EntityDTO_DatabaseData) GetDeploymentType() string {
	if m != nil && m.DeploymentType != nil {
		return *m.DeploymentType
	}
	return ""
}

func (m *EntityDTO_DatabaseData) GetLicenseModel() string {
	if m != nil && m.LicenseModel != nil {
		return *m.LicenseModel
	}
	return ""
}

type EntityDTO_StorageControllerData struct {
	// Optionally provide information about the IOPS the storage controller is capable of.
	// Either provide the estimated IOPS capacity directly, or supply
	// the counts for various types of disks so that it can be computed.
	//
	// Types that are valid to be assigned to IopsData:
	//	*EntityDTO_StorageControllerData_IopsCapacity
	//	*EntityDTO_StorageControllerData_IopsComputeData
	IopsData         isEntityDTO_StorageControllerData_IopsData `protobuf_oneof:"iops_data"`
	XXX_unrecognized []byte                                     `json:"-"`
}

func (m *EntityDTO_StorageControllerData) Reset()         { *m = EntityDTO_StorageControllerData{} }
func (m *EntityDTO_StorageControllerData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_StorageControllerData) ProtoMessage()    {}
func (*EntityDTO_StorageControllerData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 17}
}

type isEntityDTO_StorageControllerData_IopsData interface {
	isEntityDTO_StorageControllerData_IopsData()
}

type EntityDTO_StorageControllerData_IopsCapacity struct {
	IopsCapacity int64 `protobuf:"varint,1,opt,name=iopsCapacity,oneof"`
}
type EntityDTO_StorageControllerData_IopsComputeData struct {
	IopsComputeData *EntityDTO_ComputeIopsData `protobuf:"bytes,2,opt,name=iopsComputeData,oneof"`
}

func (*EntityDTO_StorageControllerData_IopsCapacity) isEntityDTO_StorageControllerData_IopsData()    {}
func (*EntityDTO_StorageControllerData_IopsComputeData) isEntityDTO_StorageControllerData_IopsData() {}

func (m *EntityDTO_StorageControllerData) GetIopsData() isEntityDTO_StorageControllerData_IopsData {
	if m != nil {
		return m.IopsData
	}
	return nil
}

func (m *EntityDTO_StorageControllerData) GetIopsCapacity() int64 {
	if x, ok := m.GetIopsData().(*EntityDTO_StorageControllerData_IopsCapacity); ok {
		return x.IopsCapacity
	}
	return 0
}

func (m *EntityDTO_StorageControllerData) GetIopsComputeData() *EntityDTO_ComputeIopsData {
	if x, ok := m.GetIopsData().(*EntityDTO_StorageControllerData_IopsComputeData); ok {
		return x.IopsComputeData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EntityDTO_StorageControllerData) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EntityDTO_StorageControllerData_OneofMarshaler, _EntityDTO_StorageControllerData_OneofUnmarshaler, _EntityDTO_StorageControllerData_OneofSizer, []interface{}{
		(*EntityDTO_StorageControllerData_IopsCapacity)(nil),
		(*EntityDTO_StorageControllerData_IopsComputeData)(nil),
	}
}

func _EntityDTO_StorageControllerData_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EntityDTO_StorageControllerData)
	// iops_data
	switch x := m.IopsData.(type) {
	case *EntityDTO_StorageControllerData_IopsCapacity:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.IopsCapacity))
	case *EntityDTO_StorageControllerData_IopsComputeData:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IopsComputeData); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EntityDTO_StorageControllerData.IopsData has unexpected type %T", x)
	}
	return nil
}

func _EntityDTO_StorageControllerData_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EntityDTO_StorageControllerData)
	switch tag {
	case 1: // iops_data.iopsCapacity
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.IopsData = &EntityDTO_StorageControllerData_IopsCapacity{int64(x)}
		return true, err
	case 2: // iops_data.iopsComputeData
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_ComputeIopsData)
		err := b.DecodeMessage(msg)
		m.IopsData = &EntityDTO_StorageControllerData_IopsComputeData{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EntityDTO_StorageControllerData_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EntityDTO_StorageControllerData)
	// iops_data
	switch x := m.IopsData.(type) {
	case *EntityDTO_StorageControllerData_IopsCapacity:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IopsCapacity))
	case *EntityDTO_StorageControllerData_IopsComputeData:
		s := proto.Size(x.IopsComputeData)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EntityDTO_ContainerPodData struct {
	Namespace        *string `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
	IpAddress        *string `protobuf:"bytes,2,opt,name=ipAddress" json:"ipAddress,omitempty"`
	FullName         *string `protobuf:"bytes,3,opt,name=fullName" json:"fullName,omitempty"`
	Port             *string `protobuf:"bytes,4,opt,name=port" json:"port,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_ContainerPodData) Reset()                    { *m = EntityDTO_ContainerPodData{} }
func (m *EntityDTO_ContainerPodData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ContainerPodData) ProtoMessage()               {}
func (*EntityDTO_ContainerPodData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 18} }

func (m *EntityDTO_ContainerPodData) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *EntityDTO_ContainerPodData) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *EntityDTO_ContainerPodData) GetFullName() string {
	if m != nil && m.FullName != nil {
		return *m.FullName
	}
	return ""
}

func (m *EntityDTO_ContainerPodData) GetPort() string {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return ""
}

type EntityDTO_ContainerData struct {
	Namespace        *string `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
	IpAddress        *string `protobuf:"bytes,2,opt,name=ipAddress" json:"ipAddress,omitempty"`
	FullName         *string `protobuf:"bytes,3,opt,name=fullName" json:"fullName,omitempty"`
	Port             *string `protobuf:"bytes,4,opt,name=port" json:"port,omitempty"`
	PodName          *string `protobuf:"bytes,5,opt,name=podName" json:"podName,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_ContainerData) Reset()                    { *m = EntityDTO_ContainerData{} }
func (m *EntityDTO_ContainerData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ContainerData) ProtoMessage()               {}
func (*EntityDTO_ContainerData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 19} }

func (m *EntityDTO_ContainerData) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *EntityDTO_ContainerData) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *EntityDTO_ContainerData) GetFullName() string {
	if m != nil && m.FullName != nil {
		return *m.FullName
	}
	return ""
}

func (m *EntityDTO_ContainerData) GetPort() string {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return ""
}

func (m *EntityDTO_ContainerData) GetPodName() string {
	if m != nil && m.PodName != nil {
		return *m.PodName
	}
	return ""
}

type EntityDTO_VMState struct {
	// Notifies if the VirtualMachine is connected.
	Connected        *bool  `protobuf:"varint,1,opt,name=connected,def=1" json:"connected,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_VMState) Reset()                    { *m = EntityDTO_VMState{} }
func (m *EntityDTO_VMState) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_VMState) ProtoMessage()               {}
func (*EntityDTO_VMState) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 20} }

const Default_EntityDTO_VMState_Connected bool = true

func (m *EntityDTO_VMState) GetConnected() bool {
	if m != nil && m.Connected != nil {
		return *m.Connected
	}
	return Default_EntityDTO_VMState_Connected
}

type EntityDTO_PhysicalMachineData struct {
	// Carries specific properties for setting Entity State of this PM.
	PmState *EntityDTO_PMState `protobuf:"bytes,1,opt,name=pmState" json:"pmState,omitempty"`
	// Total number of CPU sockets on the PM.
	NumCpuSockets *int32 `protobuf:"varint,2,opt,name=numCpuSockets" json:"numCpuSockets,omitempty"`
	// Total number of CPU cores on the PM.
	NumCpuCores *int32 `protobuf:"varint,3,opt,name=numCpuCores" json:"numCpuCores,omitempty"`
	// Total number of physical CPU threads on the PM.
	NumCpuThreads *int32 `protobuf:"varint,4,opt,name=numCpuThreads" json:"numCpuThreads,omitempty"`
	// CPU frequency for one CPU core for the PM.
	CpuCoreMhz *int32 `protobuf:"varint,5,opt,name=cpuCoreMhz" json:"cpuCoreMhz,omitempty"`
	// Disk Groups do not go in ComposedOf
	DiskGroup        []*EntityDTO_DiskGroupData `protobuf:"bytes,6,rep,name=diskGroup" json:"diskGroup,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *EntityDTO_PhysicalMachineData) Reset()         { *m = EntityDTO_PhysicalMachineData{} }
func (m *EntityDTO_PhysicalMachineData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_PhysicalMachineData) ProtoMessage()    {}
func (*EntityDTO_PhysicalMachineData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 21}
}

func (m *EntityDTO_PhysicalMachineData) GetPmState() *EntityDTO_PMState {
	if m != nil {
		return m.PmState
	}
	return nil
}

func (m *EntityDTO_PhysicalMachineData) GetNumCpuSockets() int32 {
	if m != nil && m.NumCpuSockets != nil {
		return *m.NumCpuSockets
	}
	return 0
}

func (m *EntityDTO_PhysicalMachineData) GetNumCpuCores() int32 {
	if m != nil && m.NumCpuCores != nil {
		return *m.NumCpuCores
	}
	return 0
}

func (m *EntityDTO_PhysicalMachineData) GetNumCpuThreads() int32 {
	if m != nil && m.NumCpuThreads != nil {
		return *m.NumCpuThreads
	}
	return 0
}

func (m *EntityDTO_PhysicalMachineData) GetCpuCoreMhz() int32 {
	if m != nil && m.CpuCoreMhz != nil {
		return *m.CpuCoreMhz
	}
	return 0
}

func (m *EntityDTO_PhysicalMachineData) GetDiskGroup() []*EntityDTO_DiskGroupData {
	if m != nil {
		return m.DiskGroup
	}
	return nil
}

type EntityDTO_PMState struct {
	// Notifies if the PhysicalMachine is for failover.
	Failover         *bool  `protobuf:"varint,1,opt,name=failover,def=0" json:"failover,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_PMState) Reset()                    { *m = EntityDTO_PMState{} }
func (m *EntityDTO_PMState) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_PMState) ProtoMessage()               {}
func (*EntityDTO_PMState) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 22} }

const Default_EntityDTO_PMState_Failover bool = false

func (m *EntityDTO_PMState) GetFailover() bool {
	if m != nil && m.Failover != nil {
		return *m.Failover
	}
	return Default_EntityDTO_PMState_Failover
}

// Properties specific for a particular type of virtual datacenter
type EntityDTO_VirtualDatacenterTypeProps struct {
	Role             *EntityDTO_VirtualDatacenterRole `protobuf:"varint,1,opt,name=role,enum=common_dto.EntityDTO_VirtualDatacenterRole,def=1" json:"role,omitempty"`
	SupportsNesting  *bool                            `protobuf:"varint,2,opt,name=supportsNesting,def=0" json:"supportsNesting,omitempty"`
	NestedConsumer   *bool                            `protobuf:"varint,3,opt,name=nestedConsumer,def=0" json:"nestedConsumer,omitempty"`
	XXX_unrecognized []byte                           `json:"-"`
}

func (m *EntityDTO_VirtualDatacenterTypeProps) Reset()         { *m = EntityDTO_VirtualDatacenterTypeProps{} }
func (m *EntityDTO_VirtualDatacenterTypeProps) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualDatacenterTypeProps) ProtoMessage()    {}
func (*EntityDTO_VirtualDatacenterTypeProps) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 23}
}

const Default_EntityDTO_VirtualDatacenterTypeProps_Role EntityDTO_VirtualDatacenterRole = EntityDTO_CONSUMER
const Default_EntityDTO_VirtualDatacenterTypeProps_SupportsNesting bool = false
const Default_EntityDTO_VirtualDatacenterTypeProps_NestedConsumer bool = false

func (m *EntityDTO_VirtualDatacenterTypeProps) GetRole() EntityDTO_VirtualDatacenterRole {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return Default_EntityDTO_VirtualDatacenterTypeProps_Role
}

func (m *EntityDTO_VirtualDatacenterTypeProps) GetSupportsNesting() bool {
	if m != nil && m.SupportsNesting != nil {
		return *m.SupportsNesting
	}
	return Default_EntityDTO_VirtualDatacenterTypeProps_SupportsNesting
}

func (m *EntityDTO_VirtualDatacenterTypeProps) GetNestedConsumer() bool {
	if m != nil && m.NestedConsumer != nil {
		return *m.NestedConsumer
	}
	return Default_EntityDTO_VirtualDatacenterTypeProps_NestedConsumer
}

type EntityDTO_VirtualDatacenterData struct {
	PmUuid             []string                                    `protobuf:"bytes,1,rep,name=pmUuid" json:"pmUuid,omitempty"`
	VmUuid             []string                                    `protobuf:"bytes,2,rep,name=vmUuid" json:"vmUuid,omitempty"`
	SupportsStorage    *bool                                       `protobuf:"varint,3,opt,name=supportsStorage,def=1" json:"supportsStorage,omitempty"`
	VdcTypeProps       *EntityDTO_VirtualDatacenterTypeProps       `protobuf:"bytes,4,opt,name=vdc_type_props,json=vdcTypeProps" json:"vdc_type_props,omitempty"`
	VdcAllocationModel *EntityDTO_VirtualDatacenterAllocationModel `protobuf:"varint,5,opt,name=vdc_allocation_model,json=vdcAllocationModel,enum=common_dto.EntityDTO_VirtualDatacenterAllocationModel" json:"vdc_allocation_model,omitempty"`
	DesktopPoolData    *EntityDTO_DesktopPoolData                  `protobuf:"bytes,6,opt,name=desktopPoolData" json:"desktopPoolData,omitempty"`
	XXX_unrecognized   []byte                                      `json:"-"`
}

func (m *EntityDTO_VirtualDatacenterData) Reset()         { *m = EntityDTO_VirtualDatacenterData{} }
func (m *EntityDTO_VirtualDatacenterData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualDatacenterData) ProtoMessage()    {}
func (*EntityDTO_VirtualDatacenterData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 24}
}

const Default_EntityDTO_VirtualDatacenterData_SupportsStorage bool = true

func (m *EntityDTO_VirtualDatacenterData) GetPmUuid() []string {
	if m != nil {
		return m.PmUuid
	}
	return nil
}

func (m *EntityDTO_VirtualDatacenterData) GetVmUuid() []string {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *EntityDTO_VirtualDatacenterData) GetSupportsStorage() bool {
	if m != nil && m.SupportsStorage != nil {
		return *m.SupportsStorage
	}
	return Default_EntityDTO_VirtualDatacenterData_SupportsStorage
}

func (m *EntityDTO_VirtualDatacenterData) GetVdcTypeProps() *EntityDTO_VirtualDatacenterTypeProps {
	if m != nil {
		return m.VdcTypeProps
	}
	return nil
}

func (m *EntityDTO_VirtualDatacenterData) GetVdcAllocationModel() EntityDTO_VirtualDatacenterAllocationModel {
	if m != nil && m.VdcAllocationModel != nil {
		return *m.VdcAllocationModel
	}
	return EntityDTO_ALLOCATION_POOL
}

func (m *EntityDTO_VirtualDatacenterData) GetDesktopPoolData() *EntityDTO_DesktopPoolData {
	if m != nil {
		return m.DesktopPoolData
	}
	return nil
}

// VDI desktop pool details
type EntityDTO_DesktopPoolData struct {
	ProvisionType  *EntityDTO_DesktopPoolData_DesktopPoolProvisionType  `protobuf:"varint,1,req,name=provisionType,enum=common_dto.EntityDTO_DesktopPoolData_DesktopPoolProvisionType" json:"provisionType,omitempty"`
	CloneType      *EntityDTO_DesktopPoolData_DesktopPoolCloneType      `protobuf:"varint,2,req,name=cloneType,enum=common_dto.EntityDTO_DesktopPoolData_DesktopPoolCloneType" json:"cloneType,omitempty"`
	AssignmentType *EntityDTO_DesktopPoolData_DesktopPoolAssignmentType `protobuf:"varint,3,req,name=assignmentType,enum=common_dto.EntityDTO_DesktopPoolData_DesktopPoolAssignmentType" json:"assignmentType,omitempty"`
	// id of a virtual machine or entity profile used to create VDI desktops, if applicable
	MasterImage *string `protobuf:"bytes,4,opt,name=masterImage" json:"masterImage,omitempty"`
	// reference to a snapshot used to create desktops, if the master image above is a vm
	Snapshot         *string `protobuf:"bytes,5,opt,name=snapshot" json:"snapshot,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_DesktopPoolData) Reset()                    { *m = EntityDTO_DesktopPoolData{} }
func (m *EntityDTO_DesktopPoolData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_DesktopPoolData) ProtoMessage()               {}
func (*EntityDTO_DesktopPoolData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 25} }

func (m *EntityDTO_DesktopPoolData) GetProvisionType() EntityDTO_DesktopPoolData_DesktopPoolProvisionType {
	if m != nil && m.ProvisionType != nil {
		return *m.ProvisionType
	}
	return EntityDTO_DesktopPoolData_ON_DEMAND
}

func (m *EntityDTO_DesktopPoolData) GetCloneType() EntityDTO_DesktopPoolData_DesktopPoolCloneType {
	if m != nil && m.CloneType != nil {
		return *m.CloneType
	}
	return EntityDTO_DesktopPoolData_FULL
}

func (m *EntityDTO_DesktopPoolData) GetAssignmentType() EntityDTO_DesktopPoolData_DesktopPoolAssignmentType {
	if m != nil && m.AssignmentType != nil {
		return *m.AssignmentType
	}
	return EntityDTO_DesktopPoolData_DYNAMIC
}

func (m *EntityDTO_DesktopPoolData) GetMasterImage() string {
	if m != nil && m.MasterImage != nil {
		return *m.MasterImage
	}
	return ""
}

func (m *EntityDTO_DesktopPoolData) GetSnapshot() string {
	if m != nil && m.Snapshot != nil {
		return *m.Snapshot
	}
	return ""
}

type EntityDTO_EntityProperty struct {
	Namespace        *string `protobuf:"bytes,1,req,name=namespace" json:"namespace,omitempty"`
	Name             *string `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	Value            *string `protobuf:"bytes,3,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_EntityProperty) Reset()                    { *m = EntityDTO_EntityProperty{} }
func (m *EntityDTO_EntityProperty) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_EntityProperty) ProtoMessage()               {}
func (*EntityDTO_EntityProperty) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 26} }

func (m *EntityDTO_EntityProperty) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *EntityDTO_EntityProperty) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *EntityDTO_EntityProperty) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type EntityDTO_VirtualMachineRelatedData struct {
	Memory           *EntityDTO_MemoryData      `protobuf:"bytes,1,opt,name=memory" json:"memory,omitempty"`
	Processor        []*EntityDTO_ProcessorData `protobuf:"bytes,2,rep,name=processor" json:"processor,omitempty"`
	Io               []*EntityDTO_IoData        `protobuf:"bytes,3,rep,name=io" json:"io,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *EntityDTO_VirtualMachineRelatedData) Reset()         { *m = EntityDTO_VirtualMachineRelatedData{} }
func (m *EntityDTO_VirtualMachineRelatedData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualMachineRelatedData) ProtoMessage()    {}
func (*EntityDTO_VirtualMachineRelatedData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 27}
}

func (m *EntityDTO_VirtualMachineRelatedData) GetMemory() *EntityDTO_MemoryData {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *EntityDTO_VirtualMachineRelatedData) GetProcessor() []*EntityDTO_ProcessorData {
	if m != nil {
		return m.Processor
	}
	return nil
}

func (m *EntityDTO_VirtualMachineRelatedData) GetIo() []*EntityDTO_IoData {
	if m != nil {
		return m.Io
	}
	return nil
}

type EntityDTO_PhysicalMachineRelatedData struct {
	Memory           *EntityDTO_MemoryData      `protobuf:"bytes,1,opt,name=memory" json:"memory,omitempty"`
	Processor        []*EntityDTO_ProcessorData `protobuf:"bytes,2,rep,name=processor" json:"processor,omitempty"`
	Io               []*EntityDTO_IoData        `protobuf:"bytes,3,rep,name=io" json:"io,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *EntityDTO_PhysicalMachineRelatedData) Reset()         { *m = EntityDTO_PhysicalMachineRelatedData{} }
func (m *EntityDTO_PhysicalMachineRelatedData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_PhysicalMachineRelatedData) ProtoMessage()    {}
func (*EntityDTO_PhysicalMachineRelatedData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 28}
}

func (m *EntityDTO_PhysicalMachineRelatedData) GetMemory() *EntityDTO_MemoryData {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *EntityDTO_PhysicalMachineRelatedData) GetProcessor() []*EntityDTO_ProcessorData {
	if m != nil {
		return m.Processor
	}
	return nil
}

func (m *EntityDTO_PhysicalMachineRelatedData) GetIo() []*EntityDTO_IoData {
	if m != nil {
		return m.Io
	}
	return nil
}

type EntityDTO_StorageControllerRelatedData struct {
	Memory           *EntityDTO_MemoryData      `protobuf:"bytes,1,opt,name=memory" json:"memory,omitempty"`
	Processor        []*EntityDTO_ProcessorData `protobuf:"bytes,2,rep,name=processor" json:"processor,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *EntityDTO_StorageControllerRelatedData) Reset() {
	*m = EntityDTO_StorageControllerRelatedData{}
}
func (m *EntityDTO_StorageControllerRelatedData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_StorageControllerRelatedData) ProtoMessage()    {}
func (*EntityDTO_StorageControllerRelatedData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 29}
}

func (m *EntityDTO_StorageControllerRelatedData) GetMemory() *EntityDTO_MemoryData {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *EntityDTO_StorageControllerRelatedData) GetProcessor() []*EntityDTO_ProcessorData {
	if m != nil {
		return m.Processor
	}
	return nil
}

type EntityDTO_MemoryData struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	DisplayName      *string  `protobuf:"bytes,2,opt,name=displayName" json:"displayName,omitempty"`
	Capacity         *float64 `protobuf:"fixed64,3,opt,name=capacity" json:"capacity,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityDTO_MemoryData) Reset()                    { *m = EntityDTO_MemoryData{} }
func (m *EntityDTO_MemoryData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_MemoryData) ProtoMessage()               {}
func (*EntityDTO_MemoryData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 30} }

func (m *EntityDTO_MemoryData) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *EntityDTO_MemoryData) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityDTO_MemoryData) GetCapacity() float64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

type EntityDTO_ProcessorData struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	DisplayName      *string  `protobuf:"bytes,2,opt,name=displayName" json:"displayName,omitempty"`
	Capacity         *float64 `protobuf:"fixed64,3,opt,name=capacity" json:"capacity,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityDTO_ProcessorData) Reset()                    { *m = EntityDTO_ProcessorData{} }
func (m *EntityDTO_ProcessorData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ProcessorData) ProtoMessage()               {}
func (*EntityDTO_ProcessorData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 31} }

func (m *EntityDTO_ProcessorData) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *EntityDTO_ProcessorData) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityDTO_ProcessorData) GetCapacity() float64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

type EntityDTO_IoData struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	DisplayName      *string  `protobuf:"bytes,2,opt,name=displayName" json:"displayName,omitempty"`
	Speed            *float64 `protobuf:"fixed64,3,opt,name=speed" json:"speed,omitempty"`
	MacAddress       *string  `protobuf:"bytes,4,opt,name=macAddress" json:"macAddress,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityDTO_IoData) Reset()                    { *m = EntityDTO_IoData{} }
func (m *EntityDTO_IoData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_IoData) ProtoMessage()               {}
func (*EntityDTO_IoData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 32} }

func (m *EntityDTO_IoData) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *EntityDTO_IoData) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityDTO_IoData) GetSpeed() float64 {
	if m != nil && m.Speed != nil {
		return *m.Speed
	}
	return 0
}

func (m *EntityDTO_IoData) GetMacAddress() string {
	if m != nil && m.MacAddress != nil {
		return *m.MacAddress
	}
	return ""
}

// Represents a collection of disks on a host for use by vSAN or storage technology
type EntityDTO_DiskGroupData struct {
	Disk             []*EntityDTO_DiskData `protobuf:"bytes,1,rep,name=disk" json:"disk,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *EntityDTO_DiskGroupData) Reset()                    { *m = EntityDTO_DiskGroupData{} }
func (m *EntityDTO_DiskGroupData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_DiskGroupData) ProtoMessage()               {}
func (*EntityDTO_DiskGroupData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 33} }

func (m *EntityDTO_DiskGroupData) GetDisk() []*EntityDTO_DiskData {
	if m != nil {
		return m.Disk
	}
	return nil
}

// Represents an individual disk in a disk group
type EntityDTO_DiskData struct {
	Role             *EntityDTO_DiskRole `protobuf:"varint,1,opt,name=role,enum=common_dto.EntityDTO_DiskRole" json:"role,omitempty"`
	Capacity         *int64              `protobuf:"varint,2,opt,name=capacity" json:"capacity,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *EntityDTO_DiskData) Reset()                    { *m = EntityDTO_DiskData{} }
func (m *EntityDTO_DiskData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_DiskData) ProtoMessage()               {}
func (*EntityDTO_DiskData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 34} }

func (m *EntityDTO_DiskData) GetRole() EntityDTO_DiskRole {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return EntityDTO_ROLE_CACHE
}

func (m *EntityDTO_DiskData) GetCapacity() int64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

// Represents the counts of various types of disk drives in a disk array.
// The information required to compute the IOPS capacity of a Service Entity
// Includes various flags to adjust the capacity as well as values to
// multiply by settings to get the capacity.
// Each count represents the number of discovered disks of that speed.
type EntityDTO_ComputeIopsData struct {
	// If the hybrid flag is present, it modifies how the included disk counts are
	// used to compute IOPS capacity.
	Hybrid *bool `protobuf:"varint,1,opt,name=hybrid,def=0" json:"hybrid,omitempty"`
	// If the flashAvailable flag is present, it modifies how the included disk counts are
	// used to compute IOPS capacity.
	FlashAvailable *bool                     `protobuf:"varint,2,opt,name=flashAvailable,def=0" json:"flashAvailable,omitempty"`
	IopsItems      []*EntityDTO_IopsItemData `protobuf:"bytes,3,rep,name=iopsItems" json:"iopsItems,omitempty"`
	// The calculateFromHostedEntities flag defines whether IOPS capacity must be calculated as
	// sum of capacities of underlying entities (Storages or Disk Arrays)
	CalculateFromHostedEntities *bool  `protobuf:"varint,4,opt,name=calculateFromHostedEntities,def=0" json:"calculateFromHostedEntities,omitempty"`
	XXX_unrecognized            []byte `json:"-"`
}

func (m *EntityDTO_ComputeIopsData) Reset()                    { *m = EntityDTO_ComputeIopsData{} }
func (m *EntityDTO_ComputeIopsData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ComputeIopsData) ProtoMessage()               {}
func (*EntityDTO_ComputeIopsData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 35} }

const Default_EntityDTO_ComputeIopsData_Hybrid bool = false
const Default_EntityDTO_ComputeIopsData_FlashAvailable bool = false
const Default_EntityDTO_ComputeIopsData_CalculateFromHostedEntities bool = false

func (m *EntityDTO_ComputeIopsData) GetHybrid() bool {
	if m != nil && m.Hybrid != nil {
		return *m.Hybrid
	}
	return Default_EntityDTO_ComputeIopsData_Hybrid
}

func (m *EntityDTO_ComputeIopsData) GetFlashAvailable() bool {
	if m != nil && m.FlashAvailable != nil {
		return *m.FlashAvailable
	}
	return Default_EntityDTO_ComputeIopsData_FlashAvailable
}

func (m *EntityDTO_ComputeIopsData) GetIopsItems() []*EntityDTO_IopsItemData {
	if m != nil {
		return m.IopsItems
	}
	return nil
}

func (m *EntityDTO_ComputeIopsData) GetCalculateFromHostedEntities() bool {
	if m != nil && m.CalculateFromHostedEntities != nil {
		return *m.CalculateFromHostedEntities
	}
	return Default_EntityDTO_ComputeIopsData_CalculateFromHostedEntities
}

type EntityDTO_IopsItemData struct {
	// Usually derived from the IopsItemNames enum
	IopsItemName *string `protobuf:"bytes,1,req,name=iopsItemName" json:"iopsItemName,omitempty"`
	// The number of discovered disks of this type.
	IopsItemValue    *int64 `protobuf:"varint,2,req,name=iopsItemValue" json:"iopsItemValue,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_IopsItemData) Reset()                    { *m = EntityDTO_IopsItemData{} }
func (m *EntityDTO_IopsItemData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_IopsItemData) ProtoMessage()               {}
func (*EntityDTO_IopsItemData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 36} }

func (m *EntityDTO_IopsItemData) GetIopsItemName() string {
	if m != nil && m.IopsItemName != nil {
		return *m.IopsItemName
	}
	return ""
}

func (m *EntityDTO_IopsItemData) GetIopsItemValue() int64 {
	if m != nil && m.IopsItemValue != nil {
		return *m.IopsItemValue
	}
	return 0
}

// Meta data representing the entity that will replace this proxy entity
type EntityDTO_ReplacementEntityMetaData struct {
	// Replacement entity is found by matching the values of the specified properties.
	// The value for the property must be set while building the entity. Specific properties
	// are pre-defined for some entity types. Generic properties can be set using
	// the EntityProperty.
	IdentifyingProp []string `protobuf:"bytes,1,rep,name=identifyingProp" json:"identifyingProp,omitempty"`
	// Fields of proxy entity to be patched as properties to real entity
	ReplacementFields []*EntityDTO_FieldReplacement `protobuf:"bytes,101,rep,name=replacementFields" json:"replacementFields,omitempty"`
	// names of properties to be patched to real entity
	ReplacementEntityProperties []string `protobuf:"bytes,102,rep,name=replacementEntityProperties" json:"replacementEntityProperties,omitempty"`
	// Proxy entities may also transfer their commodity data to the replacement entity
	BuyingCommTypes  []*EntityDTO_ReplacementCommodityPropertyData `protobuf:"bytes,2,rep,name=buyingCommTypes" json:"buyingCommTypes,omitempty"`
	SellingCommTypes []*EntityDTO_ReplacementCommodityPropertyData `protobuf:"bytes,3,rep,name=sellingCommTypes" json:"sellingCommTypes,omitempty"`
	// Metadata for matching external entity.
	// Name of the external property whose values will be examined
	// and matched to the values of the entity DTO properties listed above
	// The field is deprecated, extEntityPropDef must be used instead.
	ExtEntityProp []string `protobuf:"bytes,4,rep,name=extEntityProp" json:"extEntityProp,omitempty"`
	// Definition of the external matching property of the entity on the server side.
	ExtEntityPropDef []*ServerEntityPropDef `protobuf:"bytes,5,rep,name=extEntityPropDef" json:"extEntityPropDef,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *EntityDTO_ReplacementEntityMetaData) Reset()         { *m = EntityDTO_ReplacementEntityMetaData{} }
func (m *EntityDTO_ReplacementEntityMetaData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_ReplacementEntityMetaData) ProtoMessage()    {}
func (*EntityDTO_ReplacementEntityMetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 37}
}

func (m *EntityDTO_ReplacementEntityMetaData) GetIdentifyingProp() []string {
	if m != nil {
		return m.IdentifyingProp
	}
	return nil
}

func (m *EntityDTO_ReplacementEntityMetaData) GetReplacementFields() []*EntityDTO_FieldReplacement {
	if m != nil {
		return m.ReplacementFields
	}
	return nil
}

func (m *EntityDTO_ReplacementEntityMetaData) GetReplacementEntityProperties() []string {
	if m != nil {
		return m.ReplacementEntityProperties
	}
	return nil
}

func (m *EntityDTO_ReplacementEntityMetaData) GetBuyingCommTypes() []*EntityDTO_ReplacementCommodityPropertyData {
	if m != nil {
		return m.BuyingCommTypes
	}
	return nil
}

func (m *EntityDTO_ReplacementEntityMetaData) GetSellingCommTypes() []*EntityDTO_ReplacementCommodityPropertyData {
	if m != nil {
		return m.SellingCommTypes
	}
	return nil
}

func (m *EntityDTO_ReplacementEntityMetaData) GetExtEntityProp() []string {
	if m != nil {
		return m.ExtEntityProp
	}
	return nil
}

func (m *EntityDTO_ReplacementEntityMetaData) GetExtEntityPropDef() []*ServerEntityPropDef {
	if m != nil {
		return m.ExtEntityPropDef
	}
	return nil
}

// Data to specify a field in the proxy's inner entity_data DTO that should patch as an
// EntityProperty to the main entity. The field can be nested within objects in the DTO.
// For example:
// FieldReplacement {
//      propertyName = "patchedProperty1234",
//      path = FieldPath {
//          field = "reserved_instance_data",
//          next = FieldPath {
//              field = "appliedScopes",
//              next = null
//          }
//      }
// }
// would refer to a field ReservedInstanceData.appliedScopes which would be patched as an
// EntityProperty with key = "patchedProperty1234".
type EntityDTO_FieldReplacement struct {
	PropertyName     *string                               `protobuf:"bytes,1,opt,name=propertyName" json:"propertyName,omitempty"`
	Path             *EntityDTO_FieldReplacement_FieldPath `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	XXX_unrecognized []byte                                `json:"-"`
}

func (m *EntityDTO_FieldReplacement) Reset()                    { *m = EntityDTO_FieldReplacement{} }
func (m *EntityDTO_FieldReplacement) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_FieldReplacement) ProtoMessage()               {}
func (*EntityDTO_FieldReplacement) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 38} }

func (m *EntityDTO_FieldReplacement) GetPropertyName() string {
	if m != nil && m.PropertyName != nil {
		return *m.PropertyName
	}
	return ""
}

func (m *EntityDTO_FieldReplacement) GetPath() *EntityDTO_FieldReplacement_FieldPath {
	if m != nil {
		return m.Path
	}
	return nil
}

type EntityDTO_FieldReplacement_FieldPath struct {
	Field            *string                               `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	Next             *EntityDTO_FieldReplacement_FieldPath `protobuf:"bytes,2,opt,name=next" json:"next,omitempty"`
	XXX_unrecognized []byte                                `json:"-"`
}

func (m *EntityDTO_FieldReplacement_FieldPath) Reset()         { *m = EntityDTO_FieldReplacement_FieldPath{} }
func (m *EntityDTO_FieldReplacement_FieldPath) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_FieldReplacement_FieldPath) ProtoMessage()    {}
func (*EntityDTO_FieldReplacement_FieldPath) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 38, 0}
}

func (m *EntityDTO_FieldReplacement_FieldPath) GetField() string {
	if m != nil && m.Field != nil {
		return *m.Field
	}
	return ""
}

func (m *EntityDTO_FieldReplacement_FieldPath) GetNext() *EntityDTO_FieldReplacement_FieldPath {
	if m != nil {
		return m.Next
	}
	return nil
}

// Data to specify which commodity types and properties
// should be patched when updating data in an entity from
// a proxy entity
type EntityDTO_ReplacementCommodityPropertyData struct {
	// Which commodity type to patch.
	CommodityType *CommodityDTO_CommodityType `protobuf:"varint,1,req,name=commodityType,enum=common_dto.CommodityDTO_CommodityType" json:"commodityType,omitempty"`
	// Which properties to transfer from the proxy entity's commodity
	// to replacement entity's commodity.
	// If no properties are specified, transfer the whole commodity.
	PropertyName     []string `protobuf:"bytes,2,rep,name=propertyName" json:"propertyName,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityDTO_ReplacementCommodityPropertyData) Reset() {
	*m = EntityDTO_ReplacementCommodityPropertyData{}
}
func (m *EntityDTO_ReplacementCommodityPropertyData) String() string {
	return proto.CompactTextString(m)
}
func (*EntityDTO_ReplacementCommodityPropertyData) ProtoMessage() {}
func (*EntityDTO_ReplacementCommodityPropertyData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 39}
}

func (m *EntityDTO_ReplacementCommodityPropertyData) GetCommodityType() CommodityDTO_CommodityType {
	if m != nil && m.CommodityType != nil {
		return *m.CommodityType
	}
	return CommodityDTO_CLUSTER
}

func (m *EntityDTO_ReplacementCommodityPropertyData) GetPropertyName() []string {
	if m != nil {
		return m.PropertyName
	}
	return nil
}

type EntityDTO_ConsumerPolicy struct {
	// Boolean property to indicate if the entity will shop together with other associated
	// entities in the Market for resources.
	ShopsTogether *bool `protobuf:"varint,1,opt,name=shopsTogether,def=0" json:"shopsTogether,omitempty"`
	// Boolean property to indicate if the entity is controllable by Market.
	// Set as false if the entity cannot be moved, righted size, etc...
	Controllable *bool `protobuf:"varint,2,opt,name=controllable,def=1" json:"controllable,omitempty"`
	// Boolean property to indicate whether the entity needs to clone
	// its supplier when it clones
	ProviderMustClone *bool `protobuf:"varint,3,opt,name=providerMustClone,def=0" json:"providerMustClone,omitempty"`
	// Boolean property to indicate whether the entity is a daemon
	Daemon *bool `protobuf:"varint,4,opt,name=daemon,def=0" json:"daemon,omitempty"`
	// Boolean property to indicate whether the entity is deletable
	Deletable        *bool  `protobuf:"varint,5,opt,name=deletable,def=1" json:"deletable,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_ConsumerPolicy) Reset()                    { *m = EntityDTO_ConsumerPolicy{} }
func (m *EntityDTO_ConsumerPolicy) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ConsumerPolicy) ProtoMessage()               {}
func (*EntityDTO_ConsumerPolicy) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 40} }

const Default_EntityDTO_ConsumerPolicy_ShopsTogether bool = false
const Default_EntityDTO_ConsumerPolicy_Controllable bool = true
const Default_EntityDTO_ConsumerPolicy_ProviderMustClone bool = false
const Default_EntityDTO_ConsumerPolicy_Daemon bool = false
const Default_EntityDTO_ConsumerPolicy_Deletable bool = true

func (m *EntityDTO_ConsumerPolicy) GetShopsTogether() bool {
	if m != nil && m.ShopsTogether != nil {
		return *m.ShopsTogether
	}
	return Default_EntityDTO_ConsumerPolicy_ShopsTogether
}

func (m *EntityDTO_ConsumerPolicy) GetControllable() bool {
	if m != nil && m.Controllable != nil {
		return *m.Controllable
	}
	return Default_EntityDTO_ConsumerPolicy_Controllable
}

func (m *EntityDTO_ConsumerPolicy) GetProviderMustClone() bool {
	if m != nil && m.ProviderMustClone != nil {
		return *m.ProviderMustClone
	}
	return Default_EntityDTO_ConsumerPolicy_ProviderMustClone
}

func (m *EntityDTO_ConsumerPolicy) GetDaemon() bool {
	if m != nil && m.Daemon != nil {
		return *m.Daemon
	}
	return Default_EntityDTO_ConsumerPolicy_Daemon
}

func (m *EntityDTO_ConsumerPolicy) GetDeletable() bool {
	if m != nil && m.Deletable != nil {
		return *m.Deletable
	}
	return Default_EntityDTO_ConsumerPolicy_Deletable
}

type EntityDTO_ProviderPolicy struct {
	// Provides availableForPlacement placement policy
	AvailableForPlacement *bool `protobuf:"varint,1,opt,name=availableForPlacement,def=1" json:"availableForPlacement,omitempty"`
	// Provides localSupported placement policy
	LocalSupported   *bool  `protobuf:"varint,2,opt,name=localSupported,def=0" json:"localSupported,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_ProviderPolicy) Reset()                    { *m = EntityDTO_ProviderPolicy{} }
func (m *EntityDTO_ProviderPolicy) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ProviderPolicy) ProtoMessage()               {}
func (*EntityDTO_ProviderPolicy) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 41} }

const Default_EntityDTO_ProviderPolicy_AvailableForPlacement bool = true
const Default_EntityDTO_ProviderPolicy_LocalSupported bool = false

func (m *EntityDTO_ProviderPolicy) GetAvailableForPlacement() bool {
	if m != nil && m.AvailableForPlacement != nil {
		return *m.AvailableForPlacement
	}
	return Default_EntityDTO_ProviderPolicy_AvailableForPlacement
}

func (m *EntityDTO_ProviderPolicy) GetLocalSupported() bool {
	if m != nil && m.LocalSupported != nil {
		return *m.LocalSupported
	}
	return Default_EntityDTO_ProviderPolicy_LocalSupported
}

type EntityDTO_ProcessorPoolData struct {
	// Upper boundary of the Processing Units that can be utilized by VMs on the Processor Pool
	MaximumProcessingUnits *float32 `protobuf:"fixed32,1,req,name=maximumProcessingUnits" json:"maximumProcessingUnits,omitempty"`
	// Available Processing Units for VM on the Processor Pool
	AvailableProcessingUnits *float32 `protobuf:"fixed32,2,req,name=availableProcessingUnits" json:"availableProcessingUnits,omitempty"`
	// Used by Uncapped VMs during busy time
	ReservedProcessingUnits *float32 `protobuf:"fixed32,3,opt,name=reservedProcessingUnits" json:"reservedProcessingUnits,omitempty"`
	XXX_unrecognized        []byte   `json:"-"`
}

func (m *EntityDTO_ProcessorPoolData) Reset()                    { *m = EntityDTO_ProcessorPoolData{} }
func (m *EntityDTO_ProcessorPoolData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ProcessorPoolData) ProtoMessage()               {}
func (*EntityDTO_ProcessorPoolData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 42} }

func (m *EntityDTO_ProcessorPoolData) GetMaximumProcessingUnits() float32 {
	if m != nil && m.MaximumProcessingUnits != nil {
		return *m.MaximumProcessingUnits
	}
	return 0
}

func (m *EntityDTO_ProcessorPoolData) GetAvailableProcessingUnits() float32 {
	if m != nil && m.AvailableProcessingUnits != nil {
		return *m.AvailableProcessingUnits
	}
	return 0
}

func (m *EntityDTO_ProcessorPoolData) GetReservedProcessingUnits() float32 {
	if m != nil && m.ReservedProcessingUnits != nil {
		return *m.ReservedProcessingUnits
	}
	return 0
}

// This represents a Reserved Instance which is a reservation of resource and capacity.
type EntityDTO_ReservedInstanceData struct {
	// Reserved Instance Id obtained from Cloud Service Provider.
	// Not present for a RI yet to be purchased.
	ReservedInstanceId *string `protobuf:"bytes,1,opt,name=reservedInstanceId" json:"reservedInstanceId,omitempty"`
	// The start timestamp of the reservation in milliseconds.
	StartTime *int64 `protobuf:"varint,2,req,name=startTime" json:"startTime,omitempty"`
	// The duration of the reservation in milliseconds.
	Duration *int64 `protobuf:"varint,3,req,name=duration" json:"duration,omitempty"`
	// Tenancy of the Reserved Instance.
	InstanceTenancy *EntityDTO_ReservedInstanceData_InstanceTenancy `protobuf:"varint,4,req,name=instanceTenancy,enum=common_dto.EntityDTO_ReservedInstanceData_InstanceTenancy" json:"instanceTenancy,omitempty"`
	// Class of RI.
	OfferingClass *EntityDTO_ReservedInstanceData_OfferingClass `protobuf:"varint,5,req,name=offeringClass,enum=common_dto.EntityDTO_ReservedInstanceData_OfferingClass" json:"offeringClass,omitempty"`
	// Represents the payment options.
	OfferingType *EntityDTO_ReservedInstanceData_OfferingType `protobuf:"varint,6,req,name=offeringType,enum=common_dto.EntityDTO_ReservedInstanceData_OfferingType" json:"offeringType,omitempty"`
	// By selecting an Availability Zone, the RI you purchase will provide a capacity reservation
	// and a discount for the use of instances in the selected Availability Zone.
	// When an Availability Zone isn’t specified, the RI is regional.
	AvailabilityZone *string `protobuf:"bytes,7,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The operating system for this RI; e.g. Linux.
	Platform *EntityDTO_ReservedInstanceData_Platform `protobuf:"varint,8,req,name=platform,enum=common_dto.EntityDTO_ReservedInstanceData_Platform" json:"platform,omitempty"`
	// A quantitative way to compare different instance types in a family.
	NumberOfCoupons *int32 `protobuf:"varint,9,req,name=numberOfCoupons" json:"numberOfCoupons,omitempty"`
	// The number of coupons used (normalized to an hourly basis from daily billing data, so may not be an integer)
	NumberOfCouponsUsed *float64 `protobuf:"fixed64,10,req,name=numberOfCouponsUsed" json:"numberOfCouponsUsed,omitempty"`
	// The up front cost paid for this RI.
	FixedCost *float64 `protobuf:"fixed64,11,req,name=fixedCost" json:"fixedCost,omitempty"`
	// Hourly cost for usage.
	UsageCost *float64 `protobuf:"fixed64,12,req,name=usageCost" json:"usageCost,omitempty"`
	// Amount you are billed every hour, regardless of usage.
	RecurringCost *float64 `protobuf:"fixed64,13,req,name=recurringCost" json:"recurringCost,omitempty"`
	// The region in which this RI is applicable. A Regional RI can be applied to a VM running
	// in any availability zone in this region.
	Region *string `protobuf:"bytes,14,req,name=region" json:"region,omitempty"`
	// The number of instances covered in this reservation.
	InstanceCount *int32 `protobuf:"varint,15,req,name=instanceCount" json:"instanceCount,omitempty"`
	// id of VirtualMachineProfile related with this Reserved Instance. e.g. aws::VMPROFILE::c1.medium
	RelatedProfileId *string  `protobuf:"bytes,16,req,name=relatedProfileId" json:"relatedProfileId,omitempty"`
	AppliedScopes    []string `protobuf:"bytes,17,rep,name=appliedScopes" json:"appliedScopes,omitempty"`
	// ID of account that purchased this RI
	PurchasingAccountId *string `protobuf:"bytes,18,opt,name=purchasingAccountId" json:"purchasingAccountId,omitempty"`
	// If shared is true this Reserved Instance can be used by all accounts in the billing
	// family. Otherwise it is used by purchasing account only.
	Shared *bool `protobuf:"varint,19,opt,name=shared,def=1" json:"shared,omitempty"`
	// If instanceSizeFlexible is true then this Reserved Instance can be applied to all
	// instance types within the family.
	InstanceSizeFlexible *bool `protobuf:"varint,20,opt,name=instanceSizeFlexible" json:"instanceSizeFlexible,omitempty"`
	// Reservation order ID. Currently it is used in Azure only.
	ReservationOrderId *string `protobuf:"bytes,21,opt,name=reservationOrderId" json:"reservationOrderId,omitempty"`
	// The property that determines if the RI is applicable to workloads running any platform or
	// to the workloads running the same platform as the RI's platform.
	PlatformFlexible *bool  `protobuf:"varint,22,opt,name=platform_flexible,json=platformFlexible,def=0" json:"platform_flexible,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_ReservedInstanceData) Reset()         { *m = EntityDTO_ReservedInstanceData{} }
func (m *EntityDTO_ReservedInstanceData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_ReservedInstanceData) ProtoMessage()    {}
func (*EntityDTO_ReservedInstanceData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 43}
}

const Default_EntityDTO_ReservedInstanceData_Shared bool = true
const Default_EntityDTO_ReservedInstanceData_PlatformFlexible bool = false

func (m *EntityDTO_ReservedInstanceData) GetReservedInstanceId() string {
	if m != nil && m.ReservedInstanceId != nil {
		return *m.ReservedInstanceId
	}
	return ""
}

func (m *EntityDTO_ReservedInstanceData) GetStartTime() int64 {
	if m != nil && m.StartTime != nil {
		return *m.StartTime
	}
	return 0
}

func (m *EntityDTO_ReservedInstanceData) GetDuration() int64 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return 0
}

func (m *EntityDTO_ReservedInstanceData) GetInstanceTenancy() EntityDTO_ReservedInstanceData_InstanceTenancy {
	if m != nil && m.InstanceTenancy != nil {
		return *m.InstanceTenancy
	}
	return EntityDTO_ReservedInstanceData_DEFAULT
}

func (m *EntityDTO_ReservedInstanceData) GetOfferingClass() EntityDTO_ReservedInstanceData_OfferingClass {
	if m != nil && m.OfferingClass != nil {
		return *m.OfferingClass
	}
	return EntityDTO_ReservedInstanceData_STANDARD
}

func (m *EntityDTO_ReservedInstanceData) GetOfferingType() EntityDTO_ReservedInstanceData_OfferingType {
	if m != nil && m.OfferingType != nil {
		return *m.OfferingType
	}
	return EntityDTO_ReservedInstanceData_ALL_UPFRONT
}

func (m *EntityDTO_ReservedInstanceData) GetAvailabilityZone() string {
	if m != nil && m.AvailabilityZone != nil {
		return *m.AvailabilityZone
	}
	return ""
}

func (m *EntityDTO_ReservedInstanceData) GetPlatform() EntityDTO_ReservedInstanceData_Platform {
	if m != nil && m.Platform != nil {
		return *m.Platform
	}
	return EntityDTO_ReservedInstanceData_UNKNOWN
}

func (m *EntityDTO_ReservedInstanceData) GetNumberOfCoupons() int32 {
	if m != nil && m.NumberOfCoupons != nil {
		return *m.NumberOfCoupons
	}
	return 0
}

func (m *EntityDTO_ReservedInstanceData) GetNumberOfCouponsUsed() float64 {
	if m != nil && m.NumberOfCouponsUsed != nil {
		return *m.NumberOfCouponsUsed
	}
	return 0
}

func (m *EntityDTO_ReservedInstanceData) GetFixedCost() float64 {
	if m != nil && m.FixedCost != nil {
		return *m.FixedCost
	}
	return 0
}

func (m *EntityDTO_ReservedInstanceData) GetUsageCost() float64 {
	if m != nil && m.UsageCost != nil {
		return *m.UsageCost
	}
	return 0
}

func (m *EntityDTO_ReservedInstanceData) GetRecurringCost() float64 {
	if m != nil && m.RecurringCost != nil {
		return *m.RecurringCost
	}
	return 0
}

func (m *EntityDTO_ReservedInstanceData) GetRegion() string {
	if m != nil && m.Region != nil {
		return *m.Region
	}
	return ""
}

func (m *EntityDTO_ReservedInstanceData) GetInstanceCount() int32 {
	if m != nil && m.InstanceCount != nil {
		return *m.InstanceCount
	}
	return 0
}

func (m *EntityDTO_ReservedInstanceData) GetRelatedProfileId() string {
	if m != nil && m.RelatedProfileId != nil {
		return *m.RelatedProfileId
	}
	return ""
}

func (m *EntityDTO_ReservedInstanceData) GetAppliedScopes() []string {
	if m != nil {
		return m.AppliedScopes
	}
	return nil
}

func (m *EntityDTO_ReservedInstanceData) GetPurchasingAccountId() string {
	if m != nil && m.PurchasingAccountId != nil {
		return *m.PurchasingAccountId
	}
	return ""
}

func (m *EntityDTO_ReservedInstanceData) GetShared() bool {
	if m != nil && m.Shared != nil {
		return *m.Shared
	}
	return Default_EntityDTO_ReservedInstanceData_Shared
}

func (m *EntityDTO_ReservedInstanceData) GetInstanceSizeFlexible() bool {
	if m != nil && m.InstanceSizeFlexible != nil {
		return *m.InstanceSizeFlexible
	}
	return false
}

func (m *EntityDTO_ReservedInstanceData) GetReservationOrderId() string {
	if m != nil && m.ReservationOrderId != nil {
		return *m.ReservationOrderId
	}
	return ""
}

func (m *EntityDTO_ReservedInstanceData) GetPlatformFlexible() bool {
	if m != nil && m.PlatformFlexible != nil {
		return *m.PlatformFlexible
	}
	return Default_EntityDTO_ReservedInstanceData_PlatformFlexible
}

type PricingIdentifier struct {
	// The name of an account attribute that identify its pricing. e.g offerId for Azure
	// accounts
	IdentifierName *PricingIdentifier_PricingIdentifierName `protobuf:"varint,1,req,name=identifier_name,json=identifierName,enum=common_dto.PricingIdentifier_PricingIdentifierName" json:"identifier_name,omitempty"`
	// The value of an account attribute that identify its pricing. e.g MS-AZR-0003 as
	// an offerId value for Azure accounts
	IdentifierValue  *string `protobuf:"bytes,2,req,name=identifier_value,json=identifierValue" json:"identifier_value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PricingIdentifier) Reset()                    { *m = PricingIdentifier{} }
func (m *PricingIdentifier) String() string            { return proto.CompactTextString(m) }
func (*PricingIdentifier) ProtoMessage()               {}
func (*PricingIdentifier) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *PricingIdentifier) GetIdentifierName() PricingIdentifier_PricingIdentifierName {
	if m != nil && m.IdentifierName != nil {
		return *m.IdentifierName
	}
	return PricingIdentifier_OFFER_ID
}

func (m *PricingIdentifier) GetIdentifierValue() string {
	if m != nil && m.IdentifierValue != nil {
		return *m.IdentifierValue
	}
	return ""
}

// Represents a specific resource (like Mem, Cpu, Network, ...) that an entity can sell to another
// entity or wants to buy from another entity.
// A commodity has multiple metrics (like used, capacity, reservation, ...) that are used to track
// the state/utilization level of that resource.
//
// Note: Some of those metrics can be extracted from the device itself, and the probe should populate
// its value here. Other metrics will be generated automatically on the server side (like the ones
// that depends on a user setting value). In addition, some metrics can have both the behavior.
// By convention, if the probe is populating the metric value, then the server side will assume that
// the probe value is final, and will not try to generate another value for it (so it will not
// override the probe value). If the probe wants the server side to generate the value, if should
// leave the metric unset.
type CommodityDTO struct {
	// Represents the type of commodity. Check {@link Commodity} enumeration for the available
	// types.
	CommodityType *CommodityDTO_CommodityType `protobuf:"varint,1,req,name=commodityType,enum=common_dto.CommodityDTO_CommodityType" json:"commodityType,omitempty"`
	// Represents the key of this commodity.<br>
	// It is a String that represents a specific constraint for this commodity. A commodity bought
	// with a specific key can only buy from a commodity sold that has the same specific key (i.e.
	// those strings should match).
	Key *string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	// Represents how much of this resource is used.
	// Used is meaningful on both the buying and selling side.
	Used *float64 `protobuf:"fixed64,3,opt,name=used" json:"used,omitempty"`
	// Represents the reservation for this resource.
	// Reservation is only meaningful on the buying side and reserves resources for the buying
	// entity. For example, a VirtualMachine may only be using 1GB of RAM, but but if the VM
	// specifies a reservation of 2GB, it ensures the resources are available if its usage spikes.
	Reservation *float64 `protobuf:"fixed64,4,opt,name=reservation" json:"reservation,omitempty"`
	// Represents the maximum capacity of this resource.
	// Capacity should only be given on the selling side and is used to specify the quantity of a commodity
	// being provided by a given entity.
	Capacity *float64 `protobuf:"fixed64,5,opt,name=capacity" json:"capacity,omitempty"`
	// Represents the limit on this resource.
	// Limit is only meaningful on the selling side and is used to limit the amount of a commodity available
	// for sale on the market to below the value specified in the capacity. For example, a VM may have
	// a VMem capacity of 4GB, but 1GB of that is needed by its operating system. In this example, specify
	// a capacity of 4GB and a limit of 3GB to limit VMem available for sale to applications on the VM.
	Limit *float64 `protobuf:"fixed64,6,opt,name=limit" json:"limit,omitempty"`
	Peak  *float64 `protobuf:"fixed64,7,opt,name=peak" json:"peak,omitempty"`
	// Has meaning on both the buying and selling side.
	// Represents whether the commodity is active and currently participating in the market.
	// Commodities that are inactive will not factor into market recommendations but will still be visible
	// in the Operations Manager UI.
	// Commodities are active by default.
	Active *bool `protobuf:"varint,8,opt,name=active,def=1" json:"active,omitempty"`
	// Has meaning on both the buying and selling side.
	// Represents whether the commodity can be resized. This flag is used to signal to the market
	// whether a commodity is eligible to receive resize up and resize down recommendations.
	// Commodities are not resizable by default.
	Resizable *bool `protobuf:"varint,9,opt,name=resizable,def=0" json:"resizable,omitempty"`
	// The 'displayName' value appears in the product GUI and in reports to identify the commodity.
	DisplayName *string `protobuf:"bytes,10,opt,name=displayName" json:"displayName,omitempty"`
	// Implies if the commodity is thin provisioned.
	// If the commodity is thin provisioned it can be overprovisioned by resizing it.
	// By setting to false. we say overprovision by resizing up is not allowed.
	Thin *bool `protobuf:"varint,11,opt,name=thin,def=1" json:"thin,omitempty"`
	// Property to indicate if the 'used' value for the commodity will be computed by the server
	// or if it is provided by Mediation.
	// The default is 'false' since the Mediation will provide the used value and that will be
	// returned by the server.
	// In situations where Mediation is not able to obtain the used values, it should set
	// this property to 'true'.
	ComputedUsed *bool `protobuf:"varint,12,opt,name=computedUsed,def=0" json:"computedUsed,omitempty"`
	// Property to indicate the amount by which the commodity will be resized.
	UsedIncrement *float64 `protobuf:"fixed64,13,opt,name=usedIncrement" json:"usedIncrement,omitempty"`
	// Commodity properties map
	PropMap []*CommodityDTO_PropertiesList `protobuf:"bytes,14,rep,name=propMap" json:"propMap,omitempty"`
	// Specifies if 'used' value is reported as percentage
	IsUsedPct *bool `protobuf:"varint,15,opt,name=isUsedPct,def=0" json:"isUsedPct,omitempty"`
	// Maximum acceptable level of resource utilization (as percentage).
	// All the remainder of the resource above this value is considered as reserved.
	// E.g. for VMware host with a utilizationThresholdPct of 70, 70% of the commodity would be
	// permitted for use by consumers of the resource and 30% would be reserved as HA failover
	// capacity.
	UtilizationThresholdPct *float64 `protobuf:"fixed64,16,opt,name=utilizationThresholdPct" json:"utilizationThresholdPct,omitempty"`
	// Metadata for the invoking a custom pricing function for the commodity.
	PricingMetadata *CommodityDTO_PricingMetadata `protobuf:"bytes,17,opt,name=pricingMetadata" json:"pricingMetadata,omitempty"`
	// Collection of commodity utilization points. The collection contains series of usage points
	// with given timestamp and interval between points. It is used to calculate percentile on
	// server side.
	UtilizationData *CommodityDTO_UtilizationData `protobuf:"bytes,18,opt,name=utilizationData" json:"utilizationData,omitempty"`
	// The min amount resource can be provided to consumer
	MinAmountForConsumer *float64 `protobuf:"fixed64,19,opt,name=min_amount_for_consumer,json=minAmountForConsumer" json:"min_amount_for_consumer,omitempty"`
	// The max amount resource can be provided to consumer
	MaxAmountForConsumer *float64 `protobuf:"fixed64,20,opt,name=max_amount_for_consumer,json=maxAmountForConsumer" json:"max_amount_for_consumer,omitempty"`
	// The max ratio between this commodity and a base commodity
	RatioDependency *CommodityDTO_RatioDependency `protobuf:"bytes,21,opt,name=ratio_dependency,json=ratioDependency" json:"ratio_dependency,omitempty"`
	// Represents the utilization percent (range of 0 to 100), corresponding to the 95th percentile
	// (or other as specified) for the given resource. This field is set for CommodityDTOs that are
	// a part of targetSE in ActionItemDTO, created during Action Execution. This field is not
	// intended to be set as a part of DiscoveryResponse and doing so will have no effect.
	PercentileUtilization *float64 `protobuf:"fixed64,22,opt,name=percentileUtilization" json:"percentileUtilization,omitempty"`
	// Collection of commodity type's specific data
	//
	// Types that are valid to be assigned to CommodityData:
	//	*CommodityDTO_StorageLatencyData_
	//	*CommodityDTO_StorageAccessData_
	//	*CommodityDTO_VstoragePartitionData
	//	*CommodityDTO_StorageProvisionedData_
	CommodityData isCommodityDTO_CommodityData `protobuf_oneof:"commodity_data"`
	// for VMem and VCpu include info on hot add/hot remove
	//
	// Types that are valid to be assigned to HotresizeData:
	//	*CommodityDTO_VmemData
	//	*CommodityDTO_VcpuData
	HotresizeData    isCommodityDTO_HotresizeData `protobuf_oneof:"hotresize_data"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *CommodityDTO) Reset()                    { *m = CommodityDTO{} }
func (m *CommodityDTO) String() string            { return proto.CompactTextString(m) }
func (*CommodityDTO) ProtoMessage()               {}
func (*CommodityDTO) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

const Default_CommodityDTO_Active bool = true
const Default_CommodityDTO_Resizable bool = false
const Default_CommodityDTO_Thin bool = true
const Default_CommodityDTO_ComputedUsed bool = false
const Default_CommodityDTO_IsUsedPct bool = false

type isCommodityDTO_CommodityData interface {
	isCommodityDTO_CommodityData()
}
type isCommodityDTO_HotresizeData interface {
	isCommodityDTO_HotresizeData()
}

type CommodityDTO_StorageLatencyData_ struct {
	StorageLatencyData *CommodityDTO_StorageLatencyData `protobuf:"bytes,500,opt,name=storage_latency_data,json=storageLatencyData,oneof"`
}
type CommodityDTO_StorageAccessData_ struct {
	StorageAccessData *CommodityDTO_StorageAccessData `protobuf:"bytes,501,opt,name=storage_access_data,json=storageAccessData,oneof"`
}
type CommodityDTO_VstoragePartitionData struct {
	VstoragePartitionData *VStoragePartitionData `protobuf:"bytes,502,opt,name=vstorage_partition_data,json=vstoragePartitionData,oneof"`
}
type CommodityDTO_StorageProvisionedData_ struct {
	StorageProvisionedData *CommodityDTO_StorageProvisionedData `protobuf:"bytes,503,opt,name=storage_provisioned_data,json=storageProvisionedData,oneof"`
}
type CommodityDTO_VmemData struct {
	VmemData *CommodityDTO_VMemData `protobuf:"bytes,200,opt,name=vmem_data,json=vmemData,oneof"`
}
type CommodityDTO_VcpuData struct {
	VcpuData *CommodityDTO_VCpuData `protobuf:"bytes,201,opt,name=vcpu_data,json=vcpuData,oneof"`
}

func (*CommodityDTO_StorageLatencyData_) isCommodityDTO_CommodityData()     {}
func (*CommodityDTO_StorageAccessData_) isCommodityDTO_CommodityData()      {}
func (*CommodityDTO_VstoragePartitionData) isCommodityDTO_CommodityData()   {}
func (*CommodityDTO_StorageProvisionedData_) isCommodityDTO_CommodityData() {}
func (*CommodityDTO_VmemData) isCommodityDTO_HotresizeData()                {}
func (*CommodityDTO_VcpuData) isCommodityDTO_HotresizeData()                {}

func (m *CommodityDTO) GetCommodityData() isCommodityDTO_CommodityData {
	if m != nil {
		return m.CommodityData
	}
	return nil
}
func (m *CommodityDTO) GetHotresizeData() isCommodityDTO_HotresizeData {
	if m != nil {
		return m.HotresizeData
	}
	return nil
}

func (m *CommodityDTO) GetCommodityType() CommodityDTO_CommodityType {
	if m != nil && m.CommodityType != nil {
		return *m.CommodityType
	}
	return CommodityDTO_CLUSTER
}

func (m *CommodityDTO) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *CommodityDTO) GetUsed() float64 {
	if m != nil && m.Used != nil {
		return *m.Used
	}
	return 0
}

func (m *CommodityDTO) GetReservation() float64 {
	if m != nil && m.Reservation != nil {
		return *m.Reservation
	}
	return 0
}

func (m *CommodityDTO) GetCapacity() float64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

func (m *CommodityDTO) GetLimit() float64 {
	if m != nil && m.Limit != nil {
		return *m.Limit
	}
	return 0
}

func (m *CommodityDTO) GetPeak() float64 {
	if m != nil && m.Peak != nil {
		return *m.Peak
	}
	return 0
}

func (m *CommodityDTO) GetActive() bool {
	if m != nil && m.Active != nil {
		return *m.Active
	}
	return Default_CommodityDTO_Active
}

func (m *CommodityDTO) GetResizable() bool {
	if m != nil && m.Resizable != nil {
		return *m.Resizable
	}
	return Default_CommodityDTO_Resizable
}

func (m *CommodityDTO) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *CommodityDTO) GetThin() bool {
	if m != nil && m.Thin != nil {
		return *m.Thin
	}
	return Default_CommodityDTO_Thin
}

func (m *CommodityDTO) GetComputedUsed() bool {
	if m != nil && m.ComputedUsed != nil {
		return *m.ComputedUsed
	}
	return Default_CommodityDTO_ComputedUsed
}

func (m *CommodityDTO) GetUsedIncrement() float64 {
	if m != nil && m.UsedIncrement != nil {
		return *m.UsedIncrement
	}
	return 0
}

func (m *CommodityDTO) GetPropMap() []*CommodityDTO_PropertiesList {
	if m != nil {
		return m.PropMap
	}
	return nil
}

func (m *CommodityDTO) GetIsUsedPct() bool {
	if m != nil && m.IsUsedPct != nil {
		return *m.IsUsedPct
	}
	return Default_CommodityDTO_IsUsedPct
}

func (m *CommodityDTO) GetUtilizationThresholdPct() float64 {
	if m != nil && m.UtilizationThresholdPct != nil {
		return *m.UtilizationThresholdPct
	}
	return 0
}

func (m *CommodityDTO) GetPricingMetadata() *CommodityDTO_PricingMetadata {
	if m != nil {
		return m.PricingMetadata
	}
	return nil
}

func (m *CommodityDTO) GetUtilizationData() *CommodityDTO_UtilizationData {
	if m != nil {
		return m.UtilizationData
	}
	return nil
}

func (m *CommodityDTO) GetMinAmountForConsumer() float64 {
	if m != nil && m.MinAmountForConsumer != nil {
		return *m.MinAmountForConsumer
	}
	return 0
}

func (m *CommodityDTO) GetMaxAmountForConsumer() float64 {
	if m != nil && m.MaxAmountForConsumer != nil {
		return *m.MaxAmountForConsumer
	}
	return 0
}

func (m *CommodityDTO) GetRatioDependency() *CommodityDTO_RatioDependency {
	if m != nil {
		return m.RatioDependency
	}
	return nil
}

func (m *CommodityDTO) GetPercentileUtilization() float64 {
	if m != nil && m.PercentileUtilization != nil {
		return *m.PercentileUtilization
	}
	return 0
}

func (m *CommodityDTO) GetStorageLatencyData() *CommodityDTO_StorageLatencyData {
	if x, ok := m.GetCommodityData().(*CommodityDTO_StorageLatencyData_); ok {
		return x.StorageLatencyData
	}
	return nil
}

func (m *CommodityDTO) GetStorageAccessData() *CommodityDTO_StorageAccessData {
	if x, ok := m.GetCommodityData().(*CommodityDTO_StorageAccessData_); ok {
		return x.StorageAccessData
	}
	return nil
}

func (m *CommodityDTO) GetVstoragePartitionData() *VStoragePartitionData {
	if x, ok := m.GetCommodityData().(*CommodityDTO_VstoragePartitionData); ok {
		return x.VstoragePartitionData
	}
	return nil
}

func (m *CommodityDTO) GetStorageProvisionedData() *CommodityDTO_StorageProvisionedData {
	if x, ok := m.GetCommodityData().(*CommodityDTO_StorageProvisionedData_); ok {
		return x.StorageProvisionedData
	}
	return nil
}

func (m *CommodityDTO) GetVmemData() *CommodityDTO_VMemData {
	if x, ok := m.GetHotresizeData().(*CommodityDTO_VmemData); ok {
		return x.VmemData
	}
	return nil
}

func (m *CommodityDTO) GetVcpuData() *CommodityDTO_VCpuData {
	if x, ok := m.GetHotresizeData().(*CommodityDTO_VcpuData); ok {
		return x.VcpuData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CommodityDTO) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CommodityDTO_OneofMarshaler, _CommodityDTO_OneofUnmarshaler, _CommodityDTO_OneofSizer, []interface{}{
		(*CommodityDTO_StorageLatencyData_)(nil),
		(*CommodityDTO_StorageAccessData_)(nil),
		(*CommodityDTO_VstoragePartitionData)(nil),
		(*CommodityDTO_StorageProvisionedData_)(nil),
		(*CommodityDTO_VmemData)(nil),
		(*CommodityDTO_VcpuData)(nil),
	}
}

func _CommodityDTO_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CommodityDTO)
	// commodity_data
	switch x := m.CommodityData.(type) {
	case *CommodityDTO_StorageLatencyData_:
		b.EncodeVarint(500<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageLatencyData); err != nil {
			return err
		}
	case *CommodityDTO_StorageAccessData_:
		b.EncodeVarint(501<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageAccessData); err != nil {
			return err
		}
	case *CommodityDTO_VstoragePartitionData:
		b.EncodeVarint(502<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VstoragePartitionData); err != nil {
			return err
		}
	case *CommodityDTO_StorageProvisionedData_:
		b.EncodeVarint(503<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageProvisionedData); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CommodityDTO.CommodityData has unexpected type %T", x)
	}
	// hotresize_data
	switch x := m.HotresizeData.(type) {
	case *CommodityDTO_VmemData:
		b.EncodeVarint(200<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VmemData); err != nil {
			return err
		}
	case *CommodityDTO_VcpuData:
		b.EncodeVarint(201<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VcpuData); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CommodityDTO.HotresizeData has unexpected type %T", x)
	}
	return nil
}

func _CommodityDTO_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CommodityDTO)
	switch tag {
	case 500: // commodity_data.storage_latency_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommodityDTO_StorageLatencyData)
		err := b.DecodeMessage(msg)
		m.CommodityData = &CommodityDTO_StorageLatencyData_{msg}
		return true, err
	case 501: // commodity_data.storage_access_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommodityDTO_StorageAccessData)
		err := b.DecodeMessage(msg)
		m.CommodityData = &CommodityDTO_StorageAccessData_{msg}
		return true, err
	case 502: // commodity_data.vstorage_partition_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VStoragePartitionData)
		err := b.DecodeMessage(msg)
		m.CommodityData = &CommodityDTO_VstoragePartitionData{msg}
		return true, err
	case 503: // commodity_data.storage_provisioned_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommodityDTO_StorageProvisionedData)
		err := b.DecodeMessage(msg)
		m.CommodityData = &CommodityDTO_StorageProvisionedData_{msg}
		return true, err
	case 200: // hotresize_data.vmem_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommodityDTO_VMemData)
		err := b.DecodeMessage(msg)
		m.HotresizeData = &CommodityDTO_VmemData{msg}
		return true, err
	case 201: // hotresize_data.vcpu_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommodityDTO_VCpuData)
		err := b.DecodeMessage(msg)
		m.HotresizeData = &CommodityDTO_VcpuData{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CommodityDTO_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CommodityDTO)
	// commodity_data
	switch x := m.CommodityData.(type) {
	case *CommodityDTO_StorageLatencyData_:
		s := proto.Size(x.StorageLatencyData)
		n += proto.SizeVarint(500<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommodityDTO_StorageAccessData_:
		s := proto.Size(x.StorageAccessData)
		n += proto.SizeVarint(501<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommodityDTO_VstoragePartitionData:
		s := proto.Size(x.VstoragePartitionData)
		n += proto.SizeVarint(502<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommodityDTO_StorageProvisionedData_:
		s := proto.Size(x.StorageProvisionedData)
		n += proto.SizeVarint(503<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// hotresize_data
	switch x := m.HotresizeData.(type) {
	case *CommodityDTO_VmemData:
		s := proto.Size(x.VmemData)
		n += proto.SizeVarint(200<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommodityDTO_VcpuData:
		s := proto.Size(x.VcpuData)
		n += proto.SizeVarint(201<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The max amount resource will be decided by another commodity's usage on the consumer
type CommodityDTO_RatioDependency struct {
	// the type of commodity whose usage will be used as a factor
	BaseCommodity *CommodityDTO_CommodityType `protobuf:"varint,1,opt,name=base_commodity,json=baseCommodity,enum=common_dto.CommodityDTO_CommodityType" json:"base_commodity,omitempty"`
	// the ratio which will be used to multiply with base commodity's usage
	Ratio            *int32 `protobuf:"varint,2,opt,name=ratio" json:"ratio,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CommodityDTO_RatioDependency) Reset()                    { *m = CommodityDTO_RatioDependency{} }
func (m *CommodityDTO_RatioDependency) String() string            { return proto.CompactTextString(m) }
func (*CommodityDTO_RatioDependency) ProtoMessage()               {}
func (*CommodityDTO_RatioDependency) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2, 0} }

func (m *CommodityDTO_RatioDependency) GetBaseCommodity() CommodityDTO_CommodityType {
	if m != nil && m.BaseCommodity != nil {
		return *m.BaseCommodity
	}
	return CommodityDTO_CLUSTER
}

func (m *CommodityDTO_RatioDependency) GetRatio() int32 {
	if m != nil && m.Ratio != nil {
		return *m.Ratio
	}
	return 0
}

// Map property type to list of strings
type CommodityDTO_PropertiesList struct {
	Name             *string  `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Values           []string `protobuf:"bytes,2,rep,name=values" json:"values,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CommodityDTO_PropertiesList) Reset()                    { *m = CommodityDTO_PropertiesList{} }
func (m *CommodityDTO_PropertiesList) String() string            { return proto.CompactTextString(m) }
func (*CommodityDTO_PropertiesList) ProtoMessage()               {}
func (*CommodityDTO_PropertiesList) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2, 1} }

func (m *CommodityDTO_PropertiesList) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *CommodityDTO_PropertiesList) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type CommodityDTO_StorageLatencyData struct {
	SupportsDiskArrayLatency           *bool  `protobuf:"varint,1,opt,name=supportsDiskArrayLatency" json:"supportsDiskArrayLatency,omitempty"`
	SupportsStorageLatency             *bool  `protobuf:"varint,2,opt,name=supportsStorageLatency" json:"supportsStorageLatency,omitempty"`
	SupportsLogicalPoolLatency         *bool  `protobuf:"varint,3,opt,name=supportsLogicalPoolLatency" json:"supportsLogicalPoolLatency,omitempty"`
	SupportsLogicalPoolLatencyCapacity *bool  `protobuf:"varint,4,opt,name=supportsLogicalPoolLatencyCapacity" json:"supportsLogicalPoolLatencyCapacity,omitempty"`
	XXX_unrecognized                   []byte `json:"-"`
}

func (m *CommodityDTO_StorageLatencyData) Reset()         { *m = CommodityDTO_StorageLatencyData{} }
func (m *CommodityDTO_StorageLatencyData) String() string { return proto.CompactTextString(m) }
func (*CommodityDTO_StorageLatencyData) ProtoMessage()    {}
func (*CommodityDTO_StorageLatencyData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{2, 2}
}

func (m *CommodityDTO_StorageLatencyData) GetSupportsDiskArrayLatency() bool {
	if m != nil && m.SupportsDiskArrayLatency != nil {
		return *m.SupportsDiskArrayLatency
	}
	return false
}

func (m *CommodityDTO_StorageLatencyData) GetSupportsStorageLatency() bool {
	if m != nil && m.SupportsStorageLatency != nil {
		return *m.SupportsStorageLatency
	}
	return false
}

func (m *CommodityDTO_StorageLatencyData) GetSupportsLogicalPoolLatency() bool {
	if m != nil && m.SupportsLogicalPoolLatency != nil {
		return *m.SupportsLogicalPoolLatency
	}
	return false
}

func (m *CommodityDTO_StorageLatencyData) GetSupportsLogicalPoolLatencyCapacity() bool {
	if m != nil && m.SupportsLogicalPoolLatencyCapacity != nil {
		return *m.SupportsLogicalPoolLatencyCapacity
	}
	return false
}

type CommodityDTO_StorageAccessData struct {
	SupportsDiskArrayIOPS   *bool  `protobuf:"varint,1,opt,name=supportsDiskArrayIOPS" json:"supportsDiskArrayIOPS,omitempty"`
	SupportsStorageIOPS     *bool  `protobuf:"varint,2,opt,name=supportsStorageIOPS" json:"supportsStorageIOPS,omitempty"`
	SupportsLogicalPoolIOPS *bool  `protobuf:"varint,3,opt,name=supportsLogicalPoolIOPS" json:"supportsLogicalPoolIOPS,omitempty"`
	XXX_unrecognized        []byte `json:"-"`
}

func (m *CommodityDTO_StorageAccessData) Reset()         { *m = CommodityDTO_StorageAccessData{} }
func (m *CommodityDTO_StorageAccessData) String() string { return proto.CompactTextString(m) }
func (*CommodityDTO_StorageAccessData) ProtoMessage()    {}
func (*CommodityDTO_StorageAccessData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{2, 3}
}

func (m *CommodityDTO_StorageAccessData) GetSupportsDiskArrayIOPS() bool {
	if m != nil && m.SupportsDiskArrayIOPS != nil {
		return *m.SupportsDiskArrayIOPS
	}
	return false
}

func (m *CommodityDTO_StorageAccessData) GetSupportsStorageIOPS() bool {
	if m != nil && m.SupportsStorageIOPS != nil {
		return *m.SupportsStorageIOPS
	}
	return false
}

func (m *CommodityDTO_StorageAccessData) GetSupportsLogicalPoolIOPS() bool {
	if m != nil && m.SupportsLogicalPoolIOPS != nil {
		return *m.SupportsLogicalPoolIOPS
	}
	return false
}

type CommodityDTO_StorageProvisionedData struct {
	UsedAdjustment   *float64 `protobuf:"fixed64,1,opt,name=usedAdjustment" json:"usedAdjustment,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CommodityDTO_StorageProvisionedData) Reset()         { *m = CommodityDTO_StorageProvisionedData{} }
func (m *CommodityDTO_StorageProvisionedData) String() string { return proto.CompactTextString(m) }
func (*CommodityDTO_StorageProvisionedData) ProtoMessage()    {}
func (*CommodityDTO_StorageProvisionedData) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{2, 4}
}

func (m *CommodityDTO_StorageProvisionedData) GetUsedAdjustment() float64 {
	if m != nil && m.UsedAdjustment != nil {
		return *m.UsedAdjustment
	}
	return 0
}

type CommodityDTO_VMemData struct {
	HotAddSupported  *bool  `protobuf:"varint,1,opt,name=hotAddSupported,def=0" json:"hotAddSupported,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CommodityDTO_VMemData) Reset()                    { *m = CommodityDTO_VMemData{} }
func (m *CommodityDTO_VMemData) String() string            { return proto.CompactTextString(m) }
func (*CommodityDTO_VMemData) ProtoMessage()               {}
func (*CommodityDTO_VMemData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2, 5} }

const Default_CommodityDTO_VMemData_HotAddSupported bool = false

func (m *CommodityDTO_VMemData) GetHotAddSupported() bool {
	if m != nil && m.HotAddSupported != nil {
		return *m.HotAddSupported
	}
	return Default_CommodityDTO_VMemData_HotAddSupported
}

type CommodityDTO_VCpuData struct {
	HotAddSupported    *bool `protobuf:"varint,1,opt,name=hotAddSupported,def=0" json:"hotAddSupported,omitempty"`
	HotRemoveSupported *bool `protobuf:"varint,2,opt,name=hotRemoveSupported,def=0" json:"hotRemoveSupported,omitempty"`
	// whether the vcpu used is a per CPU core reading or a per node reading
	IsReadingPerCpu  *bool  `protobuf:"varint,3,opt,name=isReadingPerCpu,def=0" json:"isReadingPerCpu,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CommodityDTO_VCpuData) Reset()                    { *m = CommodityDTO_VCpuData{} }
func (m *CommodityDTO_VCpuData) String() string            { return proto.CompactTextString(m) }
func (*CommodityDTO_VCpuData) ProtoMessage()               {}
func (*CommodityDTO_VCpuData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2, 6} }

const Default_CommodityDTO_VCpuData_HotAddSupported bool = false
const Default_CommodityDTO_VCpuData_HotRemoveSupported bool = false
const Default_CommodityDTO_VCpuData_IsReadingPerCpu bool = false

func (m *CommodityDTO_VCpuData) GetHotAddSupported() bool {
	if m != nil && m.HotAddSupported != nil {
		return *m.HotAddSupported
	}
	return Default_CommodityDTO_VCpuData_HotAddSupported
}

func (m *CommodityDTO_VCpuData) GetHotRemoveSupported() bool {
	if m != nil && m.HotRemoveSupported != nil {
		return *m.HotRemoveSupported
	}
	return Default_CommodityDTO_VCpuData_HotRemoveSupported
}

func (m *CommodityDTO_VCpuData) GetIsReadingPerCpu() bool {
	if m != nil && m.IsReadingPerCpu != nil {
		return *m.IsReadingPerCpu
	}
	return Default_CommodityDTO_VCpuData_IsReadingPerCpu
}

// Metadata for invoking a custom pricing function for the commodity
type CommodityDTO_PricingMetadata struct {
	// Namespace of the handler for the pricing function for this commodity
	PricingHandlerNamespace *CustomTypeDef_MetadataNamespace `protobuf:"varint,1,req,name=pricingHandlerNamespace,enum=common_dto.CustomTypeDef_MetadataNamespace" json:"pricingHandlerNamespace,omitempty"`
	XXX_unrecognized        []byte                           `json:"-"`
}

func (m *CommodityDTO_PricingMetadata) Reset()                    { *m = CommodityDTO_PricingMetadata{} }
func (m *CommodityDTO_PricingMetadata) String() string            { return proto.CompactTextString(m) }
func (*CommodityDTO_PricingMetadata) ProtoMessage()               {}
func (*CommodityDTO_PricingMetadata) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2, 7} }

func (m *CommodityDTO_PricingMetadata) GetPricingHandlerNamespace() CustomTypeDef_MetadataNamespace {
	if m != nil && m.PricingHandlerNamespace != nil {
		return *m.PricingHandlerNamespace
	}
	return CustomTypeDef_UNKNOWN
}

// Represents a collection of utilization data points.
type CommodityDTO_UtilizationData struct {
	// Array of data points. The last element in the array refers to the latest point in time.
	Point []float64 `protobuf:"fixed64,1,rep,name=point" json:"point,omitempty"`
	// The timestamp of the last (the most recent) point in the array.
	LastPointTimestampMs *int64 `protobuf:"varint,2,req,name=lastPointTimestampMs" json:"lastPointTimestampMs,omitempty"`
	// Interval in milliseconds between 2 consecutive points in the array.
	IntervalMs       *int32 `protobuf:"varint,3,req,name=intervalMs" json:"intervalMs,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CommodityDTO_UtilizationData) Reset()                    { *m = CommodityDTO_UtilizationData{} }
func (m *CommodityDTO_UtilizationData) String() string            { return proto.CompactTextString(m) }
func (*CommodityDTO_UtilizationData) ProtoMessage()               {}
func (*CommodityDTO_UtilizationData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2, 8} }

func (m *CommodityDTO_UtilizationData) GetPoint() []float64 {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *CommodityDTO_UtilizationData) GetLastPointTimestampMs() int64 {
	if m != nil && m.LastPointTimestampMs != nil {
		return *m.LastPointTimestampMs
	}
	return 0
}

func (m *CommodityDTO_UtilizationData) GetIntervalMs() int32 {
	if m != nil && m.IntervalMs != nil {
		return *m.IntervalMs
	}
	return 0
}

// The partition that the VStorage sits on.  Used for display in the UI.
type VStoragePartitionData struct {
	Partition        *string `protobuf:"bytes,1,opt,name=partition" json:"partition,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *VStoragePartitionData) Reset()                    { *m = VStoragePartitionData{} }
func (m *VStoragePartitionData) String() string            { return proto.CompactTextString(m) }
func (*VStoragePartitionData) ProtoMessage()               {}
func (*VStoragePartitionData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *VStoragePartitionData) GetPartition() string {
	if m != nil && m.Partition != nil {
		return *m.Partition
	}
	return ""
}

// GroupDTO message carries information to setup Group and Constraint in server.
type GroupDTO struct {
	// Type of entities included in this group
	// Entity type is optional. If group already exists it can be retrieved from group entities.
	// Entity type can be empty for incremental discovery.
	EntityType *EntityDTO_EntityType `protobuf:"varint,1,opt,name=entity_type,json=entityType,enum=common_dto.EntityDTO_EntityType" json:"entity_type,omitempty"`
	// Display name for the group
	DisplayName *string `protobuf:"bytes,2,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
	// Information about the group
	// If the group is associated with any constraint, this is the place containing constraint information
	// Otherwise, it will be group name
	//
	// Types that are valid to be assigned to Info:
	//	*GroupDTO_GroupName
	//	*GroupDTO_ConstraintInfo_
	Info isGroupDTO_Info `protobuf_oneof:"info"`
	// Members information for the group
	// The group can be either dynamic or static
	// For dynamic group, it will be SelectionSpec used to select group members
	// For static group, it will be MembersList which contains a list of member uuids
	// For merge policy, it will be cluster uuid
	//
	// Types that are valid to be assigned to Members:
	//	*GroupDTO_SelectionSpecList_
	//	*GroupDTO_MemberList
	//	*GroupDTO_AddedAndRemovedMembers
	//	*GroupDTO_SourceGroupId
	Members isGroupDTO_Members `protobuf_oneof:"members"`
	// list of <string, string, string> namespace, key, value triplets
	EntityProperties []*EntityDTO_EntityProperty `protobuf:"bytes,9,rep,name=entityProperties" json:"entityProperties,omitempty"`
	// Specifies group DTO Update type (can be a new/existing group or deleted group).
	UpdateType *UpdateType `protobuf:"varint,10,opt,name=updateType,enum=common_dto.UpdateType,def=0" json:"updateType,omitempty"`
	// Specifies group DTO type (can be either a regular group or a resource group).
	GroupType *GroupDTO_GroupType `protobuf:"varint,11,opt,name=groupType,enum=common_dto.GroupDTO_GroupType,def=0" json:"groupType,omitempty"`
	// Specifies if the group should be resized consistently or not
	IsConsistentResizing *bool `protobuf:"varint,12,opt,name=isConsistentResizing,def=0" json:"isConsistentResizing,omitempty"`
	// Tags related to group.
	Tags map[string]*GroupDTO_TagValues `protobuf:"bytes,13,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// "Owner" of the group.
	// The main use case (Sept 5 2019) is Business Accounts (account id) that own Resource
	// Groups.
	Owner            *string `protobuf:"bytes,14,opt,name=owner" json:"owner,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *GroupDTO) Reset()                    { *m = GroupDTO{} }
func (m *GroupDTO) String() string            { return proto.CompactTextString(m) }
func (*GroupDTO) ProtoMessage()               {}
func (*GroupDTO) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

const Default_GroupDTO_UpdateType UpdateType = UpdateType_UPDATED
const Default_GroupDTO_GroupType GroupDTO_GroupType = GroupDTO_REGULAR
const Default_GroupDTO_IsConsistentResizing bool = false

type isGroupDTO_Info interface {
	isGroupDTO_Info()
}
type isGroupDTO_Members interface {
	isGroupDTO_Members()
}

type GroupDTO_GroupName struct {
	GroupName string `protobuf:"bytes,3,opt,name=group_name,json=groupName,oneof"`
}
type GroupDTO_ConstraintInfo_ struct {
	ConstraintInfo *GroupDTO_ConstraintInfo `protobuf:"bytes,4,opt,name=constraint_info,json=constraintInfo,oneof"`
}
type GroupDTO_SelectionSpecList_ struct {
	SelectionSpecList *GroupDTO_SelectionSpecList `protobuf:"bytes,5,opt,name=selection_spec_list,json=selectionSpecList,oneof"`
}
type GroupDTO_MemberList struct {
	MemberList *GroupDTO_MembersList `protobuf:"bytes,6,opt,name=member_list,json=memberList,oneof"`
}
type GroupDTO_AddedAndRemovedMembers struct {
	AddedAndRemovedMembers *GroupDTO_AddedAndRemovedMembersList `protobuf:"bytes,7,opt,name=added_and_removed_members,json=addedAndRemovedMembers,oneof"`
}
type GroupDTO_SourceGroupId struct {
	SourceGroupId string `protobuf:"bytes,8,opt,name=source_group_id,json=sourceGroupId,oneof"`
}

func (*GroupDTO_GroupName) isGroupDTO_Info()                 {}
func (*GroupDTO_ConstraintInfo_) isGroupDTO_Info()           {}
func (*GroupDTO_SelectionSpecList_) isGroupDTO_Members()     {}
func (*GroupDTO_MemberList) isGroupDTO_Members()             {}
func (*GroupDTO_AddedAndRemovedMembers) isGroupDTO_Members() {}
func (*GroupDTO_SourceGroupId) isGroupDTO_Members()          {}

func (m *GroupDTO) GetInfo() isGroupDTO_Info {
	if m != nil {
		return m.Info
	}
	return nil
}
func (m *GroupDTO) GetMembers() isGroupDTO_Members {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *GroupDTO) GetEntityType() EntityDTO_EntityType {
	if m != nil && m.EntityType != nil {
		return *m.EntityType
	}
	return EntityDTO_SWITCH
}

func (m *GroupDTO) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *GroupDTO) GetGroupName() string {
	if x, ok := m.GetInfo().(*GroupDTO_GroupName); ok {
		return x.GroupName
	}
	return ""
}

func (m *GroupDTO) GetConstraintInfo() *GroupDTO_ConstraintInfo {
	if x, ok := m.GetInfo().(*GroupDTO_ConstraintInfo_); ok {
		return x.ConstraintInfo
	}
	return nil
}

func (m *GroupDTO) GetSelectionSpecList() *GroupDTO_SelectionSpecList {
	if x, ok := m.GetMembers().(*GroupDTO_SelectionSpecList_); ok {
		return x.SelectionSpecList
	}
	return nil
}

func (m *GroupDTO) GetMemberList() *GroupDTO_MembersList {
	if x, ok := m.GetMembers().(*GroupDTO_MemberList); ok {
		return x.MemberList
	}
	return nil
}

func (m *GroupDTO) GetAddedAndRemovedMembers() *GroupDTO_AddedAndRemovedMembersList {
	if x, ok := m.GetMembers().(*GroupDTO_AddedAndRemovedMembers); ok {
		return x.AddedAndRemovedMembers
	}
	return nil
}

func (m *GroupDTO) GetSourceGroupId() string {
	if x, ok := m.GetMembers().(*GroupDTO_SourceGroupId); ok {
		return x.SourceGroupId
	}
	return ""
}

func (m *GroupDTO) GetEntityProperties() []*EntityDTO_EntityProperty {
	if m != nil {
		return m.EntityProperties
	}
	return nil
}

func (m *GroupDTO) GetUpdateType() UpdateType {
	if m != nil && m.UpdateType != nil {
		return *m.UpdateType
	}
	return Default_GroupDTO_UpdateType
}

func (m *GroupDTO) GetGroupType() GroupDTO_GroupType {
	if m != nil && m.GroupType != nil {
		return *m.GroupType
	}
	return Default_GroupDTO_GroupType
}

func (m *GroupDTO) GetIsConsistentResizing() bool {
	if m != nil && m.IsConsistentResizing != nil {
		return *m.IsConsistentResizing
	}
	return Default_GroupDTO_IsConsistentResizing
}

func (m *GroupDTO) GetTags() map[string]*GroupDTO_TagValues {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GroupDTO) GetOwner() string {
	if m != nil && m.Owner != nil {
		return *m.Owner
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GroupDTO) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GroupDTO_OneofMarshaler, _GroupDTO_OneofUnmarshaler, _GroupDTO_OneofSizer, []interface{}{
		(*GroupDTO_GroupName)(nil),
		(*GroupDTO_ConstraintInfo_)(nil),
		(*GroupDTO_SelectionSpecList_)(nil),
		(*GroupDTO_MemberList)(nil),
		(*GroupDTO_AddedAndRemovedMembers)(nil),
		(*GroupDTO_SourceGroupId)(nil),
	}
}

func _GroupDTO_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GroupDTO)
	// info
	switch x := m.Info.(type) {
	case *GroupDTO_GroupName:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.GroupName)
	case *GroupDTO_ConstraintInfo_:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConstraintInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GroupDTO.Info has unexpected type %T", x)
	}
	// members
	switch x := m.Members.(type) {
	case *GroupDTO_SelectionSpecList_:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SelectionSpecList); err != nil {
			return err
		}
	case *GroupDTO_MemberList:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MemberList); err != nil {
			return err
		}
	case *GroupDTO_AddedAndRemovedMembers:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddedAndRemovedMembers); err != nil {
			return err
		}
	case *GroupDTO_SourceGroupId:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.SourceGroupId)
	case nil:
	default:
		return fmt.Errorf("GroupDTO.Members has unexpected type %T", x)
	}
	return nil
}

func _GroupDTO_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GroupDTO)
	switch tag {
	case 3: // info.group_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Info = &GroupDTO_GroupName{x}
		return true, err
	case 4: // info.constraint_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GroupDTO_ConstraintInfo)
		err := b.DecodeMessage(msg)
		m.Info = &GroupDTO_ConstraintInfo_{msg}
		return true, err
	case 5: // members.selection_spec_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GroupDTO_SelectionSpecList)
		err := b.DecodeMessage(msg)
		m.Members = &GroupDTO_SelectionSpecList_{msg}
		return true, err
	case 6: // members.member_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GroupDTO_MembersList)
		err := b.DecodeMessage(msg)
		m.Members = &GroupDTO_MemberList{msg}
		return true, err
	case 7: // members.added_and_removed_members
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GroupDTO_AddedAndRemovedMembersList)
		err := b.DecodeMessage(msg)
		m.Members = &GroupDTO_AddedAndRemovedMembers{msg}
		return true, err
	case 8: // members.source_group_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Members = &GroupDTO_SourceGroupId{x}
		return true, err
	default:
		return false, nil
	}
}

func _GroupDTO_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GroupDTO)
	// info
	switch x := m.Info.(type) {
	case *GroupDTO_GroupName:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.GroupName)))
		n += len(x.GroupName)
	case *GroupDTO_ConstraintInfo_:
		s := proto.Size(x.ConstraintInfo)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// members
	switch x := m.Members.(type) {
	case *GroupDTO_SelectionSpecList_:
		s := proto.Size(x.SelectionSpecList)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GroupDTO_MemberList:
		s := proto.Size(x.MemberList)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GroupDTO_AddedAndRemovedMembers:
		s := proto.Size(x.AddedAndRemovedMembers)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GroupDTO_SourceGroupId:
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.SourceGroupId)))
		n += len(x.SourceGroupId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Tag values. Tag with certain name can has several values.
type GroupDTO_TagValues struct {
	Value            []string `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupDTO_TagValues) Reset()                    { *m = GroupDTO_TagValues{} }
func (m *GroupDTO_TagValues) String() string            { return proto.CompactTextString(m) }
func (*GroupDTO_TagValues) ProtoMessage()               {}
func (*GroupDTO_TagValues) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4, 0} }

func (m *GroupDTO_TagValues) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

// ConstraintInfo contains all necessary information specific for Group associated with Constraint
type GroupDTO_ConstraintInfo struct {
	// Constraint type associated with this group.
	// If it is just a group, then the constraint type should be Group
	ConstraintType *GroupDTO_ConstraintType `protobuf:"varint,1,req,name=constraint_type,json=constraintType,enum=common_dto.GroupDTO_ConstraintType" json:"constraint_type,omitempty"`
	// Constraint id to notify
	ConstraintId *string `protobuf:"bytes,2,req,name=constraint_id,json=constraintId" json:"constraint_id,omitempty"`
	// Notify if this group is for buyers
	IsBuyer *bool `protobuf:"varint,3,opt,name=is_buyer,json=isBuyer,def=0" json:"is_buyer,omitempty"`
	// Notify the type of the seller if it is the buyer group.
	BuyerMetaData *GroupDTO_BuyerMetaData `protobuf:"bytes,4,opt,name=buyer_meta_data,json=buyerMetaData" json:"buyer_meta_data,omitempty"`
	// Notify if this group is for creating complementary group
	NeedComplementary *bool `protobuf:"varint,5,opt,name=need_complementary,json=needComplementary,def=0" json:"need_complementary,omitempty"`
	// Name for the constraint
	ConstraintName *string `protobuf:"bytes,6,req,name=constraint_name,json=constraintName" json:"constraint_name,omitempty"`
	// Consumers that should not be included in the cluster.
	ForExcludedConsumers *bool `protobuf:"varint,7,opt,name=forExcludedConsumers,def=0" json:"forExcludedConsumers,omitempty"`
	// Display name for the constraint
	ConstraintDisplayName *string `protobuf:"bytes,8,opt,name=constraint_display_name,json=constraintDisplayName" json:"constraint_display_name,omitempty"`
	// Excluded Templates
	ExcludedTemplates []string `protobuf:"bytes,9,rep,name=excluded_templates,json=excludedTemplates" json:"excluded_templates,omitempty"`
	XXX_unrecognized  []byte   `json:"-"`
}

func (m *GroupDTO_ConstraintInfo) Reset()                    { *m = GroupDTO_ConstraintInfo{} }
func (m *GroupDTO_ConstraintInfo) String() string            { return proto.CompactTextString(m) }
func (*GroupDTO_ConstraintInfo) ProtoMessage()               {}
func (*GroupDTO_ConstraintInfo) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4, 2} }

const Default_GroupDTO_ConstraintInfo_IsBuyer bool = false
const Default_GroupDTO_ConstraintInfo_NeedComplementary bool = false
const Default_GroupDTO_ConstraintInfo_ForExcludedConsumers bool = false

func (m *GroupDTO_ConstraintInfo) GetConstraintType() GroupDTO_ConstraintType {
	if m != nil && m.ConstraintType != nil {
		return *m.ConstraintType
	}
	return GroupDTO_BUYER_SELLER_AFFINITY
}

func (m *GroupDTO_ConstraintInfo) GetConstraintId() string {
	if m != nil && m.ConstraintId != nil {
		return *m.ConstraintId
	}
	return ""
}

func (m *GroupDTO_ConstraintInfo) GetIsBuyer() bool {
	if m != nil && m.IsBuyer != nil {
		return *m.IsBuyer
	}
	return Default_GroupDTO_ConstraintInfo_IsBuyer
}

func (m *GroupDTO_ConstraintInfo) GetBuyerMetaData() *GroupDTO_BuyerMetaData {
	if m != nil {
		return m.BuyerMetaData
	}
	return nil
}

func (m *GroupDTO_ConstraintInfo) GetNeedComplementary() bool {
	if m != nil && m.NeedComplementary != nil {
		return *m.NeedComplementary
	}
	return Default_GroupDTO_ConstraintInfo_NeedComplementary
}

func (m *GroupDTO_ConstraintInfo) GetConstraintName() string {
	if m != nil && m.ConstraintName != nil {
		return *m.ConstraintName
	}
	return ""
}

func (m *GroupDTO_ConstraintInfo) GetForExcludedConsumers() bool {
	if m != nil && m.ForExcludedConsumers != nil {
		return *m.ForExcludedConsumers
	}
	return Default_GroupDTO_ConstraintInfo_ForExcludedConsumers
}

func (m *GroupDTO_ConstraintInfo) GetConstraintDisplayName() string {
	if m != nil && m.ConstraintDisplayName != nil {
		return *m.ConstraintDisplayName
	}
	return ""
}

func (m *GroupDTO_ConstraintInfo) GetExcludedTemplates() []string {
	if m != nil {
		return m.ExcludedTemplates
	}
	return nil
}

// List of SelectionSpec to select group members
type GroupDTO_SelectionSpecList struct {
	SelectionSpec    []*GroupDTO_SelectionSpec `protobuf:"bytes,1,rep,name=selection_spec,json=selectionSpec" json:"selection_spec,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *GroupDTO_SelectionSpecList) Reset()                    { *m = GroupDTO_SelectionSpecList{} }
func (m *GroupDTO_SelectionSpecList) String() string            { return proto.CompactTextString(m) }
func (*GroupDTO_SelectionSpecList) ProtoMessage()               {}
func (*GroupDTO_SelectionSpecList) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4, 3} }

func (m *GroupDTO_SelectionSpecList) GetSelectionSpec() []*GroupDTO_SelectionSpec {
	if m != nil {
		return m.SelectionSpec
	}
	return nil
}

// List of member uuids
type GroupDTO_MembersList struct {
	Member           []string `protobuf:"bytes,1,rep,name=member" json:"member,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupDTO_MembersList) Reset()                    { *m = GroupDTO_MembersList{} }
func (m *GroupDTO_MembersList) String() string            { return proto.CompactTextString(m) }
func (*GroupDTO_MembersList) ProtoMessage()               {}
func (*GroupDTO_MembersList) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4, 4} }

func (m *GroupDTO_MembersList) GetMember() []string {
	if m != nil {
		return m.Member
	}
	return nil
}

// List of members added and removed from the group.
type GroupDTO_AddedAndRemovedMembersList struct {
	AddedMembers     []string `protobuf:"bytes,1,rep,name=addedMembers" json:"addedMembers,omitempty"`
	RemovedMembers   []string `protobuf:"bytes,2,rep,name=removedMembers" json:"removedMembers,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupDTO_AddedAndRemovedMembersList) Reset()         { *m = GroupDTO_AddedAndRemovedMembersList{} }
func (m *GroupDTO_AddedAndRemovedMembersList) String() string { return proto.CompactTextString(m) }
func (*GroupDTO_AddedAndRemovedMembersList) ProtoMessage()    {}
func (*GroupDTO_AddedAndRemovedMembersList) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{4, 5}
}

func (m *GroupDTO_AddedAndRemovedMembersList) GetAddedMembers() []string {
	if m != nil {
		return m.AddedMembers
	}
	return nil
}

func (m *GroupDTO_AddedAndRemovedMembersList) GetRemovedMembers() []string {
	if m != nil {
		return m.RemovedMembers
	}
	return nil
}

type GroupDTO_BuyerMetaData struct {
	SellerType       *EntityDTO_EntityType `protobuf:"varint,1,opt,name=seller_type,json=sellerType,enum=common_dto.EntityDTO_EntityType" json:"seller_type,omitempty"`
	AtMost           *int32                `protobuf:"zigzag32,2,opt,name=at_most,json=atMost,def=-1" json:"at_most,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *GroupDTO_BuyerMetaData) Reset()                    { *m = GroupDTO_BuyerMetaData{} }
func (m *GroupDTO_BuyerMetaData) String() string            { return proto.CompactTextString(m) }
func (*GroupDTO_BuyerMetaData) ProtoMessage()               {}
func (*GroupDTO_BuyerMetaData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4, 6} }

const Default_GroupDTO_BuyerMetaData_AtMost int32 = -1

func (m *GroupDTO_BuyerMetaData) GetSellerType() EntityDTO_EntityType {
	if m != nil && m.SellerType != nil {
		return *m.SellerType
	}
	return EntityDTO_SWITCH
}

func (m *GroupDTO_BuyerMetaData) GetAtMost() int32 {
	if m != nil && m.AtMost != nil {
		return *m.AtMost
	}
	return Default_GroupDTO_BuyerMetaData_AtMost
}

// SelectionSpec is used to select group members by checking their property values
type GroupDTO_SelectionSpec struct {
	Property       *string                                `protobuf:"bytes,1,req,name=property" json:"property,omitempty"`
	ExpressionType *GroupDTO_SelectionSpec_ExpressionType `protobuf:"varint,2,req,name=expression_type,json=expressionType,enum=common_dto.GroupDTO_SelectionSpec_ExpressionType" json:"expression_type,omitempty"`
	// Types that are valid to be assigned to PropertyValue:
	//	*GroupDTO_SelectionSpec_PropertyValueDouble
	//	*GroupDTO_SelectionSpec_PropertyValueString
	//	*GroupDTO_SelectionSpec_PropertyValueStringList
	//	*GroupDTO_SelectionSpec_PropertyValueDoubleList
	PropertyValue    isGroupDTO_SelectionSpec_PropertyValue `protobuf_oneof:"propertyValue"`
	XXX_unrecognized []byte                                 `json:"-"`
}

func (m *GroupDTO_SelectionSpec) Reset()                    { *m = GroupDTO_SelectionSpec{} }
func (m *GroupDTO_SelectionSpec) String() string            { return proto.CompactTextString(m) }
func (*GroupDTO_SelectionSpec) ProtoMessage()               {}
func (*GroupDTO_SelectionSpec) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4, 7} }

type isGroupDTO_SelectionSpec_PropertyValue interface {
	isGroupDTO_SelectionSpec_PropertyValue()
}

type GroupDTO_SelectionSpec_PropertyValueDouble struct {
	PropertyValueDouble float64 `protobuf:"fixed64,3,opt,name=property_value_double,json=propertyValueDouble,oneof"`
}
type GroupDTO_SelectionSpec_PropertyValueString struct {
	PropertyValueString string `protobuf:"bytes,4,opt,name=property_value_string,json=propertyValueString,oneof"`
}
type GroupDTO_SelectionSpec_PropertyValueStringList struct {
	PropertyValueStringList *GroupDTO_SelectionSpec_PropertyStringList `protobuf:"bytes,5,opt,name=property_value_string_list,json=propertyValueStringList,oneof"`
}
type GroupDTO_SelectionSpec_PropertyValueDoubleList struct {
	PropertyValueDoubleList *GroupDTO_SelectionSpec_PropertyDoubleList `protobuf:"bytes,6,opt,name=property_value_double_list,json=propertyValueDoubleList,oneof"`
}

func (*GroupDTO_SelectionSpec_PropertyValueDouble) isGroupDTO_SelectionSpec_PropertyValue()     {}
func (*GroupDTO_SelectionSpec_PropertyValueString) isGroupDTO_SelectionSpec_PropertyValue()     {}
func (*GroupDTO_SelectionSpec_PropertyValueStringList) isGroupDTO_SelectionSpec_PropertyValue() {}
func (*GroupDTO_SelectionSpec_PropertyValueDoubleList) isGroupDTO_SelectionSpec_PropertyValue() {}

func (m *GroupDTO_SelectionSpec) GetPropertyValue() isGroupDTO_SelectionSpec_PropertyValue {
	if m != nil {
		return m.PropertyValue
	}
	return nil
}

func (m *GroupDTO_SelectionSpec) GetProperty() string {
	if m != nil && m.Property != nil {
		return *m.Property
	}
	return ""
}

func (m *GroupDTO_SelectionSpec) GetExpressionType() GroupDTO_SelectionSpec_ExpressionType {
	if m != nil && m.ExpressionType != nil {
		return *m.ExpressionType
	}
	return GroupDTO_SelectionSpec_EQUAL_TO
}

func (m *GroupDTO_SelectionSpec) GetPropertyValueDouble() float64 {
	if x, ok := m.GetPropertyValue().(*GroupDTO_SelectionSpec_PropertyValueDouble); ok {
		return x.PropertyValueDouble
	}
	return 0
}

func (m *GroupDTO_SelectionSpec) GetPropertyValueString() string {
	if x, ok := m.GetPropertyValue().(*GroupDTO_SelectionSpec_PropertyValueString); ok {
		return x.PropertyValueString
	}
	return ""
}

func (m *GroupDTO_SelectionSpec) GetPropertyValueStringList() *GroupDTO_SelectionSpec_PropertyStringList {
	if x, ok := m.GetPropertyValue().(*GroupDTO_SelectionSpec_PropertyValueStringList); ok {
		return x.PropertyValueStringList
	}
	return nil
}

func (m *GroupDTO_SelectionSpec) GetPropertyValueDoubleList() *GroupDTO_SelectionSpec_PropertyDoubleList {
	if x, ok := m.GetPropertyValue().(*GroupDTO_SelectionSpec_PropertyValueDoubleList); ok {
		return x.PropertyValueDoubleList
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GroupDTO_SelectionSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GroupDTO_SelectionSpec_OneofMarshaler, _GroupDTO_SelectionSpec_OneofUnmarshaler, _GroupDTO_SelectionSpec_OneofSizer, []interface{}{
		(*GroupDTO_SelectionSpec_PropertyValueDouble)(nil),
		(*GroupDTO_SelectionSpec_PropertyValueString)(nil),
		(*GroupDTO_SelectionSpec_PropertyValueStringList)(nil),
		(*GroupDTO_SelectionSpec_PropertyValueDoubleList)(nil),
	}
}

func _GroupDTO_SelectionSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GroupDTO_SelectionSpec)
	// propertyValue
	switch x := m.PropertyValue.(type) {
	case *GroupDTO_SelectionSpec_PropertyValueDouble:
		b.EncodeVarint(3<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.PropertyValueDouble))
	case *GroupDTO_SelectionSpec_PropertyValueString:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.PropertyValueString)
	case *GroupDTO_SelectionSpec_PropertyValueStringList:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PropertyValueStringList); err != nil {
			return err
		}
	case *GroupDTO_SelectionSpec_PropertyValueDoubleList:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PropertyValueDoubleList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GroupDTO_SelectionSpec.PropertyValue has unexpected type %T", x)
	}
	return nil
}

func _GroupDTO_SelectionSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GroupDTO_SelectionSpec)
	switch tag {
	case 3: // propertyValue.property_value_double
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.PropertyValue = &GroupDTO_SelectionSpec_PropertyValueDouble{math.Float64frombits(x)}
		return true, err
	case 4: // propertyValue.property_value_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PropertyValue = &GroupDTO_SelectionSpec_PropertyValueString{x}
		return true, err
	case 5: // propertyValue.property_value_string_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GroupDTO_SelectionSpec_PropertyStringList)
		err := b.DecodeMessage(msg)
		m.PropertyValue = &GroupDTO_SelectionSpec_PropertyValueStringList{msg}
		return true, err
	case 6: // propertyValue.property_value_double_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GroupDTO_SelectionSpec_PropertyDoubleList)
		err := b.DecodeMessage(msg)
		m.PropertyValue = &GroupDTO_SelectionSpec_PropertyValueDoubleList{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GroupDTO_SelectionSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GroupDTO_SelectionSpec)
	// propertyValue
	switch x := m.PropertyValue.(type) {
	case *GroupDTO_SelectionSpec_PropertyValueDouble:
		n += proto.SizeVarint(3<<3 | proto.WireFixed64)
		n += 8
	case *GroupDTO_SelectionSpec_PropertyValueString:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PropertyValueString)))
		n += len(x.PropertyValueString)
	case *GroupDTO_SelectionSpec_PropertyValueStringList:
		s := proto.Size(x.PropertyValueStringList)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GroupDTO_SelectionSpec_PropertyValueDoubleList:
		s := proto.Size(x.PropertyValueDoubleList)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// List of string type property value
type GroupDTO_SelectionSpec_PropertyStringList struct {
	PropertyValue    []string `protobuf:"bytes,1,rep,name=property_value,json=propertyValue" json:"property_value,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupDTO_SelectionSpec_PropertyStringList) Reset() {
	*m = GroupDTO_SelectionSpec_PropertyStringList{}
}
func (m *GroupDTO_SelectionSpec_PropertyStringList) String() string { return proto.CompactTextString(m) }
func (*GroupDTO_SelectionSpec_PropertyStringList) ProtoMessage()    {}
func (*GroupDTO_SelectionSpec_PropertyStringList) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{4, 7, 0}
}

func (m *GroupDTO_SelectionSpec_PropertyStringList) GetPropertyValue() []string {
	if m != nil {
		return m.PropertyValue
	}
	return nil
}

// List of double type property value
type GroupDTO_SelectionSpec_PropertyDoubleList struct {
	PropertyValue    []float64 `protobuf:"fixed64,1,rep,name=property_value,json=propertyValue" json:"property_value,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *GroupDTO_SelectionSpec_PropertyDoubleList) Reset() {
	*m = GroupDTO_SelectionSpec_PropertyDoubleList{}
}
func (m *GroupDTO_SelectionSpec_PropertyDoubleList) String() string { return proto.CompactTextString(m) }
func (*GroupDTO_SelectionSpec_PropertyDoubleList) ProtoMessage()    {}
func (*GroupDTO_SelectionSpec_PropertyDoubleList) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{4, 7, 1}
}

func (m *GroupDTO_SelectionSpec_PropertyDoubleList) GetPropertyValue() []float64 {
	if m != nil {
		return m.PropertyValue
	}
	return nil
}

// Context data.  This data may be related to action execution
// or this data may be used more generally.
type ContextData struct {
	ContextKey       *string `protobuf:"bytes,1,req,name=contextKey" json:"contextKey,omitempty"`
	ContextValue     *string `protobuf:"bytes,2,req,name=contextValue" json:"contextValue,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ContextData) Reset()                    { *m = ContextData{} }
func (m *ContextData) String() string            { return proto.CompactTextString(m) }
func (*ContextData) ProtoMessage()               {}
func (*ContextData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *ContextData) GetContextKey() string {
	if m != nil && m.ContextKey != nil {
		return *m.ContextKey
	}
	return ""
}

func (m *ContextData) GetContextValue() string {
	if m != nil && m.ContextValue != nil {
		return *m.ContextValue
	}
	return ""
}

// Notification on some event or condition.
type NotificationDTO struct {
	// Event name.
	Event *string `protobuf:"bytes,1,req,name=event" json:"event,omitempty"`
	// Notification category. For known notification categories use NotificationCategoryDTO enumeration.
	Category *string `protobuf:"bytes,2,req,name=category" json:"category,omitempty"`
	// Optional notification sub-category.
	SubCategory *string `protobuf:"bytes,3,opt,name=subCategory" json:"subCategory,omitempty"`
	// Optional notification description.
	Description *string `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	// Notification severity.
	Severity         *NotificationDTO_Severity `protobuf:"varint,5,opt,name=severity,enum=common_dto.NotificationDTO_Severity,def=0" json:"severity,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *NotificationDTO) Reset()                    { *m = NotificationDTO{} }
func (m *NotificationDTO) String() string            { return proto.CompactTextString(m) }
func (*NotificationDTO) ProtoMessage()               {}
func (*NotificationDTO) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

const Default_NotificationDTO_Severity NotificationDTO_Severity = NotificationDTO_UNKNOWN

func (m *NotificationDTO) GetEvent() string {
	if m != nil && m.Event != nil {
		return *m.Event
	}
	return ""
}

func (m *NotificationDTO) GetCategory() string {
	if m != nil && m.Category != nil {
		return *m.Category
	}
	return ""
}

func (m *NotificationDTO) GetSubCategory() string {
	if m != nil && m.SubCategory != nil {
		return *m.SubCategory
	}
	return ""
}

func (m *NotificationDTO) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *NotificationDTO) GetSeverity() NotificationDTO_Severity {
	if m != nil && m.Severity != nil {
		return *m.Severity
	}
	return Default_NotificationDTO_Severity
}

// Metadata for creating custom data objects in the Operations Manager
type CustomTypeDef struct {
	// Unique namespace for the data
	Namespace        *CustomTypeDef_MetadataNamespace `protobuf:"varint,1,req,name=namespace,enum=common_dto.CustomTypeDef_MetadataNamespace,def=0" json:"namespace,omitempty"`
	XXX_unrecognized []byte                           `json:"-"`
}

func (m *CustomTypeDef) Reset()                    { *m = CustomTypeDef{} }
func (m *CustomTypeDef) String() string            { return proto.CompactTextString(m) }
func (*CustomTypeDef) ProtoMessage()               {}
func (*CustomTypeDef) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7} }

const Default_CustomTypeDef_Namespace CustomTypeDef_MetadataNamespace = CustomTypeDef_UNKNOWN

func (m *CustomTypeDef) GetNamespace() CustomTypeDef_MetadataNamespace {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return Default_CustomTypeDef_Namespace
}

// The ServerEntityPropDef class provides metadata properties for entities
// in the Operations Manager topology that have not been discovered by this probe.
// Operations Manager uses these property values to stitch external entities to the
// entities discovered by the probe.
// An external entity is one that exists in the Operations Manager topology, but has
// not been discovered by the probe.
//
// The link definition identifies:
// * The entity type for this external entity
// * An attribute of the entity to use to identify it (for example a physical machine's IP address)
// * A flag to set whether to fetch the attribute from an entity that is related in the
//   Operations Manager topology (for example, use the IP address of a VM's host physical machine)
// * Optionally, a handler that can traverse the topology to find the identifying value
//
// This class includes a set of constants for properties that apply to some of the supported
// entity types. Use these constants to create external links with the most common entity
// types in the Operations Manager topology. You can also use this class to create
// custom external entity link definitions.
//
// EXAMPLE: Connecting a DiskArray to Storage. To connect storage objects to disk arrays that the probe discovers,
// the entity link can use either the LUN ID, WWN, or export path properties. This class includes
// the STORAGE_LUNID, STORAGE_WWN, and STORAGE_REMOTE_HOST constants.
// You can use one of these constants as the ExternalEntityLinkDef in the
// ExternalEntityLink that you create for the discovered disk array.
//
// EXAMPLE: Connecting an Application to a VM. To connect an application the probe discovers to a VM,
// you typically use the VM's IP address. You could also use the VM's unique ID. This class includes
// the VM_IP constant for VM IP addresses, and the VM_UUID constant for the VM unique ID.
// You can use one of these constants as the ExternalEntityLinkDef in the
// ExternalEntityLink that you create for the discovered VM.
type ServerEntityPropDef struct {
	Entity           *EntityDTO_EntityType `protobuf:"varint,1,req,name=entity,enum=common_dto.EntityDTO_EntityType" json:"entity,omitempty"`
	Attribute        *string               `protobuf:"bytes,2,req,name=attribute" json:"attribute,omitempty"`
	UseTopoExt       *bool                 `protobuf:"varint,3,opt,name=useTopoExt" json:"useTopoExt,omitempty"`
	PropertyHandler  *PropertyHandler      `protobuf:"bytes,4,opt,name=propertyHandler" json:"propertyHandler,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *ServerEntityPropDef) Reset()                    { *m = ServerEntityPropDef{} }
func (m *ServerEntityPropDef) String() string            { return proto.CompactTextString(m) }
func (*ServerEntityPropDef) ProtoMessage()               {}
func (*ServerEntityPropDef) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{8} }

func (m *ServerEntityPropDef) GetEntity() EntityDTO_EntityType {
	if m != nil && m.Entity != nil {
		return *m.Entity
	}
	return EntityDTO_SWITCH
}

func (m *ServerEntityPropDef) GetAttribute() string {
	if m != nil && m.Attribute != nil {
		return *m.Attribute
	}
	return ""
}

func (m *ServerEntityPropDef) GetUseTopoExt() bool {
	if m != nil && m.UseTopoExt != nil {
		return *m.UseTopoExt
	}
	return false
}

func (m *ServerEntityPropDef) GetPropertyHandler() *PropertyHandler {
	if m != nil {
		return m.PropertyHandler
	}
	return nil
}

// The PropertyHandler class manages handler methods that
// Operations Manager can use to traverse the topology to get value(s) of the specified attribute.
// The class assembles a linked list of handlers that can be used to inspect multiple
// layers of the topology to get properties from different entity types.
// Forms LinkedList structure to maintain multiple layers of property names and entity types.
// Example:
// PropertyHandler ipHandler {
//                nextHandler: null
//                methodName: "getAddress"
//                entity: Entity.IP
//                directlyApply: false
//                }</pre></code>
// ipHandler can be used to retrieve IP address string values from IP object.
type PropertyHandler struct {
	MethodName *string               `protobuf:"bytes,1,req,name=methodName" json:"methodName,omitempty"`
	EntityType *EntityDTO_EntityType `protobuf:"varint,2,opt,name=entityType,enum=common_dto.EntityDTO_EntityType" json:"entityType,omitempty"`
	// it notifies if the method can be directly applied to what returned from the previous layer
	// For example, if it's for IP from VM.getUsesEndPoints(), then directlyApply should be false.
	// Since what returned from VM.getUsesEndPoints() is a list of IPs. So should go to each
	// instance and apply that method.
	DirectlyApply    *bool            `protobuf:"varint,3,opt,name=directlyApply" json:"directlyApply,omitempty"`
	NextHandler      *PropertyHandler `protobuf:"bytes,4,opt,name=next_handler,json=nextHandler" json:"next_handler,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *PropertyHandler) Reset()                    { *m = PropertyHandler{} }
func (m *PropertyHandler) String() string            { return proto.CompactTextString(m) }
func (*PropertyHandler) ProtoMessage()               {}
func (*PropertyHandler) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{9} }

func (m *PropertyHandler) GetMethodName() string {
	if m != nil && m.MethodName != nil {
		return *m.MethodName
	}
	return ""
}

func (m *PropertyHandler) GetEntityType() EntityDTO_EntityType {
	if m != nil && m.EntityType != nil {
		return *m.EntityType
	}
	return EntityDTO_SWITCH
}

func (m *PropertyHandler) GetDirectlyApply() bool {
	if m != nil && m.DirectlyApply != nil {
		return *m.DirectlyApply
	}
	return false
}

func (m *PropertyHandler) GetNextHandler() *PropertyHandler {
	if m != nil {
		return m.NextHandler
	}
	return nil
}

// This message is mainly used to identify an entity such as VM, via the fields ipAddress,
// port (we can add more identifiers later).
type EntityIdentityData struct {
	// The target entity's IP address.
	IpAddress *string `protobuf:"bytes,1,req,name=ipAddress" json:"ipAddress,omitempty"`
	// The target entity's port number.
	Port             *int32 `protobuf:"varint,2,req,name=port" json:"port,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityIdentityData) Reset()                    { *m = EntityIdentityData{} }
func (m *EntityIdentityData) String() string            { return proto.CompactTextString(m) }
func (*EntityIdentityData) ProtoMessage()               {}
func (*EntityIdentityData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{10} }

func (m *EntityIdentityData) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *EntityIdentityData) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

// The Flow DTO. This data is used for describing the communication between two entities
// (VMs in NCM). It includes the source, destination entity identity data and flow data
// (protocol, flow amount, latency).
type FlowDTO struct {
	// Source entity identity data
	SourceEntityIdentityData *EntityIdentityData `protobuf:"bytes,1,req,name=sourceEntityIdentityData" json:"sourceEntityIdentityData,omitempty"`
	// Destination entity identity data
	DestEntityIdentityData *EntityIdentityData `protobuf:"bytes,2,req,name=destEntityIdentityData" json:"destEntityIdentityData,omitempty"`
	// The protocol.
	Protocol *FlowDTO_Protocol `protobuf:"varint,3,req,name=protocol,enum=common_dto.FlowDTO_Protocol" json:"protocol,omitempty"`
	// Flow Amount
	FlowAmount *float64 `protobuf:"fixed64,4,req,name=flowAmount" json:"flowAmount,omitempty"`
	// Flow latency
	Latency *int64 `protobuf:"varint,5,req,name=latency" json:"latency,omitempty"`
	// Transmitted amount
	TransmittedAmount *int64 `protobuf:"varint,6,req,name=transmittedAmount" json:"transmittedAmount,omitempty"`
	// Received amount
	ReceivedAmount   *int64 `protobuf:"varint,7,req,name=receivedAmount" json:"receivedAmount,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *FlowDTO) Reset()                    { *m = FlowDTO{} }
func (m *FlowDTO) String() string            { return proto.CompactTextString(m) }
func (*FlowDTO) ProtoMessage()               {}
func (*FlowDTO) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{11} }

func (m *FlowDTO) GetSourceEntityIdentityData() *EntityIdentityData {
	if m != nil {
		return m.SourceEntityIdentityData
	}
	return nil
}

func (m *FlowDTO) GetDestEntityIdentityData() *EntityIdentityData {
	if m != nil {
		return m.DestEntityIdentityData
	}
	return nil
}

func (m *FlowDTO) GetProtocol() FlowDTO_Protocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return FlowDTO_TCP
}

func (m *FlowDTO) GetFlowAmount() float64 {
	if m != nil && m.FlowAmount != nil {
		return *m.FlowAmount
	}
	return 0
}

func (m *FlowDTO) GetLatency() int64 {
	if m != nil && m.Latency != nil {
		return *m.Latency
	}
	return 0
}

func (m *FlowDTO) GetTransmittedAmount() int64 {
	if m != nil && m.TransmittedAmount != nil {
		return *m.TransmittedAmount
	}
	return 0
}

func (m *FlowDTO) GetReceivedAmount() int64 {
	if m != nil && m.ReceivedAmount != nil {
		return *m.ReceivedAmount
	}
	return 0
}

// geo data location with latitude and longitude to determine physical location of entity
type GeoData struct {
	// the latitude of the entity used along with longitude to determine physical location
	Latitude *float64 `protobuf:"fixed64,1,req,name=latitude" json:"latitude,omitempty"`
	// the longitude of the entity used along with latitude to determine physical location
	Longitude        *float64 `protobuf:"fixed64,2,req,name=longitude" json:"longitude,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GeoData) Reset()                    { *m = GeoData{} }
func (m *GeoData) String() string            { return proto.CompactTextString(m) }
func (*GeoData) ProtoMessage()               {}
func (*GeoData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{12} }

func (m *GeoData) GetLatitude() float64 {
	if m != nil && m.Latitude != nil {
		return *m.Latitude
	}
	return 0
}

func (m *GeoData) GetLongitude() float64 {
	if m != nil && m.Longitude != nil {
		return *m.Longitude
	}
	return 0
}

func init() {
	proto.RegisterType((*EntityDTO)(nil), "common_dto.EntityDTO")
	proto.RegisterType((*EntityDTO_CommodityBought)(nil), "common_dto.EntityDTO.CommodityBought")
	proto.RegisterType((*EntityDTO_ActionEligibility)(nil), "common_dto.EntityDTO.ActionEligibility")
	proto.RegisterType((*EntityDTO_ActionOnProviderEligibility)(nil), "common_dto.EntityDTO.ActionOnProviderEligibility")
	proto.RegisterType((*EntityDTO_SubDivisionData)(nil), "common_dto.EntityDTO.SubDivisionData")
	proto.RegisterType((*EntityDTO_StorageData)(nil), "common_dto.EntityDTO.StorageData")
	proto.RegisterType((*EntityDTO_StorageData_StorageFileDescriptor)(nil), "common_dto.EntityDTO.StorageData.StorageFileDescriptor")
	proto.RegisterType((*EntityDTO_StorageData_StoragePolicy)(nil), "common_dto.EntityDTO.StorageData.StoragePolicy")
	proto.RegisterType((*EntityDTO_StorageData_RawCapacity)(nil), "common_dto.EntityDTO.StorageData.RawCapacity")
	proto.RegisterType((*EntityDTO_BusinessUserData)(nil), "common_dto.EntityDTO.BusinessUserData")
	proto.RegisterType((*EntityDTO_RegionData)(nil), "common_dto.EntityDTO.RegionData")
	proto.RegisterType((*EntityDTO_SessionData)(nil), "common_dto.EntityDTO.SessionData")
	proto.RegisterType((*EntityDTO_DiskArrayData)(nil), "common_dto.EntityDTO.DiskArrayData")
	proto.RegisterType((*EntityDTO_LogicalPoolData)(nil), "common_dto.EntityDTO.LogicalPoolData")
	proto.RegisterType((*EntityDTO_ApplicationData)(nil), "common_dto.EntityDTO.ApplicationData")
	proto.RegisterType((*EntityDTO_VirtualApplicationData)(nil), "common_dto.EntityDTO.VirtualApplicationData")
	proto.RegisterType((*EntityDTO_BusinessAccountData)(nil), "common_dto.EntityDTO.BusinessAccountData")
	proto.RegisterType((*EntityDTO_ComputeTierData)(nil), "common_dto.EntityDTO.ComputeTierData")
	proto.RegisterType((*EntityDTO_VirtualVolumeData)(nil), "common_dto.EntityDTO.VirtualVolumeData")
	proto.RegisterType((*EntityDTO_VirtualVolumeData_VirtualVolumeFileDescriptor)(nil), "common_dto.EntityDTO.VirtualVolumeData.VirtualVolumeFileDescriptor")
	proto.RegisterType((*EntityDTO_VirtualMachineData)(nil), "common_dto.EntityDTO.VirtualMachineData")
	proto.RegisterType((*EntityDTO_VirtualMachineData_AnnotationNote)(nil), "common_dto.EntityDTO.VirtualMachineData.AnnotationNote")
	proto.RegisterType((*EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor)(nil), "common_dto.EntityDTO.VirtualMachineData.VirtualMachineFileDescriptor")
	proto.RegisterType((*EntityDTO_DatabaseData)(nil), "common_dto.EntityDTO.DatabaseData")
	proto.RegisterType((*EntityDTO_StorageControllerData)(nil), "common_dto.EntityDTO.StorageControllerData")
	proto.RegisterType((*EntityDTO_ContainerPodData)(nil), "common_dto.EntityDTO.ContainerPodData")
	proto.RegisterType((*EntityDTO_ContainerData)(nil), "common_dto.EntityDTO.ContainerData")
	proto.RegisterType((*EntityDTO_VMState)(nil), "common_dto.EntityDTO.VMState")
	proto.RegisterType((*EntityDTO_PhysicalMachineData)(nil), "common_dto.EntityDTO.PhysicalMachineData")
	proto.RegisterType((*EntityDTO_PMState)(nil), "common_dto.EntityDTO.PMState")
	proto.RegisterType((*EntityDTO_VirtualDatacenterTypeProps)(nil), "common_dto.EntityDTO.VirtualDatacenterTypeProps")
	proto.RegisterType((*EntityDTO_VirtualDatacenterData)(nil), "common_dto.EntityDTO.VirtualDatacenterData")
	proto.RegisterType((*EntityDTO_DesktopPoolData)(nil), "common_dto.EntityDTO.DesktopPoolData")
	proto.RegisterType((*EntityDTO_EntityProperty)(nil), "common_dto.EntityDTO.EntityProperty")
	proto.RegisterType((*EntityDTO_VirtualMachineRelatedData)(nil), "common_dto.EntityDTO.VirtualMachineRelatedData")
	proto.RegisterType((*EntityDTO_PhysicalMachineRelatedData)(nil), "common_dto.EntityDTO.PhysicalMachineRelatedData")
	proto.RegisterType((*EntityDTO_StorageControllerRelatedData)(nil), "common_dto.EntityDTO.StorageControllerRelatedData")
	proto.RegisterType((*EntityDTO_MemoryData)(nil), "common_dto.EntityDTO.MemoryData")
	proto.RegisterType((*EntityDTO_ProcessorData)(nil), "common_dto.EntityDTO.ProcessorData")
	proto.RegisterType((*EntityDTO_IoData)(nil), "common_dto.EntityDTO.IoData")
	proto.RegisterType((*EntityDTO_DiskGroupData)(nil), "common_dto.EntityDTO.DiskGroupData")
	proto.RegisterType((*EntityDTO_DiskData)(nil), "common_dto.EntityDTO.DiskData")
	proto.RegisterType((*EntityDTO_ComputeIopsData)(nil), "common_dto.EntityDTO.ComputeIopsData")
	proto.RegisterType((*EntityDTO_IopsItemData)(nil), "common_dto.EntityDTO.IopsItemData")
	proto.RegisterType((*EntityDTO_ReplacementEntityMetaData)(nil), "common_dto.EntityDTO.ReplacementEntityMetaData")
	proto.RegisterType((*EntityDTO_FieldReplacement)(nil), "common_dto.EntityDTO.FieldReplacement")
	proto.RegisterType((*EntityDTO_FieldReplacement_FieldPath)(nil), "common_dto.EntityDTO.FieldReplacement.FieldPath")
	proto.RegisterType((*EntityDTO_ReplacementCommodityPropertyData)(nil), "common_dto.EntityDTO.ReplacementCommodityPropertyData")
	proto.RegisterType((*EntityDTO_ConsumerPolicy)(nil), "common_dto.EntityDTO.ConsumerPolicy")
	proto.RegisterType((*EntityDTO_ProviderPolicy)(nil), "common_dto.EntityDTO.ProviderPolicy")
	proto.RegisterType((*EntityDTO_ProcessorPoolData)(nil), "common_dto.EntityDTO.ProcessorPoolData")
	proto.RegisterType((*EntityDTO_ReservedInstanceData)(nil), "common_dto.EntityDTO.ReservedInstanceData")
	proto.RegisterType((*PricingIdentifier)(nil), "common_dto.PricingIdentifier")
	proto.RegisterType((*CommodityDTO)(nil), "common_dto.CommodityDTO")
	proto.RegisterType((*CommodityDTO_RatioDependency)(nil), "common_dto.CommodityDTO.RatioDependency")
	proto.RegisterType((*CommodityDTO_PropertiesList)(nil), "common_dto.CommodityDTO.PropertiesList")
	proto.RegisterType((*CommodityDTO_StorageLatencyData)(nil), "common_dto.CommodityDTO.StorageLatencyData")
	proto.RegisterType((*CommodityDTO_StorageAccessData)(nil), "common_dto.CommodityDTO.StorageAccessData")
	proto.RegisterType((*CommodityDTO_StorageProvisionedData)(nil), "common_dto.CommodityDTO.StorageProvisionedData")
	proto.RegisterType((*CommodityDTO_VMemData)(nil), "common_dto.CommodityDTO.VMemData")
	proto.RegisterType((*CommodityDTO_VCpuData)(nil), "common_dto.CommodityDTO.VCpuData")
	proto.RegisterType((*CommodityDTO_PricingMetadata)(nil), "common_dto.CommodityDTO.PricingMetadata")
	proto.RegisterType((*CommodityDTO_UtilizationData)(nil), "common_dto.CommodityDTO.UtilizationData")
	proto.RegisterType((*VStoragePartitionData)(nil), "common_dto.VStoragePartitionData")
	proto.RegisterType((*GroupDTO)(nil), "common_dto.GroupDTO")
	proto.RegisterType((*GroupDTO_TagValues)(nil), "common_dto.GroupDTO.TagValues")
	proto.RegisterType((*GroupDTO_ConstraintInfo)(nil), "common_dto.GroupDTO.ConstraintInfo")
	proto.RegisterType((*GroupDTO_SelectionSpecList)(nil), "common_dto.GroupDTO.SelectionSpecList")
	proto.RegisterType((*GroupDTO_MembersList)(nil), "common_dto.GroupDTO.MembersList")
	proto.RegisterType((*GroupDTO_AddedAndRemovedMembersList)(nil), "common_dto.GroupDTO.AddedAndRemovedMembersList")
	proto.RegisterType((*GroupDTO_BuyerMetaData)(nil), "common_dto.GroupDTO.BuyerMetaData")
	proto.RegisterType((*GroupDTO_SelectionSpec)(nil), "common_dto.GroupDTO.SelectionSpec")
	proto.RegisterType((*GroupDTO_SelectionSpec_PropertyStringList)(nil), "common_dto.GroupDTO.SelectionSpec.PropertyStringList")
	proto.RegisterType((*GroupDTO_SelectionSpec_PropertyDoubleList)(nil), "common_dto.GroupDTO.SelectionSpec.PropertyDoubleList")
	proto.RegisterType((*ContextData)(nil), "common_dto.ContextData")
	proto.RegisterType((*NotificationDTO)(nil), "common_dto.NotificationDTO")
	proto.RegisterType((*CustomTypeDef)(nil), "common_dto.CustomTypeDef")
	proto.RegisterType((*ServerEntityPropDef)(nil), "common_dto.ServerEntityPropDef")
	proto.RegisterType((*PropertyHandler)(nil), "common_dto.PropertyHandler")
	proto.RegisterType((*EntityIdentityData)(nil), "common_dto.EntityIdentityData")
	proto.RegisterType((*FlowDTO)(nil), "common_dto.FlowDTO")
	proto.RegisterType((*GeoData)(nil), "common_dto.GeoData")
	proto.RegisterEnum("common_dto.UpdateType", UpdateType_name, UpdateType_value)
	proto.RegisterEnum("common_dto.EntityDTO_EntityType", EntityDTO_EntityType_name, EntityDTO_EntityType_value)
	proto.RegisterEnum("common_dto.EntityDTO_PowerState", EntityDTO_PowerState_name, EntityDTO_PowerState_value)
	proto.RegisterEnum("common_dto.EntityDTO_StorageRedundancyMethod", EntityDTO_StorageRedundancyMethod_name, EntityDTO_StorageRedundancyMethod_value)
	proto.RegisterEnum("common_dto.EntityDTO_StorageType", EntityDTO_StorageType_name, EntityDTO_StorageType_value)
	proto.RegisterEnum("common_dto.EntityDTO_VirtualMachineFileType", EntityDTO_VirtualMachineFileType_name, EntityDTO_VirtualMachineFileType_value)
	proto.RegisterEnum("common_dto.EntityDTO_InstanceDiskType", EntityDTO_InstanceDiskType_name, EntityDTO_InstanceDiskType_value)
	proto.RegisterEnum("common_dto.EntityDTO_LicenseModel", EntityDTO_LicenseModel_name, EntityDTO_LicenseModel_value)
	proto.RegisterEnum("common_dto.EntityDTO_VirtualDatacenterRole", EntityDTO_VirtualDatacenterRole_name, EntityDTO_VirtualDatacenterRole_value)
	proto.RegisterEnum("common_dto.EntityDTO_VirtualDatacenterAllocationModel", EntityDTO_VirtualDatacenterAllocationModel_name, EntityDTO_VirtualDatacenterAllocationModel_value)
	proto.RegisterEnum("common_dto.EntityDTO_DiskRole", EntityDTO_DiskRole_name, EntityDTO_DiskRole_value)
	proto.RegisterEnum("common_dto.EntityDTO_IopsItemNames", EntityDTO_IopsItemNames_name, EntityDTO_IopsItemNames_value)
	proto.RegisterEnum("common_dto.EntityDTO_EntityOrigin", EntityDTO_EntityOrigin_name, EntityDTO_EntityOrigin_value)
	proto.RegisterEnum("common_dto.EntityDTO_ComputeTierData_DedicatedStorageNetworkState", EntityDTO_ComputeTierData_DedicatedStorageNetworkState_name, EntityDTO_ComputeTierData_DedicatedStorageNetworkState_value)
	proto.RegisterEnum("common_dto.EntityDTO_VirtualVolumeData_AttachmentState", EntityDTO_VirtualVolumeData_AttachmentState_name, EntityDTO_VirtualVolumeData_AttachmentState_value)
	proto.RegisterEnum("common_dto.EntityDTO_VirtualVolumeData_RedundancyType", EntityDTO_VirtualVolumeData_RedundancyType_name, EntityDTO_VirtualVolumeData_RedundancyType_value)
	proto.RegisterEnum("common_dto.EntityDTO_VirtualMachineData_VMBillingType", EntityDTO_VirtualMachineData_VMBillingType_name, EntityDTO_VirtualMachineData_VMBillingType_value)
	proto.RegisterEnum("common_dto.EntityDTO_DesktopPoolData_DesktopPoolProvisionType", EntityDTO_DesktopPoolData_DesktopPoolProvisionType_name, EntityDTO_DesktopPoolData_DesktopPoolProvisionType_value)
	proto.RegisterEnum("common_dto.EntityDTO_DesktopPoolData_DesktopPoolCloneType", EntityDTO_DesktopPoolData_DesktopPoolCloneType_name, EntityDTO_DesktopPoolData_DesktopPoolCloneType_value)
	proto.RegisterEnum("common_dto.EntityDTO_DesktopPoolData_DesktopPoolAssignmentType", EntityDTO_DesktopPoolData_DesktopPoolAssignmentType_name, EntityDTO_DesktopPoolData_DesktopPoolAssignmentType_value)
	proto.RegisterEnum("common_dto.EntityDTO_ReservedInstanceData_InstanceTenancy", EntityDTO_ReservedInstanceData_InstanceTenancy_name, EntityDTO_ReservedInstanceData_InstanceTenancy_value)
	proto.RegisterEnum("common_dto.EntityDTO_ReservedInstanceData_OfferingClass", EntityDTO_ReservedInstanceData_OfferingClass_name, EntityDTO_ReservedInstanceData_OfferingClass_value)
	proto.RegisterEnum("common_dto.EntityDTO_ReservedInstanceData_OfferingType", EntityDTO_ReservedInstanceData_OfferingType_name, EntityDTO_ReservedInstanceData_OfferingType_value)
	proto.RegisterEnum("common_dto.EntityDTO_ReservedInstanceData_Platform", EntityDTO_ReservedInstanceData_Platform_name, EntityDTO_ReservedInstanceData_Platform_value)
	proto.RegisterEnum("common_dto.PricingIdentifier_PricingIdentifierName", PricingIdentifier_PricingIdentifierName_name, PricingIdentifier_PricingIdentifierName_value)
	proto.RegisterEnum("common_dto.CommodityDTO_CommodityType", CommodityDTO_CommodityType_name, CommodityDTO_CommodityType_value)
	proto.RegisterEnum("common_dto.GroupDTO_GroupType", GroupDTO_GroupType_name, GroupDTO_GroupType_value)
	proto.RegisterEnum("common_dto.GroupDTO_ConstraintType", GroupDTO_ConstraintType_name, GroupDTO_ConstraintType_value)
	proto.RegisterEnum("common_dto.GroupDTO_SelectionSpec_ExpressionType", GroupDTO_SelectionSpec_ExpressionType_name, GroupDTO_SelectionSpec_ExpressionType_value)
	proto.RegisterEnum("common_dto.NotificationDTO_Severity", NotificationDTO_Severity_name, NotificationDTO_Severity_value)
	proto.RegisterEnum("common_dto.CustomTypeDef_MetadataNamespace", CustomTypeDef_MetadataNamespace_name, CustomTypeDef_MetadataNamespace_value)
	proto.RegisterEnum("common_dto.FlowDTO_Protocol", FlowDTO_Protocol_name, FlowDTO_Protocol_value)
}

func init() { proto.RegisterFile("CommonDTO.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 9921 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0xbd, 0x5d, 0x8c, 0x24, 0xc7,
	0x96, 0x10, 0x3c, 0x55, 0xfd, 0x7f, 0xfa, 0x2f, 0x3b, 0xa6, 0xa7, 0xa7, 0xa6, 0x66, 0x6c, 0x8f,
	0xcb, 0xbe, 0xf6, 0x5c, 0x5f, 0x7b, 0x3c, 0x1e, 0xdb, 0xe3, 0xf1, 0x5c, 0xef, 0xbd, 0xce, 0xae,
	0xca, 0xee, 0xce, 0x3b, 0x55, 0x99, 0xe5, 0xc8, 0xac, 0x9e, 0x9f, 0xdd, 0xbb, 0x79, 0xb3, 0x2b,
	0xa3, 0xbb, 0x73, 0xa7, 0xaa, 0xb2, 0xbe, 0xcc, 0xac, 0xf6, 0xb4, 0xf7, 0x03, 0x2d, 0x2c, 0x2b,
	0x04, 0x6f, 0x48, 0x20, 0x21, 0x56, 0x2b, 0x90, 0x10, 0xfb, 0xb0, 0x0f, 0x3c, 0x81, 0x04, 0x0f,
	0x08, 0xf1, 0xb2, 0xc0, 0xf3, 0x82, 0x10, 0x48, 0x08, 0x5e, 0x90, 0x96, 0x45, 0x8b, 0x04, 0xe2,
	0x7f, 0x17, 0x16, 0x9d, 0x88, 0xc8, 0xac, 0xcc, 0xac, 0xaa, 0x9e, 0xf6, 0xbd, 0x2b, 0x10, 0x2f,
	0xad, 0x8a, 0x13, 0xe7, 0x9c, 0x88, 0x38, 0x19, 0x71, 0xe2, 0x9c, 0x13, 0x27, 0xa2, 0x61, 0xb3,
	0x1e, 0xf4, 0xfb, 0xc1, 0xa0, 0x61, 0x9b, 0x77, 0x87, 0x61, 0x10, 0x07, 0x04, 0xba, 0x1c, 0xe0,
	0x78, 0x71, 0x50, 0xfb, 0xcd, 0xbf, 0x50, 0x82, 0x15, 0x6d, 0x10, 0xfb, 0xf1, 0x79, 0xc3, 0x36,
	0xc9, 0x97, 0x00, 0x8c, 0x17, 0xec, 0xf3, 0x21, 0xab, 0x94, 0x6e, 0x97, 0xef, 0x6c, 0xdc, 0xbf,
	0x7d, 0x77, 0x8c, 0x7f, 0x37, 0x45, 0x95, 0xbf, 0x10, 0x8f, 0x66, 0x68, 0xc8, 0x06, 0x94, 0x7d,
	0xaf, 0x52, 0xbe, 0x5d, 0xbe, 0xb3, 0x42, 0xcb, 0xbe, 0x47, 0x6e, 0xc3, 0xaa, 0xe7, 0x47, 0xc3,
	0x9e, 0x7b, 0x6e, 0xb8, 0x7d, 0x56, 0x99, 0xbb, 0x5d, 0xba, 0xb3, 0x42, 0xb3, 0x20, 0xb2, 0x0b,
	0x9b, 0xbc, 0x01, 0xcf, 0x8f, 0x7d, 0x16, 0x59, 0x41, 0xcf, 0xab, 0xcc, 0xdf, 0x9e, 0xbb, 0xb3,
	0x7a, 0xbf, 0x92, 0x6d, 0xb8, 0x2e, 0x51, 0xb0, 0x6d, 0x5a, 0x24, 0x20, 0x16, 0x6c, 0x65, 0x40,
	0xbb, 0xc1, 0xe8, 0xe4, 0x34, 0xae, 0x2c, 0x70, 0x2e, 0xdf, 0x99, 0xde, 0xfd, 0x94, 0x9f, 0x40,
	0xa6, 0x93, 0xf4, 0xa4, 0x06, 0x30, 0x1a, 0x78, 0x2c, 0xec, 0x9d, 0xfb, 0x83, 0x93, 0xca, 0xe2,
	0xed, 0xb9, 0x3b, 0x2b, 0xbb, 0xe5, 0x4a, 0x89, 0x66, 0xa0, 0xa4, 0x0d, 0x8a, 0x18, 0x7c, 0x3b,
	0x0c, 0x86, 0x2c, 0x44, 0xea, 0xca, 0x12, 0x6f, 0xf7, 0xed, 0x8b, 0xc4, 0x26, 0xb1, 0xcf, 0xe9,
	0x04, 0x35, 0xd9, 0x83, 0xc5, 0x20, 0xf4, 0x4f, 0xfc, 0x41, 0x65, 0xf9, 0x76, 0xe9, 0xce, 0xc6,
	0xfd, 0xda, 0x45, 0x7c, 0x4c, 0x8e, 0xf9, 0x08, 0x1a, 0xba, 0x55, 0x37, 0x0f, 0x35, 0xaa, 0x35,
	0xa8, 0xa4, 0x26, 0x0c, 0xae, 0x85, 0x6c, 0xd8, 0x73, 0xbb, 0xac, 0xcf, 0x06, 0xb1, 0x24, 0x74,
	0x63, 0xb7, 0xb2, 0x72, 0xbb, 0x74, 0x67, 0xf5, 0xfe, 0x87, 0xd3, 0xd9, 0xd2, 0x22, 0x49, 0x8b,
	0xc5, 0x2e, 0x92, 0xd1, 0xe9, 0xdc, 0x48, 0x0d, 0x56, 0xfa, 0xc1, 0xc0, 0x8f, 0x83, 0x90, 0x79,
	0x15, 0xb8, 0x5d, 0xba, 0xb3, 0xfc, 0x68, 0x3e, 0x0e, 0x47, 0x8c, 0x8e, 0xc1, 0xa4, 0x09, 0x30,
	0x0c, 0xbe, 0x66, 0xa1, 0x15, 0xbb, 0x31, 0xab, 0xac, 0xf2, 0x61, 0xcd, 0x98, 0x55, 0xed, 0x14,
	0xef, 0x11, 0xb4, 0xcd, 0x27, 0x38, 0x22, 0xc7, 0x34, 0x68, 0x86, 0x9e, 0x34, 0x61, 0xa3, 0x1b,
	0x0c, 0xa2, 0x51, 0x9f, 0x85, 0xed, 0xa0, 0xe7, 0x77, 0xcf, 0x2b, 0x6b, 0x7c, 0x44, 0x6f, 0xcf,
	0xfa, 0xd0, 0x59, 0x5c, 0x5a, 0xa0, 0x45, 0x6e, 0xc3, 0x30, 0x38, 0xf3, 0xbd, 0x94, 0xdb, 0xfa,
	0x45, 0xdc, 0xda, 0x39, 0x5c, 0x5a, 0xa0, 0x25, 0x15, 0x58, 0x0a, 0xbe, 0x1e, 0x30, 0x6f, 0xf7,
	0xbc, 0xb2, 0xc1, 0x67, 0x7a, 0x52, 0x24, 0x3f, 0x84, 0xb5, 0x41, 0x10, 0xfb, 0xc7, 0x7e, 0xd7,
	0x8d, 0xfd, 0x60, 0x50, 0xd9, 0xe4, 0x93, 0xe4, 0x66, 0xb6, 0x15, 0x23, 0x53, 0x8f, 0xb3, 0x3c,
	0x47, 0x40, 0xde, 0x87, 0x8d, 0x17, 0x8c, 0x0d, 0xad, 0xd8, 0x1d, 0x78, 0x6e, 0x2f, 0x18, 0xb0,
	0x8a, 0x92, 0x91, 0x76, 0xa1, 0x8e, 0xdc, 0x82, 0x95, 0x61, 0x18, 0x1c, 0xfb, 0x3d, 0xa6, 0x7b,
	0x95, 0x2d, 0xde, 0x95, 0x31, 0x80, 0xfc, 0x10, 0x60, 0x34, 0xf4, 0xdc, 0x98, 0xf1, 0x65, 0x4e,
	0xf8, 0x07, 0xd9, 0xc9, 0x76, 0xa5, 0x93, 0xd6, 0x3e, 0x5a, 0xea, 0xb4, 0x1b, 0xaa, 0xad, 0x35,
	0x68, 0x86, 0x04, 0x57, 0x75, 0xcf, 0x3d, 0x67, 0x21, 0xf3, 0xcc, 0x33, 0x16, 0x56, 0xae, 0xe2,
	0xda, 0xa0, 0x59, 0x10, 0x79, 0x0f, 0x14, 0x39, 0x61, 0x22, 0x21, 0x3d, 0xdd, 0xab, 0x6c, 0x73,
	0xb4, 0x09, 0x38, 0x79, 0x17, 0x56, 0xfb, 0xae, 0x3f, 0x88, 0xd9, 0xc0, 0x1d, 0x74, 0x59, 0xe5,
	0x1a, 0x1f, 0xd7, 0xc2, 0xb1, 0xdb, 0x8b, 0x18, 0xcd, 0xd6, 0x90, 0xd7, 0x01, 0xf0, 0xf3, 0xf9,
	0x51, 0x1c, 0x99, 0xc7, 0x95, 0x1d, 0xce, 0x2e, 0x03, 0x21, 0x1d, 0xd8, 0x72, 0xbb, 0x28, 0x2d,
	0xad, 0xe7, 0x9f, 0xf8, 0x47, 0x7e, 0xcf, 0x8f, 0xcf, 0x2b, 0xd7, 0xf9, 0xf7, 0x7c, 0x77, 0xfa,
	0xf7, 0x54, 0x8b, 0xe8, 0x74, 0x92, 0x03, 0xd9, 0x87, 0xb5, 0x28, 0x0e, 0x42, 0xf7, 0x84, 0x39,
	0x1e, 0xae, 0xa0, 0xff, 0x34, 0xc7, 0x59, 0xbe, 0x39, 0x9d, 0xa5, 0x25, 0x50, 0x71, 0x75, 0x1c,
	0x5c, 0xa1, 0xab, 0xd1, 0xb8, 0x48, 0x0c, 0xd8, 0xf4, 0xfc, 0xe8, 0x85, 0xe3, 0x86, 0xa1, 0x7b,
	0x2e, 0x78, 0xfd, 0x67, 0xc1, 0xeb, 0xad, 0xe9, 0xbc, 0x1a, 0x7e, 0xf4, 0x42, 0x45, 0x64, 0xc9,
	0x6d, 0xdd, 0xcb, 0x02, 0x88, 0x05, 0x8a, 0x3b, 0x1c, 0xf6, 0xe4, 0x14, 0x11, 0x0c, 0xff, 0x8b,
	0x60, 0x38, 0x43, 0xed, 0xa9, 0x63, 0x74, 0xc9, 0x72, 0xd3, 0xcd, 0x83, 0xc8, 0x8f, 0x61, 0xfb,
	0xcc, 0x0f, 0xe3, 0x91, 0xdb, 0x73, 0xfa, 0x6e, 0xf7, 0xd4, 0x1f, 0xc8, 0x51, 0xff, 0x57, 0xc1,
	0xf8, 0xce, 0x74, 0xc6, 0x87, 0x82, 0xa4, 0x25, 0x28, 0x24, 0x6f, 0x72, 0x36, 0x01, 0x25, 0x3f,
	0x81, 0x6b, 0xc3, 0xd3, 0xf3, 0xc8, 0xef, 0x16, 0xf9, 0xff, 0x37, 0xc1, 0xff, 0xbb, 0x33, 0x16,
	0x9e, 0xa4, 0xc9, 0x37, 0x70, 0x75, 0x38, 0x09, 0x26, 0xc7, 0x70, 0x3d, 0x19, 0x00, 0x32, 0xee,
	0xb2, 0x41, 0xcc, 0x42, 0xd1, 0xc6, 0x7f, 0x17, 0x6d, 0x7c, 0xef, 0xc2, 0x31, 0x34, 0x52, 0x22,
	0xd9, 0xca, 0xb5, 0xb3, 0x69, 0x15, 0xd8, 0x4e, 0x32, 0x2d, 0xba, 0xc1, 0x20, 0x0e, 0x83, 0x5e,
	0x2f, 0x69, 0xe7, 0x7f, 0x5c, 0xd8, 0x8e, 0x9c, 0x21, 0xf5, 0x94, 0x28, 0x69, 0x27, 0x9a, 0x56,
	0x41, 0x6c, 0xd8, 0xea, 0x05, 0x27, 0x5c, 0x60, 0xc3, 0x20, 0x10, 0x83, 0xaa, 0xfc, 0xc1, 0x85,
	0x9f, 0xb9, 0x29, 0xf0, 0xdb, 0x41, 0xd0, 0x4b, 0x3e, 0x73, 0x2f, 0x0f, 0x22, 0x3e, 0x54, 0x12,
	0x29, 0x4d, 0xcc, 0xa1, 0x3f, 0x14, 0xcc, 0xdf, 0xbf, 0x50, 0x4c, 0x93, 0x53, 0x69, 0xe7, 0x6c,
	0x6a, 0x0d, 0x79, 0x0e, 0x57, 0x87, 0x61, 0xd0, 0x65, 0x51, 0x14, 0x84, 0x99, 0x21, 0xfc, 0xcf,
	0xb9, 0x8b, 0x56, 0x66, 0x3b, 0xa1, 0xc8, 0x0c, 0x62, 0x6b, 0x58, 0x04, 0x92, 0x2e, 0xec, 0x84,
	0x2c, 0x62, 0xe1, 0x19, 0xf3, 0x1c, 0x7f, 0x10, 0xc5, 0xa8, 0x27, 0x04, 0xfb, 0xff, 0x25, 0xd8,
	0xbf, 0x37, 0x6b, 0xa3, 0x13, 0x44, 0xba, 0xa4, 0x91, 0x2d, 0x6c, 0x87, 0x53, 0xe0, 0xe4, 0x09,
	0x10, 0xfc, 0xc2, 0xae, 0x3f, 0x60, 0x38, 0x00, 0x4f, 0x34, 0xf0, 0x47, 0xa2, 0x81, 0x77, 0x66,
	0xee, 0x3b, 0x82, 0xa0, 0x1d, 0x78, 0x92, 0xb9, 0xd2, 0x2d, 0xc0, 0x48, 0x8b, 0xef, 0x65, 0x92,
	0x31, 0x67, 0xfa, 0x2b, 0xf3, 0x17, 0xe9, 0x83, 0x94, 0x69, 0xa2, 0x0f, 0xba, 0x59, 0x00, 0xae,
	0xad, 0xa3, 0x51, 0xe4, 0x0f, 0x58, 0x14, 0x39, 0x6e, 0xb7, 0x1b, 0x8c, 0x06, 0xb1, 0xe0, 0xfa,
	0xa7, 0xe6, 0x2f, 0x5a, 0x5b, 0xbb, 0x92, 0x46, 0x15, 0x24, 0xc9, 0xda, 0x3a, 0x9a, 0x04, 0xe3,
	0x5c, 0xec, 0x06, 0xfd, 0xe1, 0x28, 0x66, 0x4e, 0xec, 0x27, 0x7d, 0xfe, 0xd3, 0xf3, 0x17, 0xcd,
	0xc5, 0xba, 0xc0, 0xb7, 0xfd, 0xb4, 0xd7, 0x9b, 0xdd, 0x3c, 0x08, 0x27, 0x48, 0x32, 0x17, 0xcf,
	0x82, 0xde, 0xa8, 0x2f, 0xbf, 0xe0, 0xaf, 0xce, 0x5f, 0x34, 0x41, 0xe4, 0x34, 0x3c, 0xe4, 0x04,
	0xc9, 0x04, 0x39, 0x2b, 0x02, 0xf1, 0xdb, 0xa5, 0x32, 0x19, 0x45, 0x49, 0x97, 0xff, 0xcc, 0xfc,
	0x45, 0xdf, 0x2e, 0x11, 0x48, 0x27, 0x4a, 0xfb, 0xac, 0x1c, 0x15, 0x60, 0xa4, 0x01, 0xab, 0x21,
	0x3b, 0x49, 0xd7, 0xcc, 0xaf, 0x09, 0x8e, 0xb7, 0x67, 0x4d, 0xb7, 0x93, 0xf1, 0x3a, 0x81, 0x30,
	0x2d, 0x91, 0x08, 0x6e, 0x15, 0xb5, 0x6d, 0xc8, 0x7a, 0x6e, 0xcc, 0xe4, 0x24, 0xfb, 0xdd, 0xa5,
	0x8b, 0xcc, 0xb5, 0xbc, 0xd6, 0xa5, 0x82, 0x90, 0xb7, 0x52, 0xa2, 0x37, 0xce, 0x66, 0x55, 0x92,
	0x33, 0x78, 0x6d, 0x42, 0x07, 0xe7, 0x5a, 0xfd, 0xb7, 0xa2, 0xd5, 0x7b, 0x97, 0xd2, 0xc5, 0xf9,
	0x66, 0xab, 0xc3, 0x99, 0xb5, 0xe4, 0xff, 0x87, 0x37, 0xa6, 0x68, 0xcc, 0x5c, 0xcb, 0xbf, 0x27,
	0x5a, 0xbe, 0x7f, 0x49, 0xcd, 0x99, 0x6f, 0xfb, 0x56, 0x74, 0x41, 0x7d, 0xf5, 0x77, 0xca, 0xd2,
	0x17, 0x1a, 0x9b, 0xfd, 0x68, 0x51, 0x24, 0x26, 0x9c, 0xee, 0x71, 0x87, 0x67, 0x85, 0x66, 0x20,
	0xe4, 0x1e, 0x2c, 0x1e, 0x09, 0x6f, 0xa2, 0xfc, 0x0a, 0x9f, 0x44, 0xe2, 0x91, 0x06, 0xac, 0x25,
	0xf4, 0xdc, 0xba, 0x9a, 0xbb, 0xc8, 0xdc, 0xcd, 0x38, 0x51, 0x39, 0x2a, 0xb2, 0x0f, 0xab, 0xd1,
	0xe8, 0xa8, 0xe1, 0x9f, 0xf9, 0x11, 0x5a, 0x8b, 0x17, 0x2e, 0x30, 0x6b, 0x8c, 0xc8, 0x2d, 0xf5,
	0x2c, 0x25, 0x71, 0xa6, 0x99, 0x44, 0x8b, 0x9c, 0xdd, 0x47, 0x17, 0x99, 0x44, 0xe6, 0x20, 0x31,
	0x75, 0x2f, 0x36, 0x8e, 0xaa, 0x0e, 0x6c, 0x4d, 0x18, 0x51, 0xe4, 0x1d, 0xec, 0x7e, 0x34, 0x64,
	0x03, 0xcf, 0x3d, 0xea, 0xa1, 0x23, 0x39, 0xb6, 0x54, 0xb3, 0x15, 0xe8, 0x3d, 0x74, 0xd1, 0x5e,
	0xe5, 0x58, 0xe5, 0xac, 0xf7, 0x90, 0x82, 0xab, 0x7f, 0x02, 0x6e, 0x5e, 0xd0, 0x25, 0x34, 0xb9,
	0xfb, 0xc1, 0xd9, 0xb8, 0x19, 0x9a, 0x14, 0x91, 0x79, 0x14, 0xbb, 0x61, 0x3c, 0xc9, 0x3c, 0x05,
	0x93, 0xdb, 0xb0, 0x1c, 0x75, 0xdd, 0x1e, 0x47, 0x99, 0xcb, 0xa0, 0xa4, 0xd0, 0xea, 0xef, 0x97,
	0x60, 0xb3, 0x20, 0x61, 0xf2, 0x36, 0xac, 0x67, 0x64, 0x9c, 0x4e, 0x9c, 0x3c, 0x90, 0xbc, 0x03,
	0x1b, 0x21, 0xf3, 0x46, 0x03, 0xcf, 0x1d, 0x74, 0x85, 0x43, 0x5d, 0xe6, 0x86, 0x78, 0x01, 0x4a,
	0x3e, 0x81, 0x64, 0xe3, 0x57, 0xbb, 0xb8, 0xbb, 0xd5, 0xdd, 0xa1, 0xdb, 0xc5, 0xcf, 0x84, 0x1d,
	0x2a, 0xd3, 0xe9, 0x95, 0x59, 0xaa, 0x3e, 0xaa, 0xe7, 0x94, 0x6a, 0x3e, 0x4f, 0x95, 0xab, 0x2c,
	0xba, 0xe3, 0x0b, 0x13, 0xee, 0x78, 0xf5, 0x3f, 0xac, 0xc2, 0x6a, 0xc6, 0x84, 0x25, 0x75, 0x48,
	0x4c, 0x58, 0x19, 0x13, 0xc0, 0xe9, 0x7c, 0xb1, 0xe9, 0xcb, 0xe7, 0x73, 0x96, 0x8a, 0xdc, 0x86,
	0x15, 0x7f, 0xa8, 0x7a, 0x5e, 0xc8, 0xa2, 0x48, 0x48, 0x81, 0x7b, 0xd2, 0x63, 0x20, 0x3a, 0xdb,
	0xec, 0xe5, 0x30, 0x08, 0xe3, 0xb6, 0x1b, 0x9f, 0x8a, 0x30, 0x81, 0x70, 0xb6, 0xc7, 0x50, 0xe4,
	0x22, 0x99, 0xea, 0x1e, 0x1f, 0xa6, 0xe4, 0x92, 0x02, 0xc9, 0x2d, 0x58, 0xea, 0x8d, 0x06, 0x9d,
	0x91, 0xef, 0x89, 0xa1, 0xf1, 0xfa, 0x04, 0x44, 0x2a, 0xb0, 0xd0, 0x1b, 0xe1, 0xe7, 0xc2, 0xf9,
	0xbf, 0xc0, 0xeb, 0x04, 0x80, 0x6c, 0xc3, 0xdc, 0xd7, 0x5f, 0x0f, 0x2a, 0x4b, 0x29, 0x0d, 0x16,
	0xc9, 0x07, 0xb0, 0x31, 0x08, 0xe2, 0x7a, 0x6f, 0x14, 0xc5, 0x2c, 0xe4, 0x53, 0x64, 0x39, 0xeb,
	0x9a, 0x14, 0x2a, 0x49, 0x0d, 0xd6, 0xd8, 0xcb, 0x98, 0x85, 0x03, 0xb7, 0xc7, 0x85, 0xbb, 0xc2,
	0xfd, 0x93, 0x1c, 0x8c, 0x3c, 0x86, 0x79, 0xf4, 0xc1, 0x2a, 0xc0, 0xb5, 0xc9, 0x67, 0xaf, 0xf4,
	0x20, 0x92, 0xdf, 0x7b, 0x7e, 0x8f, 0x35, 0x58, 0xd4, 0x0d, 0xfd, 0x61, 0x1c, 0x84, 0x94, 0x33,
	0xc1, 0x8f, 0x99, 0x08, 0xd9, 0x67, 0x21, 0x77, 0xac, 0x57, 0x68, 0x16, 0x44, 0xf6, 0x61, 0x71,
	0x98, 0xf5, 0x91, 0x3f, 0xbc, 0x74, 0x83, 0xd2, 0xc1, 0x95, 0xe4, 0xc4, 0x84, 0xd5, 0xd0, 0xfd,
	0x3a, 0x9d, 0x63, 0xc2, 0x47, 0xfe, 0xe0, 0xd5, 0xdc, 0xe8, 0x98, 0x88, 0x66, 0x39, 0x54, 0x7f,
	0x7b, 0x1e, 0xae, 0x4d, 0x1d, 0x1b, 0x21, 0x30, 0x3f, 0xc4, 0x39, 0x20, 0xd6, 0x14, 0xff, 0x4d,
	0x76, 0x60, 0x31, 0xf2, 0xbf, 0x61, 0x8f, 0x8f, 0x78, 0x64, 0x69, 0x8e, 0xca, 0x12, 0xb9, 0x0b,
	0x04, 0x35, 0x70, 0xe2, 0x24, 0xdb, 0x7e, 0x9f, 0xb5, 0xa2, 0xca, 0x1c, 0xc7, 0x99, 0x52, 0x43,
	0xbe, 0x84, 0xf9, 0x18, 0x67, 0xf1, 0x3c, 0x9f, 0xc5, 0xef, 0x5f, 0x66, 0x53, 0xc5, 0xde, 0xf1,
	0x09, 0xcd, 0x29, 0xc9, 0x1d, 0xd8, 0xf4, 0x83, 0x61, 0xc4, 0x35, 0x11, 0xae, 0x73, 0x26, 0x66,
	0xda, 0x02, 0x2d, 0x82, 0xa7, 0x2c, 0xff, 0xc5, 0xa9, 0xcb, 0xff, 0x6d, 0x58, 0x0f, 0x59, 0x14,
	0x8c, 0xc2, 0x2e, 0xdb, 0x0f, 0x83, 0xd1, 0x50, 0xcc, 0x42, 0x9a, 0x07, 0xa2, 0x8f, 0xec, 0x05,
	0x46, 0x10, 0x37, 0x58, 0x8f, 0xc5, 0x85, 0x89, 0x98, 0xad, 0xc1, 0x1d, 0x2d, 0x88, 0x4f, 0x59,
	0x88, 0x2b, 0x26, 0x92, 0x73, 0x30, 0x03, 0xc1, 0x59, 0xda, 0x0d, 0x59, 0x2a, 0x14, 0x1e, 0xb3,
	0x59, 0xa1, 0x39, 0x18, 0xea, 0xd4, 0xe8, 0xc5, 0x88, 0x4f, 0x62, 0x31, 0xa9, 0x92, 0x22, 0x72,
	0x8f, 0x06, 0xee, 0x30, 0x3a, 0x0d, 0x62, 0xdd, 0xe3, 0x93, 0x6a, 0x85, 0x66, 0x20, 0x58, 0x2f,
	0x2c, 0x38, 0x4e, 0xbc, 0x2e, 0xea, 0xc7, 0x10, 0xd2, 0x06, 0x45, 0x94, 0x32, 0xf1, 0xb2, 0xcd,
	0x6f, 0x13, 0x2f, 0x2b, 0x52, 0x57, 0xff, 0x75, 0x09, 0xd6, 0x73, 0x73, 0x96, 0xb4, 0x00, 0xc6,
	0x22, 0x96, 0x0a, 0xeb, 0xe2, 0xa9, 0x4a, 0x53, 0xf4, 0x16, 0x8b, 0x4f, 0x03, 0x8f, 0x66, 0x18,
	0xe0, 0x1c, 0x3b, 0x76, 0xfd, 0xde, 0x28, 0x64, 0x91, 0x1d, 0xd8, 0x41, 0x8f, 0x85, 0x6e, 0x2c,
	0x54, 0xf9, 0x02, 0x9d, 0x52, 0x43, 0xee, 0xc1, 0xd5, 0x68, 0xe8, 0x76, 0x99, 0xf0, 0x30, 0xb8,
	0x50, 0xdb, 0xdd, 0x98, 0xab, 0xb4, 0x05, 0x3a, 0xad, 0x0a, 0x85, 0x16, 0xba, 0xbe, 0xb7, 0xe7,
	0x76, 0xe3, 0x20, 0x94, 0xfa, 0x3b, 0x03, 0xa9, 0x3a, 0xb0, 0x9a, 0x59, 0x47, 0xa4, 0x0a, 0xcb,
	0xdd, 0x64, 0x21, 0xe2, 0xe8, 0xe6, 0x68, 0x5a, 0xc6, 0xc5, 0x73, 0x1c, 0x32, 0xd1, 0xbd, 0x39,
	0xca, 0x7f, 0xa3, 0x9a, 0x18, 0x0d, 0x70, 0xf8, 0x7e, 0x1c, 0x33, 0x8f, 0x77, 0x64, 0x8e, 0x66,
	0x41, 0xd5, 0x27, 0xa0, 0x14, 0x4d, 0x5e, 0xae, 0xf7, 0x59, 0x94, 0x6c, 0x79, 0x95, 0x12, 0xff,
	0x48, 0xb3, 0xf4, 0xfe, 0x18, 0x91, 0x66, 0xa9, 0xaa, 0x5f, 0x00, 0x8c, 0x2d, 0x5f, 0x72, 0x17,
	0x96, 0x4f, 0x58, 0x20, 0xec, 0xbc, 0x12, 0xd7, 0x20, 0x57, 0xb3, 0xfc, 0xf6, 0x59, 0xc0, 0x39,
	0x2c, 0x9d, 0x88, 0x1f, 0x38, 0xee, 0x0c, 0x67, 0x5c, 0x50, 0x79, 0x93, 0x56, 0xaa, 0x88, 0x02,
	0x14, 0x97, 0x68, 0xd2, 0x87, 0x51, 0x28, 0xa2, 0x6d, 0x42, 0x6b, 0x14, 0xc1, 0xd5, 0x7f, 0x5f,
	0x82, 0xf5, 0x5c, 0x88, 0x85, 0xdc, 0xca, 0x6e, 0x31, 0x25, 0xbe, 0x78, 0x32, 0xdb, 0xcb, 0xdb,
	0xb0, 0x86, 0xab, 0x3c, 0x55, 0x83, 0x5c, 0xca, 0x07, 0x57, 0x68, 0x0e, 0x4a, 0xbe, 0x12, 0x2a,
	0x42, 0xfa, 0x3d, 0x5c, 0x7a, 0x73, 0x97, 0x70, 0x90, 0xf4, 0x60, 0x18, 0x25, 0x0e, 0x52, 0x81,
	0x9e, 0x7c, 0x0e, 0xdb, 0xd1, 0x68, 0x88, 0x1b, 0x61, 0x24, 0x5c, 0x1b, 0xca, 0x50, 0x03, 0xf2,
	0xb9, 0x92, 0xaa, 0x81, 0xa9, 0x28, 0xbb, 0xab, 0xb0, 0x82, 0xdc, 0xb8, 0xd4, 0xab, 0xff, 0xae,
	0x04, 0x9b, 0x85, 0xd8, 0xc0, 0x2b, 0x86, 0x8c, 0x66, 0x06, 0x0b, 0xcf, 0xfc, 0x2e, 0x6b, 0xb2,
	0x33, 0xd6, 0x33, 0x8f, 0x7e, 0x89, 0x75, 0x63, 0xff, 0x2c, 0xb1, 0x65, 0xa6, 0x57, 0x4e, 0x08,
	0x6a, 0xee, 0xb2, 0x82, 0x9a, 0xff, 0xd9, 0x04, 0x95, 0x1f, 0xed, 0xdf, 0x2f, 0xc1, 0x66, 0x31,
	0x16, 0x41, 0xe4, 0x0e, 0x50, 0xe2, 0xdd, 0x17, 0x3a, 0xfd, 0xd6, 0x84, 0x75, 0x92, 0xb5, 0x4c,
	0x70, 0x3f, 0x0a, 0xc2, 0x58, 0x1e, 0x5d, 0xf0, 0xdf, 0x22, 0xba, 0xc9, 0x3d, 0x0b, 0x3d, 0x25,
	0xe4, 0x06, 0x09, 0x9d, 0x80, 0x93, 0x47, 0xb0, 0xe8, 0x1d, 0xf1, 0xc1, 0x2d, 0xf0, 0xc1, 0xcd,
	0x08, 0xe8, 0x23, 0xc6, 0x91, 0x1b, 0xf1, 0x61, 0x50, 0x49, 0x51, 0xfd, 0x95, 0x12, 0xec, 0x4c,
	0x0f, 0xb7, 0xfc, 0x8c, 0x03, 0x59, 0x90, 0x03, 0x41, 0x13, 0x42, 0x7c, 0x41, 0x3b, 0xd9, 0x17,
	0xd1, 0x84, 0x18, 0x83, 0xaa, 0x7f, 0x58, 0x82, 0xab, 0x53, 0x02, 0x04, 0x68, 0x1c, 0xa1, 0x90,
	0x1b, 0x7e, 0xd4, 0x0d, 0xce, 0x58, 0xc8, 0x3c, 0x69, 0xe5, 0x27, 0xc6, 0x51, 0xbe, 0x92, 0xbc,
	0x06, 0x90, 0x44, 0x24, 0xf8, 0xf9, 0x10, 0xef, 0x9b, 0x84, 0xe8, 0x1e, 0x31, 0xe0, 0xea, 0x30,
	0xf4, 0xbb, 0xfe, 0xe0, 0xc4, 0xf1, 0x3d, 0x36, 0x88, 0xfd, 0x63, 0x9f, 0x85, 0xb8, 0x93, 0xa3,
	0xd6, 0x79, 0x2d, 0x2b, 0xb1, 0xb6, 0x40, 0xd3, 0x53, 0x2c, 0x4a, 0x86, 0x45, 0x50, 0x44, 0xf6,
	0x41, 0x41, 0x28, 0x73, 0xb8, 0x99, 0xef, 0xbc, 0x60, 0xe7, 0x91, 0x3c, 0x55, 0x7a, 0x05, 0xb3,
	0x0d, 0x4e, 0x66, 0x23, 0xd5, 0x63, 0x76, 0x1e, 0x55, 0x7f, 0x7f, 0x9e, 0x3b, 0x8d, 0xb9, 0x70,
	0xc5, 0x0e, 0x2c, 0x1e, 0xbb, 0x7d, 0xbf, 0x77, 0x2e, 0x85, 0x2f, 0x4b, 0xe4, 0x4d, 0x58, 0xfb,
	0xff, 0x46, 0x41, 0xec, 0x3a, 0xb2, 0x56, 0x5a, 0xd7, 0x1c, 0xb6, 0x27, 0x50, 0xfe, 0x5c, 0x09,
	0xde, 0xf0, 0x98, 0x87, 0x1f, 0x92, 0x79, 0x4e, 0xe2, 0x0c, 0x0f, 0x58, 0xfc, 0x75, 0x10, 0xbe,
	0x70, 0xa2, 0x38, 0xd9, 0x5a, 0x36, 0xee, 0xef, 0x5e, 0x2a, 0x9a, 0x72, 0xb7, 0x91, 0x30, 0x93,
	0x5b, 0x99, 0x21, 0x58, 0xf1, 0xa3, 0x12, 0x7a, 0xcb, 0xbb, 0xa0, 0x96, 0xbc, 0x01, 0xab, 0x83,
	0x51, 0xdf, 0xe9, 0x06, 0xa3, 0x61, 0x30, 0x88, 0xe4, 0xb4, 0x80, 0xc1, 0xa8, 0x5f, 0x17, 0x10,
	0x72, 0x13, 0x56, 0x04, 0x42, 0xc8, 0xc4, 0xf4, 0x5e, 0xa0, 0xcb, 0xbc, 0x3a, 0x64, 0x11, 0x79,
	0x1f, 0x08, 0x56, 0x8e, 0x63, 0x6e, 0x7e, 0xf4, 0x22, 0x12, 0x96, 0x35, 0x55, 0x06, 0xa3, 0x7e,
	0x1a, 0x40, 0x43, 0x38, 0xf9, 0x08, 0xae, 0xe5, 0x30, 0x1d, 0xd4, 0x4d, 0xce, 0xc9, 0x11, 0x37,
	0x76, 0x16, 0x28, 0xf1, 0x33, 0xd8, 0x96, 0xff, 0x0d, 0xdb, 0x3f, 0x22, 0x36, 0x90, 0x3c, 0x09,
	0x9f, 0xee, 0xe2, 0x50, 0x6c, 0x46, 0xdc, 0x26, 0xdb, 0x26, 0xb7, 0xd9, 0x14, 0xbf, 0x00, 0x41,
	0xf3, 0xe7, 0x68, 0x14, 0x46, 0x7c, 0x5a, 0xd4, 0xdb, 0x1d, 0x7e, 0x1a, 0xb6, 0x4c, 0x73, 0xb0,
	0xda, 0x37, 0x70, 0xeb, 0x22, 0xb1, 0x92, 0x2d, 0x58, 0x37, 0x4c, 0xdb, 0xb1, 0x3a, 0xed, 0xb6,
	0x49, 0x6d, 0xad, 0xa1, 0x94, 0xc8, 0x75, 0xb8, 0x5a, 0x37, 0x8d, 0x3d, 0x7d, 0xbf, 0x43, 0xb5,
	0x86, 0xd3, 0xd0, 0x2d, 0x75, 0xb7, 0xa9, 0x35, 0x94, 0x32, 0xd9, 0x01, 0x92, 0xa9, 0xd0, 0x0c,
	0x01, 0x9f, 0x43, 0xb8, 0x2c, 0x38, 0xbb, 0xcf, 0x9c, 0x86, 0xb6, 0xa7, 0x76, 0x9a, 0xb6, 0x32,
	0x5f, 0xfd, 0xa7, 0x4b, 0xb0, 0x35, 0x11, 0xd9, 0x22, 0x0f, 0xc6, 0xa1, 0x66, 0x97, 0xbb, 0x81,
	0x4e, 0xce, 0x02, 0x98, 0xe9, 0x24, 0x66, 0xe9, 0xb8, 0x23, 0x38, 0xa6, 0x2b, 0x5f, 0xe4, 0x26,
	0x3a, 0xb0, 0x39, 0xb6, 0x80, 0x84, 0xe0, 0x45, 0x1c, 0xe3, 0xc1, 0x25, 0x63, 0x71, 0x77, 0x69,
	0xce, 0xc8, 0x9d, 0x30, 0x7a, 0x9f, 0x48, 0x3f, 0x48, 0xac, 0xc9, 0xfa, 0x65, 0xb9, 0xe6, 0x20,
	0x53, 0x7d, 0xa2, 0xbc, 0x81, 0xba, 0x30, 0x61, 0xa0, 0xbe, 0x05, 0xeb, 0x89, 0xa9, 0xeb, 0xc4,
	0x68, 0xff, 0x2e, 0x72, 0x73, 0x28, 0x6f, 0xff, 0x7e, 0x02, 0x3b, 0x7e, 0xe0, 0xc4, 0xa7, 0x61,
	0x30, 0x3a, 0x39, 0x1d, 0x8e, 0x32, 0x52, 0xc3, 0xe9, 0x5a, 0xa2, 0xdb, 0x7e, 0x60, 0xa7, 0x95,
	0xa9, 0xd0, 0xee, 0xc2, 0xd5, 0x3c, 0xd5, 0x28, 0x72, 0x4f, 0xc4, 0x8c, 0x2d, 0xd1, 0xad, 0x2c,
	0x49, 0x07, 0x2b, 0xc8, 0x11, 0x28, 0x6e, 0x1c, 0xbb, 0xdd, 0xd3, 0x3e, 0x1b, 0xc4, 0x72, 0xed,
	0xaf, 0x70, 0x29, 0x7f, 0x76, 0x59, 0x79, 0xa8, 0x29, 0xbd, 0x58, 0xf0, 0x9b, 0x6e, 0x1e, 0x80,
	0x3b, 0x02, 0x1b, 0x74, 0xc3, 0xf3, 0x61, 0x9c, 0x1c, 0xcf, 0xd2, 0x31, 0x00, 0xb5, 0xbf, 0x1f,
	0x69, 0xc3, 0x53, 0xd6, 0x67, 0xa1, 0xdb, 0xe3, 0xb6, 0xfe, 0x32, 0xcd, 0x82, 0xaa, 0xff, 0xb2,
	0x04, 0x37, 0x2f, 0x10, 0xfa, 0x2b, 0x9d, 0xb5, 0x52, 0xc6, 0x59, 0x4b, 0x9c, 0xaf, 0xb9, 0x9f,
	0xda, 0xf9, 0x9a, 0xee, 0xee, 0xcd, 0xf3, 0x56, 0xa6, 0xb9, 0x7b, 0xb7, 0x61, 0xb5, 0xe7, 0x0f,
	0x5e, 0x30, 0x4f, 0x38, 0x43, 0x0b, 0xf2, 0x98, 0x72, 0x0c, 0xaa, 0x7d, 0x08, 0x9b, 0x05, 0x19,
	0x92, 0x35, 0x58, 0x56, 0x6d, 0x5b, 0xad, 0x1f, 0x68, 0x0d, 0xe5, 0x0a, 0xd9, 0x00, 0xe8, 0x18,
	0x69, 0xb9, 0x54, 0x7b, 0x00, 0x1b, 0xf9, 0xa9, 0x4d, 0x96, 0x60, 0xae, 0x49, 0x2d, 0xa5, 0x84,
	0x3f, 0x9e, 0x53, 0x4b, 0x29, 0xe3, 0x8f, 0x7d, 0x6a, 0x29, 0x73, 0x64, 0x05, 0x16, 0xa8, 0x8a,
	0x3f, 0xe7, 0xab, 0x7f, 0x67, 0x05, 0xc8, 0xe4, 0x19, 0x59, 0x7e, 0xc7, 0x96, 0xc6, 0xd7, 0x78,
	0xc7, 0xfe, 0x0c, 0x96, 0xce, 0xfa, 0x56, 0xba, 0x29, 0x14, 0x36, 0xaf, 0x8c, 0xd0, 0x5a, 0xe2,
	0xf3, 0x27, 0xd8, 0xc8, 0xf6, 0x64, 0xc4, 0xa2, 0x38, 0x93, 0x73, 0x31, 0x06, 0x10, 0x07, 0x36,
	0xdc, 0xc1, 0x20, 0x88, 0xb9, 0xa8, 0x8c, 0x20, 0x4e, 0x96, 0xe1, 0x67, 0x97, 0x3d, 0xda, 0xbb,
	0xab, 0xe6, 0xc8, 0x69, 0x81, 0x1d, 0x79, 0x26, 0x57, 0xb7, 0xc8, 0xc0, 0xd0, 0x2e, 0xcd, 0x76,
	0xf2, 0xe3, 0x4f, 0xac, 0xef, 0x0a, 0x2c, 0xe1, 0x16, 0x34, 0x1c, 0x25, 0x7b, 0x4d, 0x52, 0x24,
	0x4f, 0x61, 0xf5, 0xc8, 0xef, 0xf5, 0xfc, 0xc1, 0x09, 0x37, 0x65, 0x96, 0x2e, 0xa1, 0xaf, 0x72,
	0x6d, 0xb7, 0x76, 0xc7, 0xd4, 0x34, 0xcb, 0x8a, 0x7c, 0x01, 0x37, 0x8e, 0x7c, 0xcf, 0xf3, 0x07,
	0x27, 0xed, 0x30, 0xf0, 0x46, 0xdd, 0x38, 0xe9, 0x15, 0xba, 0x16, 0xcb, 0x5c, 0xba, 0xb3, 0x11,
	0xd0, 0xbf, 0x1f, 0x8c, 0xfa, 0x5a, 0xcf, 0x8d, 0x62, 0xbf, 0xab, 0x0f, 0x23, 0xbe, 0xc6, 0x17,
	0x68, 0x1e, 0x88, 0x16, 0x65, 0x37, 0x18, 0x0c, 0x58, 0x37, 0x66, 0x9e, 0xdc, 0x6c, 0x78, 0x90,
	0x68, 0x85, 0x4e, 0xc0, 0x89, 0x0b, 0xfc, 0x1c, 0xd8, 0x0e, 0xe4, 0xe6, 0x54, 0x59, 0xe5, 0x72,
	0xfe, 0xfe, 0xa5, 0xc7, 0xda, 0xc8, 0x52, 0x6b, 0x83, 0x38, 0x3c, 0xa7, 0x79, 0x8e, 0xe4, 0x29,
	0xac, 0xf5, 0xfc, 0x2e, 0x1b, 0x44, 0xac, 0x15, 0x78, 0xac, 0xc7, 0x3d, 0xfd, 0x99, 0xb9, 0x28,
	0xcd, 0x0c, 0xe6, 0x23, 0xa5, 0xa9, 0xd7, 0x35, 0xc3, 0xd2, 0x1c, 0xdd, 0xa8, 0x37, 0x3b, 0x0d,
	0xad, 0x41, 0x73, 0x9c, 0xc8, 0x7d, 0xd8, 0xc6, 0x91, 0x27, 0x1a, 0x46, 0x36, 0x18, 0xf1, 0x58,
	0xc1, 0x02, 0x9d, 0x5a, 0x57, 0x7d, 0x08, 0x1b, 0xf9, 0x19, 0x47, 0x14, 0x98, 0x7b, 0xc1, 0xce,
	0xa5, 0xda, 0xc1, 0x9f, 0x64, 0x1b, 0x16, 0xce, 0xdc, 0xde, 0x88, 0xc9, 0xdc, 0x23, 0x51, 0xa8,
	0xfe, 0x56, 0x09, 0x6e, 0x5d, 0x34, 0xab, 0x8a, 0xde, 0x4f, 0x39, 0xef, 0xfd, 0x24, 0xea, 0xad,
	0x3c, 0x55, 0xbd, 0xcd, 0x4d, 0x55, 0x6f, 0x3f, 0x75, 0x6c, 0xa9, 0xfa, 0x25, 0x90, 0xc9, 0x2f,
	0x33, 0x1e, 0x6a, 0x69, 0xca, 0x50, 0x4b, 0xe9, 0x50, 0x1f, 0x95, 0x1f, 0x96, 0x6a, 0x16, 0xac,
	0xe7, 0xe6, 0x31, 0x2a, 0x33, 0xd3, 0x68, 0x68, 0x2d, 0xd5, 0x40, 0x65, 0xb6, 0x0a, 0x4b, 0xbb,
	0x7a, 0xa3, 0xa1, 0x1b, 0xfb, 0x4a, 0x89, 0xac, 0xc3, 0x4a, 0x43, 0x6b, 0xe8, 0x75, 0xd5, 0xe6,
	0x86, 0xca, 0x1a, 0x2c, 0x53, 0xcd, 0xd2, 0xe8, 0x21, 0x37, 0x4f, 0x00, 0x16, 0x0f, 0x9e, 0xed,
	0x52, 0xbd, 0xa1, 0xcc, 0x57, 0x7f, 0xb3, 0x04, 0x6b, 0x59, 0xef, 0x04, 0x25, 0xc0, 0x06, 0x27,
	0xc2, 0x01, 0xe7, 0xf6, 0xaf, 0x28, 0xe1, 0xda, 0x64, 0x9e, 0x2f, 0x1d, 0x6e, 0x1e, 0x36, 0x92,
	0x45, 0xac, 0x39, 0x63, 0x21, 0x3f, 0xca, 0x10, 0xda, 0x28, 0x29, 0xa2, 0x53, 0xef, 0xb1, 0x61,
	0x2f, 0x38, 0x47, 0x05, 0x9c, 0xf1, 0x41, 0x0a, 0x50, 0xb4, 0xdb, 0x72, 0x13, 0x52, 0xec, 0xec,
	0x39, 0x58, 0xf5, 0x37, 0x4a, 0x69, 0x4c, 0xb1, 0x70, 0x84, 0x5e, 0xf4, 0x47, 0x4b, 0x97, 0xf5,
	0x47, 0xcb, 0x7f, 0x9c, 0xfe, 0xe8, 0x9f, 0x04, 0xa5, 0x78, 0x2a, 0x8c, 0xf3, 0x6f, 0xe0, 0xf6,
	0x19, 0x0f, 0x0b, 0x49, 0x71, 0x8e, 0x01, 0xaf, 0x70, 0xe8, 0xaa, 0xb0, 0x7c, 0x3c, 0xea, 0xf5,
	0x32, 0x4a, 0x3e, 0x2d, 0xa7, 0xce, 0xde, 0xfc, 0xd8, 0x6b, 0xad, 0xfe, 0xa5, 0x12, 0xac, 0xe7,
	0x4e, 0x90, 0xff, 0x4f, 0xb6, 0x8e, 0x73, 0x60, 0x18, 0x78, 0x99, 0x63, 0x87, 0xa4, 0x58, 0xfd,
	0x00, 0x96, 0xe4, 0x0e, 0xc6, 0x0f, 0x84, 0x12, 0x75, 0x97, 0x3b, 0x36, 0x1a, 0x83, 0xab, 0x7f,
	0xb5, 0x0c, 0x57, 0xa7, 0xa4, 0x83, 0xe0, 0x6e, 0x39, 0x94, 0xbb, 0x65, 0xe9, 0xa2, 0xdd, 0xb2,
	0x9d, 0xec, 0x96, 0x12, 0x5b, 0x6a, 0xe8, 0xfa, 0x70, 0x64, 0x05, 0xdd, 0x17, 0x2c, 0x8e, 0x64,
	0x70, 0x2f, 0x0f, 0x44, 0x63, 0x42, 0x00, 0xb8, 0xff, 0x23, 0xdd, 0xa5, 0x2c, 0x68, 0xcc, 0xc7,
	0x3e, 0x0d, 0x99, 0xeb, 0x25, 0x3e, 0x53, 0x1e, 0xc8, 0x93, 0x98, 0x04, 0x45, 0xeb, 0xf4, 0x1b,
	0x19, 0x3c, 0xce, 0x40, 0x88, 0x0a, 0x2b, 0xa8, 0x8b, 0x45, 0x2c, 0x78, 0x91, 0x6b, 0xf6, 0x0b,
	0xb2, 0x83, 0x38, 0x1a, 0x8f, 0x19, 0x8c, 0xa9, 0xaa, 0xef, 0xc3, 0x92, 0x1c, 0x24, 0x79, 0x13,
	0x96, 0x8f, 0x5d, 0xbf, 0x87, 0x5e, 0x78, 0xde, 0x41, 0x4f, 0xc1, 0xd5, 0x7f, 0x58, 0x82, 0xea,
	0x44, 0xea, 0x0b, 0x2e, 0xba, 0x76, 0x18, 0x0c, 0x23, 0xa2, 0xc3, 0x7c, 0x18, 0xf4, 0x92, 0x93,
	0x9f, 0xcb, 0xa6, 0xce, 0xd0, 0xa0, 0xc7, 0x1e, 0x2d, 0xd7, 0x4d, 0xc3, 0xea, 0xb4, 0x34, 0x4a,
	0x39, 0x0b, 0xf2, 0x21, 0x6c, 0x26, 0x31, 0x2a, 0x83, 0x45, 0xb1, 0x3f, 0x38, 0x91, 0xe7, 0x72,
	0xb2, 0x4f, 0xc5, 0x5a, 0x7e, 0x02, 0xc3, 0xa2, 0x98, 0x79, 0x49, 0x16, 0x9f, 0x3c, 0xa4, 0x4b,
	0x4f, 0x60, 0x72, 0x95, 0xd5, 0x3f, 0x3f, 0x07, 0xd7, 0xa6, 0x26, 0xf1, 0xa0, 0xca, 0x1a, 0xf6,
	0xf9, 0xb9, 0x90, 0x30, 0xb2, 0x64, 0x09, 0xe1, 0x67, 0x02, 0x5e, 0x16, 0x70, 0x51, 0x22, 0x77,
	0xc7, 0x3d, 0x4d, 0x36, 0xd9, 0xec, 0xf1, 0x60, 0xb1, 0x92, 0x1c, 0xc2, 0xc6, 0x99, 0xd7, 0xe5,
	0x9e, 0x92, 0x33, 0x44, 0xb1, 0xc9, 0x48, 0xd6, 0xbd, 0x4b, 0x8a, 0x2b, 0x15, 0x37, 0x5d, 0x3b,
	0xf3, 0xba, 0x63, 0xe1, 0x9f, 0xc2, 0x36, 0xf2, 0x75, 0x7b, 0xbd, 0x40, 0x26, 0xe8, 0xf4, 0x53,
	0xf5, 0xf7, 0x2a, 0xeb, 0x66, 0xcc, 0x5d, 0x4d, 0xc9, 0xb9, 0xa2, 0xa4, 0xe4, 0xcc, 0xeb, 0x16,
	0x60, 0xc4, 0x84, 0x4d, 0x8f, 0x45, 0x2f, 0xe2, 0x60, 0x98, 0x44, 0x06, 0xe5, 0x31, 0xf1, 0x0c,
	0xe5, 0xd7, 0xc8, 0x23, 0xd3, 0x22, 0x75, 0xf5, 0x6f, 0xcc, 0xc3, 0x66, 0x01, 0x89, 0x78, 0xb0,
	0x3e, 0x4c, 0x8e, 0x48, 0x32, 0x29, 0xc6, 0x3f, 0xb8, 0x54, 0x13, 0xd9, 0x72, 0x3b, 0xcb, 0x85,
	0xe6, 0x99, 0x92, 0xa7, 0xf2, 0x54, 0x59, 0x9e, 0xb9, 0x62, 0x0b, 0x8f, 0xbe, 0x75, 0x0b, 0xf5,
	0x84, 0x03, 0x1d, 0x33, 0x23, 0x27, 0xb0, 0xe1, 0x46, 0x91, 0x7f, 0x32, 0x48, 0x77, 0xab, 0x39,
	0xce, 0xfe, 0x87, 0xdf, 0x9a, 0xbd, 0x9a, 0x63, 0x43, 0x0b, 0x6c, 0x51, 0xd9, 0xf4, 0xdd, 0x28,
	0x66, 0xa1, 0xde, 0xc7, 0xb9, 0x27, 0xe3, 0x72, 0x19, 0x10, 0xaa, 0xdf, 0xc4, 0xad, 0x95, 0xfa,
	0x34, 0x2d, 0xd7, 0x1e, 0x40, 0x65, 0x96, 0xac, 0x70, 0xdb, 0x37, 0x0d, 0x27, 0x6b, 0x12, 0x74,
	0xda, 0x7b, 0xd4, 0x34, 0x6c, 0xa5, 0x54, 0xfb, 0x1c, 0xb6, 0xa7, 0x49, 0x80, 0x2c, 0xc3, 0xfc,
	0x5e, 0xa7, 0xd9, 0x54, 0xae, 0xa0, 0x5d, 0xd0, 0xd4, 0x8d, 0xc7, 0x3c, 0xe6, 0xb1, 0x0a, 0x4b,
	0xba, 0x61, 0xd9, 0xaa, 0x61, 0x2b, 0xe5, 0xda, 0x43, 0xb8, 0x31, 0x73, 0x74, 0x88, 0xd9, 0x78,
	0x66, 0xa8, 0x2d, 0xbd, 0x2e, 0x3c, 0xaa, 0xb6, 0x46, 0x2d, 0xdd, 0xb2, 0x35, 0x6c, 0xb4, 0xfa,
	0x14, 0x36, 0xf2, 0x87, 0x3c, 0xc5, 0x5d, 0xa9, 0x9c, 0xdf, 0x95, 0x08, 0xcc, 0x63, 0x21, 0xb1,
	0xc9, 0xf0, 0xf7, 0xd8, 0x22, 0x9a, 0xcb, 0x1a, 0x7f, 0xbf, 0x5d, 0x82, 0x1b, 0x33, 0x33, 0x64,
	0xc8, 0x43, 0x58, 0xec, 0xb3, 0x7e, 0x10, 0x9e, 0xcb, 0xdd, 0x62, 0x46, 0x8a, 0x46, 0x8b, 0xe3,
	0x88, 0xa8, 0xac, 0xc0, 0x47, 0x0d, 0x9d, 0x26, 0xa2, 0xc9, 0xbc, 0x90, 0xb7, 0x5e, 0x91, 0xc4,
	0x26, 0x34, 0x74, 0x4a, 0x45, 0xde, 0x87, 0xb2, 0x1f, 0xc8, 0xf0, 0xe6, 0xad, 0x19, 0xc1, 0x2c,
	0x71, 0x1a, 0x52, 0xf6, 0x03, 0xae, 0xa1, 0x67, 0x27, 0xdd, 0xfc, 0xbf, 0x34, 0x92, 0x5f, 0x2f,
	0xc1, 0xad, 0x8b, 0x92, 0x78, 0xfe, 0xaf, 0x8e, 0xa5, 0xfa, 0x1c, 0x60, 0xcc, 0x58, 0x5e, 0x65,
	0x28, 0xcd, 0xba, 0xca, 0x50, 0x9e, 0xbc, 0xca, 0x90, 0x3d, 0x99, 0x9b, 0xe3, 0x61, 0x9f, 0xb4,
	0x5c, 0xfd, 0x31, 0xac, 0xe7, 0xda, 0xfd, 0x63, 0x66, 0x3f, 0x84, 0x45, 0x21, 0xe6, 0x9f, 0x82,
	0xef, 0x36, 0x2c, 0x44, 0x43, 0x26, 0x8f, 0x06, 0x4b, 0x54, 0x14, 0xd0, 0x4e, 0xe9, 0xbb, 0xdd,
	0xfc, 0xe9, 0x46, 0x06, 0x52, 0xad, 0x8b, 0xb3, 0xb3, 0xd4, 0x00, 0x21, 0xf7, 0x61, 0x1e, 0x4d,
	0x10, 0x79, 0x54, 0xf8, 0xfa, 0x6c, 0x9b, 0x85, 0x8b, 0x9d, 0xe3, 0x56, 0x9f, 0xc3, 0x72, 0x02,
	0x41, 0xfa, 0x8c, 0xa1, 0x71, 0x01, 0x3d, 0xda, 0x16, 0xd2, 0xa2, 0xc8, 0x8a, 0xa4, 0x9c, 0x3f,
	0x0b, 0xad, 0xfe, 0x5e, 0x29, 0x0d, 0xdd, 0x27, 0x26, 0x3a, 0x79, 0x0d, 0x16, 0x4f, 0xcf, 0x8f,
	0x42, 0xbf, 0x70, 0x5a, 0x21, 0x81, 0x68, 0x6f, 0x1c, 0xf7, 0xdc, 0xe8, 0x54, 0x3d, 0x73, 0xfd,
	0x5e, 0x26, 0x6f, 0x28, 0xb1, 0x37, 0xf2, 0x95, 0xe4, 0x4b, 0x61, 0xdd, 0xeb, 0x31, 0xeb, 0x27,
	0x67, 0x15, 0xb5, 0x59, 0x4b, 0x40, 0xa0, 0x89, 0x19, 0x97, 0x12, 0x91, 0x7d, 0xb8, 0xd9, 0x75,
	0x7b, 0xdd, 0x11, 0x2e, 0x80, 0xbd, 0x30, 0xe8, 0x1f, 0x04, 0x68, 0xd0, 0x70, 0x3a, 0x5f, 0x06,
	0xdd, 0xd3, 0xd6, 0x2f, 0xc2, 0xac, 0x3e, 0x85, 0xb5, 0x6c, 0x1b, 0xe8, 0x2f, 0x25, 0xad, 0xf0,
	0xcf, 0x2e, 0xe6, 0x43, 0x0e, 0x86, 0xf6, 0x6a, 0x52, 0x3e, 0x4c, 0x5d, 0xe7, 0x39, 0x9a, 0x07,
	0x56, 0xff, 0xca, 0x3c, 0xdc, 0x98, 0x79, 0x2d, 0x84, 0xe7, 0x43, 0x88, 0xd3, 0x93, 0x73, 0x11,
	0xfe, 0x18, 0x4a, 0x0b, 0xab, 0x08, 0x26, 0x36, 0x6c, 0x65, 0xae, 0x90, 0xec, 0xf9, 0xac, 0xe7,
	0x45, 0x15, 0xc6, 0x85, 0x36, 0x23, 0x9c, 0xcf, 0x71, 0x32, 0x4d, 0xd3, 0x49, 0x06, 0xe4, 0x4b,
	0xb8, 0x39, 0x71, 0x31, 0x25, 0x93, 0x5b, 0x70, 0xcc, 0xfb, 0x72, 0x11, 0x0a, 0xf9, 0x09, 0x6c,
	0x1e, 0x8d, 0xb0, 0x97, 0xf5, 0xa0, 0xdf, 0xc7, 0xed, 0x2a, 0x92, 0xda, 0xe3, 0xc1, 0x2b, 0xaf,
	0xc8, 0xa4, 0x09, 0x80, 0xc9, 0xd6, 0x25, 0x2c, 0xa1, 0x02, 0x3b, 0x72, 0x04, 0x4a, 0xc4, 0xb8,
	0x4f, 0x3e, 0x6e, 0x62, 0xee, 0x67, 0x6a, 0x62, 0x82, 0x1f, 0xb9, 0x03, 0xeb, 0xec, 0x65, 0x66,
	0x70, 0x3c, 0xa4, 0x27, 0x72, 0x99, 0xf2, 0x15, 0xe4, 0x31, 0x28, 0x39, 0x40, 0x83, 0x1d, 0xcb,
	0x40, 0xdd, 0x1b, 0xd9, 0xde, 0x58, 0x2c, 0x3c, 0x63, 0x61, 0x0e, 0x8d, 0x4e, 0x10, 0x56, 0xff,
	0x4d, 0x09, 0x94, 0xe2, 0x67, 0xc2, 0xb9, 0x37, 0x94, 0xbd, 0x95, 0x73, 0x8f, 0xfb, 0xea, 0x59,
	0x18, 0x69, 0xa4, 0x91, 0x95, 0x0b, 0xcc, 0xe4, 0x22, 0x67, 0x01, 0x68, 0xbb, 0xf1, 0xa9, 0x88,
	0xc5, 0x54, 0x4f, 0x60, 0x25, 0x05, 0xa1, 0x1a, 0x3b, 0xc6, 0x82, 0x6c, 0x4f, 0x14, 0xb0, 0xa1,
	0x01, 0x7b, 0x19, 0xff, 0xf4, 0x0d, 0x21, 0x75, 0xf5, 0x2f, 0x96, 0xe0, 0xf6, 0xab, 0xbe, 0x0a,
	0x69, 0xc2, 0x7a, 0x72, 0x8b, 0x2c, 0x7b, 0x81, 0xee, 0x9d, 0x59, 0x39, 0xa3, 0xe3, 0x82, 0xb0,
	0x62, 0x73, 0xc4, 0x13, 0x52, 0x14, 0x0e, 0x4a, 0x0e, 0x56, 0xfd, 0x57, 0x25, 0xd8, 0xc8, 0x5f,
	0x70, 0x22, 0xdf, 0x83, 0xf5, 0xe8, 0x34, 0x18, 0x46, 0x76, 0x70, 0xc2, 0xe2, 0xd3, 0xa2, 0xd7,
	0x97, 0xaf, 0x23, 0x77, 0x60, 0x2d, 0x49, 0xc4, 0x9d, 0xc8, 0x92, 0xcc, 0xd5, 0x90, 0x8f, 0x61,
	0x2b, 0x49, 0x50, 0x6d, 0x8d, 0xa2, 0x98, 0xdb, 0x86, 0x79, 0x67, 0x6c, 0xb2, 0x1e, 0xb5, 0xad,
	0xe7, 0xb2, 0xbe, 0x4c, 0x60, 0x1d, 0x6b, 0x5b, 0x01, 0x44, 0x67, 0xdf, 0x63, 0x3d, 0x26, 0x12,
	0x34, 0x17, 0xb2, 0xce, 0x7e, 0x0a, 0xae, 0xfe, 0x32, 0x6c, 0xe4, 0xef, 0x5c, 0x91, 0x47, 0x70,
	0xcd, 0x4d, 0x34, 0xf0, 0x5e, 0x10, 0xb6, 0x93, 0x6f, 0x92, 0x0b, 0x17, 0x4c, 0x47, 0x41, 0xfd,
	0x8e, 0x5e, 0x4f, 0xcf, 0x12, 0xee, 0x1b, 0xf3, 0x0a, 0xfa, 0x3d, 0x5f, 0x59, 0xfd, 0x07, 0x25,
	0xd8, 0x9a, 0xb8, 0x87, 0x40, 0x1e, 0xc0, 0x4e, 0xdf, 0x7d, 0xe9, 0xf7, 0x47, 0x7d, 0x59, 0xe7,
	0x0f, 0x4e, 0x3a, 0x03, 0x3f, 0x8e, 0xf8, 0xf7, 0x2e, 0xd3, 0x19, 0xb5, 0xe4, 0x11, 0x54, 0xd2,
	0x5e, 0x15, 0x29, 0xcb, 0x9c, 0x72, 0x66, 0x3d, 0x79, 0x08, 0xd7, 0x93, 0x9b, 0x09, 0x45, 0x52,
	0x91, 0x25, 0x3a, 0xab, 0xba, 0xfa, 0x67, 0xd7, 0x60, 0x7b, 0xda, 0x65, 0x07, 0x72, 0x17, 0x48,
	0xf1, 0xb2, 0x83, 0x9e, 0xac, 0x9d, 0x29, 0x35, 0x22, 0x52, 0xea, 0x86, 0x31, 0xcf, 0x1a, 0x13,
	0x3b, 0xc5, 0x18, 0x80, 0x1b, 0xb1, 0x97, 0x64, 0xdb, 0x88, 0xfc, 0xbb, 0xb4, 0x4c, 0x3c, 0xd8,
	0x4c, 0xce, 0x61, 0x6d, 0x7e, 0x93, 0xeb, 0xbc, 0x32, 0x7f, 0x91, 0x57, 0x36, 0xad, 0xbb, 0xe9,
	0xd9, 0xae, 0xe4, 0x40, 0x8b, 0x2c, 0xc9, 0x2f, 0xc2, 0x7a, 0x70, 0x7c, 0xcc, 0x42, 0x54, 0x8b,
	0x3d, 0x37, 0x8a, 0x2a, 0x0b, 0xbc, 0x8d, 0x87, 0xdf, 0xa2, 0x0d, 0x33, 0x4b, 0x4f, 0xf3, 0xec,
	0xc8, 0xcf, 0xc3, 0x5a, 0x02, 0x90, 0xd9, 0x7c, 0xe5, 0xd9, 0x47, 0x75, 0x17, 0xb2, 0x17, 0xf9,
	0xde, 0x59, 0x66, 0xe4, 0x3d, 0x50, 0xe4, 0xb7, 0xe7, 0x59, 0xcd, 0xcf, 0x71, 0x75, 0x89, 0x3c,
	0xc0, 0x09, 0x38, 0x31, 0x61, 0x79, 0xd8, 0x73, 0xe3, 0xe3, 0x20, 0xec, 0x57, 0x96, 0x79, 0x27,
	0x3e, 0xfe, 0x16, 0x9d, 0x68, 0x4b, 0x52, 0x9a, 0x32, 0xc1, 0x3d, 0x7c, 0x30, 0xea, 0x1f, 0xb1,
	0xd0, 0x3c, 0x96, 0x47, 0xff, 0x95, 0x95, 0xdb, 0xe5, 0x3b, 0x0b, 0xb4, 0x08, 0x26, 0xf7, 0xe0,
	0x6a, 0x01, 0xd4, 0x89, 0xf8, 0xc1, 0x62, 0xf9, 0x4e, 0x89, 0x4e, 0xab, 0xc2, 0x59, 0x73, 0xec,
	0xbf, 0x64, 0x5e, 0x3d, 0x88, 0xe2, 0xca, 0x2a, 0xc7, 0x1b, 0x03, 0xb0, 0x96, 0x1f, 0x92, 0xf2,
	0xda, 0x35, 0x51, 0x9b, 0x02, 0x44, 0x66, 0x64, 0x77, 0x14, 0xf2, 0x6f, 0x80, 0x18, 0xeb, 0x1c,
	0x23, 0x0f, 0x24, 0x3b, 0xb0, 0x28, 0xee, 0x53, 0x54, 0x36, 0xb8, 0x8d, 0x23, 0x4b, 0xdc, 0xba,
	0x91, 0x03, 0xaf, 0x07, 0xa3, 0x41, 0x5c, 0xd9, 0xe4, 0x63, 0xca, 0x03, 0x33, 0x99, 0x3c, 0xed,
	0xf4, 0xbe, 0xa4, 0xc2, 0xf9, 0x4c, 0xc0, 0x91, 0x23, 0xbf, 0x2a, 0xc5, 0x3c, 0xab, 0x1b, 0xe0,
	0x26, 0xbe, 0xc5, 0x55, 0x72, 0x1e, 0x88, 0x32, 0x1a, 0x8e, 0xc2, 0xee, 0xa9, 0x8b, 0x6b, 0x50,
	0x4d, 0x32, 0x5c, 0xf8, 0x2d, 0xcb, 0x15, 0x3a, 0xad, 0x8a, 0xdc, 0x82, 0xc5, 0xe8, 0xd4, 0x0d,
	0x99, 0x57, 0xb9, 0x9a, 0x51, 0x61, 0x12, 0x46, 0xee, 0xc3, 0x76, 0xd2, 0x65, 0xcb, 0xff, 0x86,
	0xed, 0xf5, 0xd8, 0x4b, 0x1f, 0x15, 0xe6, 0x36, 0x3f, 0xad, 0x9d, 0x5a, 0x37, 0x5e, 0xdb, 0x7c,
	0x01, 0x9a, 0xa1, 0xb8, 0xde, 0x70, 0x2d, 0xbb, 0xb6, 0xb3, 0x35, 0xe4, 0x3e, 0x6c, 0x25, 0xb3,
	0xc1, 0x39, 0x4e, 0x1a, 0xd8, 0xc9, 0xaa, 0x46, 0x25, 0xa9, 0x4f, 0xda, 0xa8, 0x7d, 0x06, 0x9b,
	0x85, 0x35, 0xc9, 0xfd, 0x7c, 0x99, 0xc9, 0x30, 0x71, 0xbe, 0xb0, 0x0c, 0xf3, 0x07, 0xa6, 0x65,
	0x2b, 0x73, 0xb5, 0xbb, 0xb0, 0x9e, 0x5b, 0x68, 0x64, 0x0d, 0x96, 0x2d, 0x5b, 0x35, 0x1a, 0x2a,
	0x6d, 0x28, 0x25, 0xb2, 0x09, 0xab, 0x75, 0xd3, 0x38, 0xd4, 0xa8, 0xad, 0xef, 0x36, 0x35, 0xa5,
	0x5c, 0x6b, 0xc0, 0x5a, 0x76, 0xe5, 0x20, 0x82, 0xda, 0x6c, 0x3a, 0x69, 0xd8, 0x82, 0x5c, 0x85,
	0xcd, 0xb6, 0x4a, 0x6d, 0x5d, 0x1d, 0x03, 0xcb, 0x64, 0x03, 0xc0, 0x30, 0xd3, 0xf2, 0x5c, 0xed,
	0x8f, 0x4a, 0xb0, 0x9c, 0xcc, 0x7d, 0x1e, 0xf5, 0x30, 0x1e, 0x1b, 0xe6, 0x13, 0x43, 0x29, 0x91,
	0x15, 0x58, 0x68, 0xea, 0x46, 0xe7, 0xa9, 0xe8, 0x24, 0x3d, 0xd0, 0x9a, 0xca, 0x1c, 0xfe, 0xb2,
	0x3a, 0x96, 0xa6, 0xcc, 0x23, 0xee, 0x13, 0xdd, 0x68, 0x98, 0x4f, 0x2c, 0x65, 0x81, 0xbc, 0x06,
	0x37, 0x64, 0xc1, 0x79, 0xa2, 0xdb, 0x07, 0x8e, 0xf5, 0x55, 0xd3, 0x49, 0xfb, 0xbe, 0x48, 0x2a,
	0xb0, 0x3d, 0x51, 0xfd, 0x44, 0xdb, 0x55, 0x96, 0xc8, 0x3b, 0x50, 0x9b, 0x24, 0xd4, 0xe8, 0xa1,
	0x46, 0x1d, 0xcd, 0xb0, 0x35, 0xda, 0xa6, 0xba, 0xa5, 0x29, 0xcb, 0xe4, 0x26, 0x5c, 0xe7, 0x9d,
	0x99, 0xc2, 0x7e, 0x85, 0xec, 0x00, 0x29, 0x54, 0x22, 0x73, 0x20, 0x6f, 0xc3, 0xed, 0x22, 0xd1,
	0x04, 0xeb, 0xd5, 0xda, 0xdf, 0x5a, 0x01, 0x18, 0x5f, 0x38, 0x21, 0x00, 0x8b, 0xd6, 0x13, 0xdd,
	0xae, 0x1f, 0x28, 0x57, 0x90, 0xf1, 0xa1, 0x4e, 0xed, 0x8e, 0xda, 0x74, 0x1a, 0xaa, 0xad, 0xd6,
	0x39, 0x9d, 0x08, 0xf1, 0x58, 0xb6, 0x49, 0xd5, 0x7d, 0x4d, 0x29, 0xf3, 0x82, 0x46, 0x0f, 0xf5,
	0xba, 0xa6, 0xcc, 0xa1, 0xcc, 0x11, 0x73, 0x57, 0xb5, 0x34, 0xd9, 0x98, 0x10, 0x95, 0xa5, 0x1e,
	0xea, 0xc6, 0x3e, 0x8a, 0x6a, 0x0d, 0x96, 0xcd, 0xb6, 0x46, 0x55, 0xdb, 0xa4, 0xca, 0x22, 0x7e,
	0x8e, 0x27, 0xda, 0x6e, 0x82, 0xba, 0x84, 0x1f, 0x91, 0xea, 0xfb, 0x07, 0xb6, 0x63, 0xe9, 0xcf,
	0x35, 0xaa, 0x2c, 0x93, 0x2a, 0xec, 0xd8, 0x07, 0x54, 0xd3, 0x1c, 0x5b, 0xd7, 0xa8, 0xa3, 0xb6,
	0xdb, 0x4d, 0x9c, 0x3a, 0xba, 0x69, 0x28, 0x2b, 0xd8, 0x58, 0xd2, 0xbd, 0x96, 0x5a, 0x3f, 0xd0,
	0x0d, 0x4d, 0x01, 0xe4, 0xd8, 0xd0, 0xad, 0xc7, 0x8e, 0x4a, 0xa9, 0xfa, 0x4c, 0x59, 0xe5, 0xe5,
	0x71, 0xdf, 0xd7, 0x08, 0x81, 0x0d, 0xdd, 0xd8, 0xa3, 0xaa, 0x65, 0xd3, 0x4e, 0xdd, 0xee, 0x50,
	0x4d, 0x59, 0x27, 0xdb, 0xa0, 0xb4, 0x0f, 0x9e, 0x59, 0x7a, 0x3d, 0xc3, 0x69, 0x03, 0xbb, 0x5d,
	0x3f, 0x50, 0x2d, 0x4b, 0xb7, 0x94, 0x4d, 0x72, 0x0d, 0xb6, 0xc4, 0x09, 0xa6, 0x6e, 0xec, 0x3b,
	0xc9, 0x78, 0x15, 0xb2, 0x05, 0xeb, 0xbb, 0x1d, 0x4b, 0x37, 0x34, 0xcb, 0x72, 0x3a, 0x96, 0x46,
	0x95, 0x2d, 0x14, 0x9a, 0x14, 0x8e, 0x53, 0x37, 0x0d, 0x9b, 0x9a, 0xcd, 0xa6, 0x46, 0x15, 0x82,
	0x1c, 0x0e, 0x9e, 0xb5, 0x91, 0xd2, 0x32, 0x69, 0x32, 0xe2, 0xab, 0x38, 0x88, 0x94, 0x83, 0x66,
	0xd8, 0xba, 0xfd, 0x4c, 0xd9, 0xc6, 0x45, 0xa2, 0x9b, 0x4e, 0xcb, 0x6c, 0x74, 0x9a, 0x9a, 0x72,
	0x0d, 0xfb, 0xac, 0xd6, 0x71, 0xd0, 0x4e, 0x4b, 0x35, 0xd4, 0x7d, 0x8d, 0x2a, 0x3b, 0x38, 0x13,
	0x0f, 0x9b, 0xaa, 0xa1, 0x5c, 0xc7, 0x06, 0x33, 0x72, 0x49, 0x38, 0x57, 0x50, 0xd2, 0x09, 0x67,
	0xe5, 0x06, 0xb9, 0x0e, 0x57, 0x13, 0x61, 0x65, 0xa5, 0x58, 0xc5, 0x0a, 0x43, 0xb3, 0x9f, 0x98,
	0xf4, 0x31, 0x0e, 0x4d, 0x33, 0x1a, 0x6d, 0x53, 0x37, 0x6c, 0xe5, 0x26, 0x4a, 0x25, 0xed, 0x99,
	0x5a, 0xaf, 0x9b, 0x1d, 0xc3, 0x56, 0x6e, 0x91, 0x45, 0x28, 0xeb, 0x6d, 0xe5, 0x35, 0x9c, 0x91,
	0x52, 0x0c, 0xb2, 0xdb, 0x8e, 0xad, 0xb5, 0xda, 0x4d, 0xd5, 0xd6, 0x94, 0xd7, 0xb1, 0x73, 0x6d,
	0x93, 0xda, 0xca, 0x1b, 0x28, 0x44, 0xc9, 0x5d, 0xb9, 0xcd, 0x97, 0x68, 0xa6, 0xed, 0x37, 0x11,
	0x60, 0x1f, 0xe8, 0xe9, 0xc0, 0x6b, 0xd8, 0x66, 0xdd, 0x6c, 0xb5, 0x3b, 0xb6, 0xe6, 0x50, 0xcd,
	0x32, 0x3b, 0xb4, 0xae, 0x29, 0x6f, 0x91, 0x25, 0x98, 0x6b, 0xa9, 0x75, 0xe5, 0x6d, 0x1c, 0x92,
	0x8e, 0xdf, 0xd1, 0xd0, 0x6c, 0xe5, 0x3b, 0xb8, 0x42, 0x5b, 0x26, 0x8e, 0xf5, 0x1d, 0xf2, 0x26,
	0xbc, 0xd6, 0xd0, 0x2d, 0x9b, 0xea, 0xbb, 0x1d, 0x5b, 0x6b, 0x38, 0xc9, 0x48, 0xb1, 0x13, 0xfb,
	0xd4, 0xec, 0xb4, 0x95, 0x77, 0x51, 0xa6, 0xf8, 0x3d, 0x54, 0xdd, 0xd0, 0xa8, 0x72, 0x07, 0xbf,
	0x5c, 0x5a, 0x74, 0xda, 0x66, 0x43, 0xf9, 0x2e, 0x51, 0x60, 0xad, 0x69, 0xee, 0xf3, 0x59, 0xd0,
	0x36, 0xcd, 0xa6, 0xf2, 0x1e, 0x47, 0x6a, 0x9a, 0x9d, 0x46, 0xfa, 0xc5, 0xbf, 0x87, 0x43, 0x6b,
	0x20, 0xfa, 0xfb, 0xfc, 0x0b, 0xe0, 0xaf, 0x0f, 0xb0, 0x5b, 0xc9, 0xac, 0x57, 0xee, 0x22, 0x51,
	0xd3, 0x54, 0x1b, 0xce, 0xae, 0xda, 0x54, 0x8d, 0xba, 0x46, 0x95, 0x0f, 0x51, 0x01, 0x8c, 0x45,
	0x99, 0x91, 0xc0, 0x3d, 0xfc, 0xb4, 0x6d, 0x6a, 0xd6, 0x35, 0x0b, 0x27, 0x05, 0x6f, 0xf5, 0x23,
	0x84, 0x25, 0x33, 0xe8, 0xd0, 0x6c, 0x76, 0x5a, 0x9a, 0x72, 0x1f, 0x67, 0x4f, 0x72, 0x0e, 0xeb,
	0x88, 0xf0, 0x6a, 0x5d, 0x53, 0x3e, 0x26, 0x6f, 0xc1, 0x1b, 0x13, 0x60, 0xc7, 0x6a, 0x6b, 0x75,
	0x7d, 0x2f, 0x69, 0xe3, 0x13, 0xd4, 0x4e, 0x0d, 0xcd, 0xd2, 0xa9, 0xd6, 0x70, 0x26, 0x79, 0x7c,
	0x8a, 0x2b, 0x9e, 0x6a, 0xfb, 0x88, 0xfa, 0x00, 0x9b, 0x51, 0x0f, 0x55, 0xbd, 0xa9, 0xee, 0xea,
	0x4d, 0xfc, 0xa6, 0xcf, 0x4d, 0x43, 0x53, 0x3e, 0x43, 0xc9, 0x24, 0x9f, 0x05, 0xd7, 0xa1, 0xf2,
	0x10, 0x21, 0x49, 0x1f, 0x39, 0xe4, 0x73, 0x1c, 0x76, 0xba, 0xf4, 0x39, 0xe8, 0x11, 0x0e, 0xbb,
	0xa0, 0x0d, 0x44, 0xcd, 0xf7, 0x71, 0x88, 0xc9, 0x37, 0x92, 0x43, 0xfc, 0x02, 0xa5, 0x78, 0xa8,
	0x6b, 0x4f, 0xf8, 0xc7, 0xf8, 0x39, 0x6c, 0xa0, 0xa1, 0x59, 0x8f, 0x6d, 0xb3, 0x2d, 0xc4, 0xf2,
	0x03, 0xb2, 0x36, 0xd6, 0xce, 0x7f, 0xb4, 0x59, 0xb3, 0x01, 0xc6, 0xaf, 0x42, 0xf0, 0xe8, 0x71,
	0xfa, 0x2e, 0x84, 0xd8, 0x2d, 0xd2, 0xf2, 0xde, 0x9e, 0x52, 0xc6, 0xaf, 0x6f, 0x75, 0xac, 0xb6,
	0x66, 0x34, 0x92, 0x3c, 0x3b, 0x5e, 0x6f, 0xd9, 0xaa, 0xad, 0x39, 0x09, 0xdb, 0xf9, 0x9a, 0x06,
	0xd7, 0x67, 0x24, 0xff, 0x8b, 0xac, 0x1d, 0xbd, 0x71, 0x4f, 0xb9, 0x92, 0xfc, 0xfc, 0x48, 0xec,
	0x12, 0xf8, 0xf3, 0x53, 0x65, 0x21, 0xf9, 0xf9, 0x40, 0x59, 0xac, 0xfd, 0xcd, 0x52, 0x7a, 0x5b,
	0x8a, 0x2b, 0xd5, 0x2d, 0x58, 0xdf, 0xd7, 0x0c, 0x8d, 0xea, 0x75, 0x67, 0xb7, 0x69, 0xd6, 0x1f,
	0x0b, 0x42, 0xdd, 0xaa, 0x5b, 0xba, 0x52, 0xc6, 0xda, 0x3d, 0x7d, 0x57, 0xa3, 0x4e, 0xfd, 0x40,
	0x35, 0x8c, 0x64, 0x9f, 0xd9, 0xab, 0x9b, 0xb8, 0xcf, 0x00, 0x2c, 0x9a, 0xbb, 0x3f, 0xd2, 0xea,
	0xb6, 0xb2, 0x80, 0x4b, 0x35, 0x61, 0xb3, 0xa7, 0x37, 0x35, 0xc7, 0x7a, 0x66, 0xd9, 0x5a, 0x4b,
	0x59, 0xc4, 0x05, 0x62, 0xec, 0x59, 0xca, 0x12, 0xca, 0xb0, 0xae, 0xef, 0x59, 0x8e, 0xd5, 0xda,
	0x55, 0x96, 0xf9, 0x16, 0x66, 0xd6, 0xd5, 0xa6, 0xb2, 0x82, 0x3f, 0x4d, 0xfb, 0x40, 0xa3, 0x0a,
	0xf0, 0x79, 0xdb, 0xda, 0xb3, 0x94, 0x55, 0xfe, 0xcb, 0x52, 0x0d, 0x65, 0xad, 0xf6, 0xcb, 0x69,
	0x42, 0x71, 0x21, 0x07, 0x41, 0xae, 0x13, 0x9e, 0xa9, 0x28, 0xe6, 0x53, 0x89, 0x2f, 0x01, 0xdd,
	0x7a, 0x2c, 0xb2, 0x03, 0x2c, 0x43, 0x6d, 0x5b, 0x07, 0xa6, 0x2d, 0xb2, 0x03, 0x5a, 0x5a, 0xcb,
	0xa4, 0xcf, 0x94, 0x79, 0xbe, 0x51, 0x3e, 0x51, 0xdb, 0xca, 0x02, 0x4f, 0x84, 0x32, 0xf7, 0x45,
	0x27, 0x75, 0xcb, 0x54, 0x96, 0xf0, 0x63, 0x69, 0xd6, 0xd3, 0xba, 0x69, 0x58, 0x66, 0x53, 0x53,
	0x96, 0x6b, 0xcf, 0x41, 0x29, 0xa6, 0x68, 0x22, 0xbd, 0x81, 0x73, 0x8f, 0xe7, 0x4f, 0x1d, 0x34,
	0x1a, 0x22, 0x7f, 0xca, 0xb2, 0xf0, 0xe3, 0xad, 0xc1, 0xb2, 0x71, 0xd8, 0xd2, 0x1c, 0x2c, 0xcd,
	0xe3, 0x97, 0x55, 0x9f, 0x77, 0xa8, 0xe6, 0x20, 0x16, 0x8c, 0x8b, 0x58, 0xbb, 0x5a, 0xbb, 0x0b,
	0x6b, 0xd9, 0x3c, 0x14, 0x54, 0x30, 0xc5, 0x4c, 0x14, 0x31, 0x22, 0xf5, 0xa0, 0xb3, 0xab, 0x94,
	0x6b, 0x1f, 0x4f, 0x39, 0x2a, 0xa4, 0x41, 0x8f, 0xa7, 0x4c, 0x24, 0xc7, 0x96, 0x4a, 0x09, 0x4b,
	0x6d, 0x6a, 0x36, 0x3a, 0xb8, 0xbc, 0xcb, 0xb5, 0x9f, 0xc0, 0xed, 0x57, 0x1d, 0xae, 0xa1, 0x9e,
	0x57, 0x9b, 0xf8, 0x35, 0xb8, 0x92, 0xe6, 0x53, 0xba, 0x84, 0xc2, 0x6d, 0xab, 0xcf, 0x1c, 0xd5,
	0x72, 0x9e, 0x99, 0x1d, 0x67, 0xdf, 0x54, 0xca, 0xd8, 0x41, 0xb1, 0x48, 0x33, 0x88, 0x73, 0xb5,
	0x0f, 0x44, 0x40, 0x94, 0xf7, 0x64, 0x03, 0x80, 0x9a, 0x4d, 0xcd, 0xa9, 0xab, 0xf5, 0x03, 0x4d,
	0x30, 0x91, 0xe5, 0xb6, 0x5a, 0x47, 0x35, 0x5a, 0xae, 0xfd, 0x5a, 0x09, 0xd6, 0xf5, 0x4c, 0x4c,
	0x2f, 0xe2, 0x7a, 0xb8, 0xd3, 0xe2, 0x42, 0x29, 0xe1, 0xea, 0xc3, 0xc2, 0x67, 0xf7, 0xef, 0xdd,
	0x73, 0xf0, 0x4b, 0x5a, 0x62, 0x12, 0x22, 0xec, 0xa3, 0x7b, 0x8f, 0x25, 0x68, 0x2e, 0x05, 0x7d,
	0x9a, 0x80, 0xe6, 0x51, 0x3f, 0x20, 0xe8, 0xd0, 0xd2, 0xa8, 0xae, 0x59, 0x12, 0xbc, 0x80, 0xcb,
	0x09, 0xc1, 0xba, 0xd9, 0xb6, 0x32, 0xf9, 0xaf, 0x8b, 0xb5, 0x47, 0xb0, 0x96, 0x7d, 0x91, 0x46,
	0x6e, 0xce, 0xf2, 0x4d, 0x1a, 0xb1, 0x08, 0xda, 0xd4, 0x7c, 0xfa, 0x4c, 0x29, 0xf3, 0x9d, 0x5f,
	0x6b, 0x37, 0xd5, 0xba, 0xa6, 0xa2, 0x7d, 0x37, 0xb7, 0xbb, 0x0e, 0xab, 0xe2, 0x15, 0x1c, 0x9e,
	0x25, 0xb1, 0x7b, 0x0d, 0xae, 0x26, 0x37, 0x82, 0x33, 0xe0, 0xda, 0xbf, 0xe0, 0xbe, 0x78, 0x21,
	0x5d, 0x9b, 0xfc, 0x42, 0x1a, 0x7e, 0xf4, 0x59, 0xe8, 0x0c, 0x92, 0x48, 0x67, 0xc1, 0x25, 0x9a,
	0xa0, 0x9b, 0x84, 0xa0, 0xf0, 0xe8, 0x86, 0x9f, 0x2b, 0x93, 0xef, 0x82, 0x92, 0xe1, 0x9e, 0x4d,
	0x2f, 0xca, 0xb4, 0xca, 0xa3, 0xa4, 0xb5, 0x2f, 0xe0, 0xda, 0x54, 0x9e, 0xdc, 0x0c, 0xda, 0xdb,
	0xd3, 0xa8, 0xa3, 0xa3, 0x1c, 0xae, 0xc1, 0x96, 0x66, 0xa0, 0xa5, 0xd0, 0xd2, 0x0c, 0xdb, 0x31,
	0x3a, 0xad, 0x5d, 0x3e, 0xaf, 0xfe, 0xd9, 0xdb, 0xb0, 0x96, 0x8d, 0x0c, 0xfd, 0x31, 0x87, 0x92,
	0x64, 0x0a, 0x51, 0x79, 0x9c, 0x42, 0x44, 0x60, 0x7e, 0x14, 0xa5, 0x11, 0x7f, 0xfe, 0x9b, 0xdc,
	0x86, 0xd5, 0x8c, 0x6b, 0xc0, 0x43, 0x36, 0x25, 0x9a, 0x05, 0xe5, 0xa2, 0xed, 0x0b, 0xf9, 0x03,
	0x08, 0xb2, 0x0d, 0x0b, 0x3d, 0xbf, 0xef, 0xc7, 0xfc, 0xd4, 0xb8, 0x44, 0x45, 0x81, 0x27, 0x82,
	0x30, 0xf7, 0x85, 0xcc, 0x9b, 0xe5, 0xbf, 0xd1, 0xdd, 0x71, 0xc5, 0x1d, 0x92, 0xe5, 0xac, 0xbb,
	0x23, 0x60, 0xe4, 0x2d, 0x58, 0x09, 0x59, 0xe4, 0x7f, 0xc3, 0x83, 0x42, 0x2b, 0x59, 0x17, 0x64,
	0x0c, 0x2f, 0x9e, 0x69, 0xc0, 0xe4, 0x99, 0x46, 0x05, 0xe6, 0xe3, 0x53, 0x7f, 0x20, 0x72, 0x5a,
	0x65, 0x13, 0x1c, 0x42, 0xbe, 0x0b, 0x6b, 0xf2, 0xfd, 0x01, 0x8f, 0x3b, 0xaf, 0x6b, 0xd9, 0x36,
	0x72, 0x55, 0xe8, 0xf0, 0xa1, 0x64, 0xf4, 0x41, 0x37, 0x14, 0x21, 0xa6, 0x75, 0x3e, 0x8c, 0x3c,
	0x90, 0xa8, 0xb0, 0x34, 0x0c, 0x83, 0x61, 0xcb, 0x1d, 0x56, 0x36, 0x78, 0x1c, 0xf5, 0xdd, 0x99,
	0x5f, 0x69, 0x1c, 0x76, 0x6e, 0xfa, 0x51, 0x4c, 0x13, 0x3a, 0x1c, 0xb4, 0xcf, 0xfd, 0xe5, 0x76,
	0x17, 0xfd, 0xd4, 0xec, 0xa0, 0x53, 0x38, 0x79, 0x08, 0xd7, 0x47, 0xb1, 0xdf, 0xf3, 0xbf, 0x11,
	0x29, 0xae, 0xa7, 0x21, 0x8b, 0x4e, 0x83, 0x1e, 0x27, 0x51, 0x78, 0xbf, 0x66, 0x55, 0x13, 0x0a,
	0x9b, 0xf2, 0x8e, 0x44, 0x8b, 0xc5, 0x2e, 0xbf, 0x7f, 0xb5, 0x35, 0xf9, 0x98, 0x4b, 0xa1, 0xa7,
	0x39, 0x7c, 0x5a, 0x64, 0x80, 0x3c, 0x33, 0xcd, 0xf1, 0x7c, 0x01, 0xf2, 0x0a, 0x9e, 0x9d, 0x3c,
	0x3e, 0x2d, 0x32, 0x20, 0x9f, 0xc2, 0xf5, 0xbe, 0x3f, 0x48, 0x52, 0xd5, 0x8f, 0x83, 0xd0, 0x49,
	0x5e, 0x6b, 0xe2, 0x9e, 0x71, 0x89, 0x6e, 0xf7, 0xfd, 0x81, 0x48, 0x55, 0xdf, 0x0b, 0xc2, 0x24,
	0xf0, 0xc9, 0xc9, 0xdc, 0x97, 0x53, 0xc9, 0xb6, 0x25, 0x99, 0xfb, 0x72, 0x92, 0xcc, 0x02, 0x85,
	0x07, 0xa8, 0x1c, 0x8f, 0x0d, 0xd9, 0xc0, 0x63, 0x83, 0xee, 0x39, 0x77, 0x91, 0x2f, 0x1a, 0x02,
	0x45, 0x82, 0x46, 0x8a, 0x4f, 0x37, 0xc3, 0x3c, 0x80, 0x7c, 0x02, 0xd7, 0x86, 0x2c, 0xc4, 0x9d,
	0xc1, 0xef, 0xb1, 0xcc, 0x80, 0xb9, 0x37, 0x5d, 0xa2, 0xd3, 0x2b, 0xc9, 0x4f, 0x60, 0x3b, 0xc9,
	0xd3, 0x47, 0xcd, 0x37, 0xe8, 0x9e, 0xe7, 0x5e, 0x1a, 0xfa, 0xde, 0xcc, 0xfe, 0x48, 0xdb, 0xa3,
	0x29, 0x88, 0x92, 0x67, 0x77, 0xa2, 0x09, 0x28, 0xf9, 0x31, 0x5c, 0x2d, 0xdc, 0x20, 0xc8, 0x3e,
	0x3f, 0xf4, 0xde, 0xab, 0x1a, 0x10, 0xf7, 0x0a, 0x92, 0x57, 0x36, 0xa2, 0x22, 0x90, 0xfc, 0x02,
	0x5c, 0x3f, 0x4b, 0xf8, 0x0f, 0xdd, 0x30, 0xf6, 0x27, 0x1e, 0x24, 0xca, 0x5d, 0x1d, 0x3c, 0x4c,
	0x6e, 0x6c, 0x26, 0xa8, 0xe9, 0x4b, 0x3b, 0xd1, 0x94, 0x0a, 0xd2, 0x83, 0x4a, 0xca, 0x7c, 0x7c,
	0xc3, 0x36, 0xf7, 0x2c, 0xd1, 0x87, 0xaf, 0x1a, 0x41, 0xe6, 0x6a, 0x6e, 0xf2, 0x5c, 0x4d, 0x34,
	0xb5, 0x86, 0xa8, 0xb0, 0x72, 0xd6, 0x67, 0x7d, 0xc1, 0xfe, 0x1f, 0x95, 0x26, 0x7b, 0x9f, 0x63,
	0x7f, 0xd8, 0x12, 0x27, 0x6e, 0x07, 0x25, 0xba, 0x8c, 0x64, 0x29, 0x8b, 0xee, 0x70, 0x24, 0x58,
	0xfc, 0xe3, 0x57, 0xb2, 0xa8, 0x0f, 0x47, 0x29, 0x8b, 0xae, 0xf8, 0x5d, 0x3d, 0x83, 0xcd, 0xc2,
	0x64, 0x23, 0x2d, 0xd8, 0x38, 0x72, 0x23, 0xe6, 0xa4, 0xca, 0x5d, 0x1e, 0x95, 0x5e, 0x7a, 0x57,
	0x40, 0xea, 0x14, 0x84, 0x1a, 0x9b, 0xcf, 0x5e, 0x99, 0xee, 0x26, 0x0a, 0xd5, 0x2f, 0x78, 0xc0,
	0x3d, 0xa3, 0xa5, 0xd2, 0x84, 0x8b, 0x52, 0x26, 0xe1, 0x62, 0x07, 0x16, 0xf9, 0x76, 0x18, 0xa5,
	0x79, 0x53, 0xbc, 0x54, 0xfd, 0xcb, 0x65, 0x20, 0x93, 0x73, 0x92, 0x3c, 0x82, 0x4a, 0x92, 0x31,
	0x95, 0xde, 0xb7, 0x94, 0xf5, 0xf2, 0xd5, 0x86, 0x99, 0xf5, 0xe4, 0x01, 0xec, 0x14, 0xb2, 0xad,
	0x12, 0x4a, 0x1e, 0xbb, 0xa7, 0x33, 0x6a, 0xc9, 0x0f, 0xa0, 0x9a, 0xd4, 0x64, 0xae, 0x3c, 0x26,
	0xb4, 0xfc, 0xe8, 0x82, 0x5e, 0x80, 0x41, 0x0c, 0xa8, 0xcd, 0xae, 0xcd, 0xbd, 0xb6, 0xb0, 0x4c,
	0x2f, 0x81, 0x59, 0xfd, 0xdb, 0x25, 0xd8, 0x9a, 0x58, 0x4d, 0xfc, 0x7e, 0x65, 0x71, 0xe4, 0x68,
	0x5d, 0x49, 0xb1, 0x4c, 0xaf, 0xe4, 0x77, 0x8c, 0xf3, 0xa3, 0xe6, 0x34, 0x42, 0x20, 0xd3, 0xaa,
	0x70, 0xf3, 0x98, 0xd2, 0x47, 0x4e, 0x25, 0x44, 0x31, 0xab, 0xba, 0xfa, 0x25, 0xec, 0x4c, 0x5f,
	0x42, 0xe4, 0x1d, 0xd8, 0xc0, 0x9d, 0x50, 0xf5, 0x7e, 0x69, 0x14, 0xc5, 0xe9, 0x11, 0x4c, 0x89,
	0x16, 0xa0, 0xd5, 0xef, 0xc3, 0x72, 0xb2, 0x4a, 0xc8, 0x87, 0xb0, 0x79, 0x1a, 0xc4, 0xaa, 0xe7,
	0x8d, 0x8f, 0x60, 0x72, 0x07, 0x54, 0xc5, 0xda, 0xea, 0x5f, 0x2f, 0xc1, 0x72, 0xb2, 0x40, 0xbe,
	0x35, 0x35, 0xf9, 0x14, 0xc8, 0x69, 0x10, 0x53, 0xd6, 0x0f, 0xce, 0xd8, 0x8c, 0x43, 0x9f, 0x29,
	0x08, 0xd8, 0x8e, 0x1f, 0x51, 0xe6, 0xf2, 0x94, 0x7e, 0x16, 0xd6, 0x87, 0xa3, 0xfc, 0x59, 0x57,
	0xb1, 0xb6, 0xfa, 0x12, 0x36, 0x0b, 0x3b, 0x26, 0x61, 0x70, 0x5d, 0xee, 0x99, 0x07, 0xee, 0xc0,
	0xeb, 0x09, 0x73, 0x70, 0x9c, 0xd3, 0x54, 0x48, 0xa5, 0xac, 0x8f, 0xa2, 0x38, 0xe0, 0x67, 0xb9,
	0x0d, 0x76, 0x7c, 0x37, 0x61, 0x92, 0x92, 0xd0, 0x59, 0xbc, 0xaa, 0xbf, 0x0c, 0x9b, 0x85, 0x7d,
	0x15, 0x17, 0xf6, 0x30, 0xf0, 0xf9, 0xe7, 0x98, 0x43, 0x53, 0x8c, 0x17, 0xc8, 0x7d, 0xd8, 0xee,
	0xb9, 0x51, 0xdc, 0xc6, 0x82, 0xed, 0xf7, 0x59, 0x14, 0xbb, 0xfd, 0x61, 0x2b, 0x92, 0x47, 0x39,
	0x53, 0xeb, 0xc8, 0xeb, 0x00, 0x3e, 0xfa, 0x38, 0x67, 0x6e, 0x4f, 0xbe, 0xab, 0xb0, 0x40, 0x33,
	0x90, 0xda, 0x1f, 0x6c, 0xc0, 0x7a, 0x4e, 0xc7, 0xf0, 0x58, 0x5a, 0xb3, 0x63, 0xd9, 0x1a, 0x15,
	0xc9, 0x65, 0xf6, 0x01, 0xd5, 0xd4, 0x86, 0x25, 0x7c, 0x91, 0x7a, 0xbb, 0xe3, 0x8c, 0x7d, 0x23,
	0xe1, 0x03, 0x09, 0x1b, 0xd8, 0x49, 0x5c, 0x2e, 0x4b, 0xc4, 0x16, 0xf7, 0x9a, 0xe6, 0x93, 0x2c,
	0x2a, 0x8f, 0x2d, 0x7e, 0xf5, 0x91, 0x73, 0x58, 0x6f, 0x77, 0x84, 0x7f, 0x9c, 0x04, 0x25, 0xda,
	0xd4, 0x3c, 0xd4, 0x2d, 0xdd, 0x34, 0xd0, 0x0f, 0x19, 0x47, 0xef, 0x34, 0xa7, 0x6e, 0xb6, 0x5a,
	0x66, 0x03, 0xdd, 0xa4, 0xa5, 0x6c, 0xa0, 0x45, 0x6d, 0xf1, 0xf8, 0xd6, 0x32, 0x1a, 0xe6, 0x5f,
	0x7d, 0xf4, 0x40, 0x70, 0x5c, 0xe1, 0xa5, 0x8f, 0xef, 0x8b, 0x12, 0x90, 0x1b, 0x70, 0xcd, 0x52,
	0x5b, 0x9a, 0x23, 0x87, 0xe2, 0xb4, 0xcc, 0x43, 0xcd, 0xb1, 0x0e, 0xeb, 0xca, 0x2a, 0xef, 0xc7,
	0xc7, 0x02, 0x6f, 0x0d, 0x1d, 0x27, 0xab, 0xa9, 0x66, 0x9a, 0x5a, 0x27, 0x55, 0xd8, 0xa9, 0x53,
	0xd3, 0xb2, 0x26, 0x69, 0x37, 0x78, 0x04, 0xae, 0x30, 0x5c, 0xa7, 0xdd, 0x52, 0x36, 0xb3, 0xa1,
	0xc4, 0xcc, 0xa0, 0x15, 0xde, 0xd8, 0x43, 0xd1, 0xd8, 0x16, 0xfa, 0x50, 0x56, 0x5b, 0xad, 0x6b,
	0x0a, 0xe1, 0x70, 0xd9, 0xf5, 0xab, 0xdc, 0xb7, 0x32, 0x9f, 0x68, 0x54, 0xd9, 0xe6, 0xf1, 0x33,
	0xad, 0xa5, 0x5c, 0x43, 0x11, 0x26, 0x0c, 0x9b, 0xaa, 0xad, 0x19, 0xf5, 0x67, 0xca, 0x0e, 0xa7,
	0xfa, 0x4c, 0x50, 0x5d, 0xe7, 0x1f, 0xca, 0x34, 0x9b, 0xba, 0xb1, 0xaf, 0x54, 0x44, 0x14, 0x85,
	0xda, 0x3c, 0x2e, 0xa1, 0x35, 0x95, 0x1b, 0x3c, 0x60, 0x80, 0x78, 0x55, 0x4e, 0x64, 0x08, 0xa2,
	0x9b, 0xc8, 0x16, 0xbf, 0x61, 0x56, 0xe6, 0xb7, 0x50, 0xb8, 0xe3, 0x50, 0x2e, 0x1f, 0xe9, 0x6b,
	0x48, 0x8f, 0xe3, 0x56, 0x5e, 0xe7, 0xf4, 0x52, 0xae, 0x3c, 0x48, 0xf8, 0xd5, 0xa7, 0xa2, 0x70,
	0x9b, 0xc7, 0x14, 0x9e, 0xa8, 0xed, 0x36, 0x76, 0xe1, 0x4d, 0x1e, 0x67, 0xd2, 0xf6, 0xd1, 0x2d,
	0x12, 0x83, 0xaf, 0xf1, 0xd0, 0x48, 0xd3, 0x7c, 0xa2, 0xbc, 0xc5, 0x8f, 0x12, 0x54, 0x5b, 0xc5,
	0x11, 0x69, 0xca, 0xdb, 0xa4, 0x02, 0xdb, 0x89, 0x88, 0xcd, 0x4e, 0x63, 0x2c, 0xe0, 0xef, 0x60,
	0xff, 0x32, 0x5d, 0x69, 0x98, 0x4f, 0x0c, 0xe5, 0x1d, 0xfc, 0x48, 0xba, 0xe9, 0xd8, 0x07, 0xd4,
	0xec, 0xec, 0x1f, 0xb4, 0x3b, 0xb6, 0xf2, 0x2e, 0xca, 0x09, 0xfb, 0x70, 0x07, 0xfd, 0xd4, 0x5d,
	0x94, 0xb8, 0x69, 0x60, 0x2f, 0xbe, 0x8b, 0x15, 0x87, 0x8d, 0xba, 0xf2, 0x1e, 0x9f, 0x0f, 0x0f,
	0x3e, 0x11, 0x5d, 0xfd, 0x1e, 0xa2, 0xd5, 0x4d, 0xc3, 0xd0, 0x78, 0x6c, 0x56, 0x79, 0x1f, 0xdb,
	0x69, 0x69, 0xad, 0x9c, 0x1c, 0x3e, 0xc8, 0x06, 0xcb, 0xef, 0x72, 0xcf, 0x5b, 0xb3, 0xb3, 0xad,
	0x7e, 0x48, 0x6e, 0x41, 0x65, 0xe2, 0xf3, 0x27, 0x14, 0xf7, 0x78, 0x88, 0x94, 0xaa, 0x86, 0x25,
	0x02, 0xc0, 0x22, 0x3a, 0x88, 0x8d, 0x64, 0x26, 0xc4, 0x7d, 0x44, 0x6a, 0x58, 0xed, 0x96, 0xa3,
	0xd6, 0xeb, 0x9a, 0x65, 0x29, 0x1f, 0xf3, 0x98, 0x80, 0x66, 0xb5, 0x4d, 0x83, 0x07, 0xe3, 0x5a,
	0x9a, 0xf2, 0x89, 0x08, 0xfb, 0x68, 0x2d, 0xe5, 0x53, 0xac, 0x94, 0xe1, 0xe4, 0xb6, 0x46, 0x5b,
	0xba, 0xad, 0x3c, 0x28, 0x44, 0xc9, 0x3f, 0x2b, 0x46, 0x6a, 0x1f, 0x66, 0xe3, 0xb8, 0x9f, 0xf3,
	0xef, 0x25, 0x85, 0xf0, 0x28, 0x3b, 0xa7, 0x92, 0x25, 0xfe, 0x7d, 0x02, 0xb0, 0xa8, 0x3d, 0xe5,
	0x99, 0x9c, 0x5f, 0xe0, 0x6f, 0xd9, 0xaf, 0x9f, 0xe3, 0xfd, 0x1a, 0x7f, 0x89, 0x4e, 0x5b, 0xf9,
	0x01, 0x36, 0x75, 0xa8, 0xb6, 0xdb, 0x49, 0xdf, 0x7f, 0x98, 0x5b, 0x95, 0x02, 0xf6, 0x25, 0x8f,
	0x0d, 0x26, 0x32, 0x51, 0x51, 0x3f, 0x34, 0x50, 0x48, 0xd9, 0x89, 0xb1, 0x8b, 0xed, 0x34, 0x76,
	0x1d, 0x1c, 0x62, 0x1d, 0x3b, 0x95, 0x91, 0x9a, 0xd3, 0x34, 0xf7, 0x95, 0x06, 0x6a, 0x81, 0xc6,
	0xae, 0x08, 0x9b, 0x38, 0x07, 0xba, 0xed, 0x50, 0xd5, 0xd6, 0x14, 0x0d, 0x3b, 0x70, 0x60, 0xda,
	0xa9, 0xc8, 0xf7, 0xf8, 0x74, 0x36, 0x9b, 0x4d, 0xf1, 0x59, 0x85, 0xf8, 0xf6, 0x45, 0x34, 0x9c,
	0x7b, 0xec, 0xe3, 0x65, 0x7d, 0x40, 0x5e, 0x87, 0xaa, 0x65, 0xee, 0xd9, 0x4f, 0x54, 0xaa, 0x39,
	0x93, 0x1a, 0x46, 0xe7, 0x83, 0x6b, 0x8d, 0x3f, 0xcc, 0x8f, 0x70, 0x3e, 0x1f, 0x64, 0x35, 0xc3,
	0x63, 0x39, 0x25, 0x50, 0xb2, 0x4e, 0xdb, 0x6c, 0xea, 0xf5, 0x67, 0x4a, 0x93, 0x9f, 0x8a, 0x69,
	0x6a, 0x5b, 0x69, 0xf1, 0x3e, 0xa7, 0xc7, 0x19, 0x09, 0x1b, 0x83, 0x6b, 0x22, 0x19, 0x7d, 0x6f,
	0x6a, 0x87, 0x5a, 0x33, 0x15, 0xbd, 0xc9, 0x0f, 0x33, 0x44, 0x44, 0x59, 0x37, 0xf6, 0x9d, 0x8e,
	0xa1, 0xdb, 0x96, 0xd2, 0xc6, 0x31, 0x1d, 0x98, 0x96, 0xed, 0x34, 0x3b, 0x46, 0xc2, 0xe5, 0x2b,
	0x94, 0x58, 0xdd, 0xec, 0xb4, 0x4d, 0x43, 0xa1, 0xd8, 0x0d, 0x5b, 0x33, 0x54, 0xa3, 0x9e, 0xb6,
	0x62, 0x21, 0x2c, 0x19, 0x94, 0x84, 0xd9, 0x5c, 0xb2, 0x32, 0xd0, 0x9f, 0x00, 0x3b, 0x3c, 0x22,
	0xd7, 0x69, 0xf1, 0x70, 0x90, 0x72, 0x88, 0xbd, 0xe7, 0x71, 0xe3, 0x27, 0x3c, 0xe8, 0x55, 0xb7,
	0x75, 0x5c, 0x88, 0xd8, 0x1f, 0xd3, 0xb0, 0x94, 0xa7, 0x3c, 0x76, 0x66, 0x9a, 0x4d, 0x07, 0xa7,
	0xcf, 0xb3, 0xb4, 0x84, 0xdf, 0xed, 0x39, 0x8a, 0x87, 0x97, 0x92, 0x8f, 0xf1, 0xf3, 0xfc, 0x28,
	0xa4, 0xc5, 0x27, 0x57, 0xbb, 0xa3, 0xfc, 0xc2, 0xb8, 0x88, 0xf8, 0x3f, 0xe6, 0x8b, 0x98, 0x17,
	0x13, 0x82, 0x5f, 0x44, 0xa5, 0x99, 0x46, 0xc2, 0xb9, 0xe8, 0x70, 0xaa, 0x29, 0xce, 0x24, 0xdc,
	0x7e, 0xd6, 0xd6, 0x94, 0x9f, 0x88, 0x23, 0x1c, 0x6a, 0xd9, 0x49, 0xbc, 0x5e, 0x71, 0x73, 0x63,
	0xdc, 0x53, 0x5b, 0x7a, 0xf3, 0x99, 0x72, 0x84, 0xc2, 0x48, 0xa2, 0xe8, 0x52, 0x68, 0x5d, 0xec,
	0x2e, 0xae, 0x02, 0x87, 0x6a, 0x5f, 0x75, 0x34, 0xcb, 0x56, 0x3c, 0x0e, 0xc1, 0xe5, 0x99, 0x40,
	0x18, 0xd7, 0xfc, 0x63, 0x94, 0xec, 0xba, 0x3d, 0xc6, 0xba, 0x0c, 0x72, 0xb6, 0xee, 0x84, 0xdc,
	0x84, 0xeb, 0xc9, 0xbc, 0xe0, 0x67, 0x1e, 0x7b, 0x6a, 0x1d, 0xe7, 0x16, 0xee, 0x52, 0xa7, 0xfc,
	0x6c, 0x47, 0xaf, 0x37, 0xf5, 0xaf, 0x3a, 0x9a, 0xe2, 0xe7, 0x23, 0xe3, 0xbb, 0x0a, 0x6c, 0xa4,
	0xae, 0x80, 0x88, 0x9d, 0x29, 0xb0, 0x71, 0x1a, 0xc4, 0x3c, 0x4e, 0x22, 0xde, 0x50, 0xac, 0x7d,
	0x0a, 0xd7, 0xa6, 0x3a, 0x5b, 0xfc, 0x85, 0xe0, 0x04, 0x90, 0x5c, 0xfd, 0x49, 0x01, 0xb5, 0x5f,
	0xbd, 0x01, 0xcb, 0x22, 0xb3, 0xd3, 0x36, 0x89, 0x9a, 0x06, 0xe8, 0xe2, 0xf1, 0x13, 0x60, 0xdf,
	0xee, 0x59, 0xf0, 0x37, 0x61, 0x4d, 0x46, 0x67, 0x9c, 0xc1, 0x8c, 0x2c, 0xd4, 0x37, 0x00, 0x4e,
	0xb0, 0x45, 0x81, 0xc0, 0x6f, 0x14, 0x1d, 0x5c, 0xa1, 0x2b, 0x1c, 0xc6, 0x11, 0x0c, 0xd8, 0x44,
	0xbf, 0x3e, 0x0e, 0x5d, 0x7f, 0x10, 0x3b, 0xfe, 0xe0, 0x38, 0xa8, 0x4c, 0x79, 0x2c, 0x33, 0xe9,
	0x35, 0x7f, 0xf8, 0x59, 0xe0, 0xea, 0x83, 0xe3, 0xe0, 0xe0, 0x8a, 0x78, 0xfa, 0x79, 0x0c, 0x21,
	0x4f, 0xe1, 0x6a, 0xc4, 0x7a, 0x8c, 0xbf, 0x2d, 0xe7, 0x44, 0x43, 0xd6, 0x75, 0x7a, 0x7e, 0x14,
	0xcb, 0x57, 0x3a, 0xde, 0x99, 0xca, 0xd3, 0x4a, 0xf0, 0xad, 0x21, 0xeb, 0xa2, 0x73, 0x74, 0x50,
	0xa2, 0x5b, 0x51, 0x11, 0x48, 0xea, 0xb0, 0xda, 0x67, 0xfd, 0x23, 0x16, 0x0a, 0x8e, 0x8b, 0x93,
	0x99, 0xcc, 0x29, 0xc7, 0x16, 0xc7, 0x8b, 0x24, 0x2f, 0x10, 0x64, 0x9c, 0x49, 0x0f, 0x6e, 0xb8,
	0x9e, 0xc7, 0x3c, 0xc7, 0x1d, 0x78, 0x4e, 0xc8, 0x0d, 0x54, 0xcf, 0x11, 0xf5, 0x51, 0x65, 0xca,
	0xab, 0x90, 0x29, 0x4b, 0x15, 0xa9, 0xd4, 0x81, 0x27, 0x8c, 0x5a, 0x2f, 0xdf, 0xc2, 0x8e, 0x3b,
	0xb5, 0x96, 0x3f, 0x9a, 0xc3, 0x9f, 0x9b, 0x72, 0xc4, 0x47, 0xf0, 0x3d, 0x71, 0xb3, 0xf5, 0xa0,
	0x44, 0xd7, 0x33, 0xef, 0x50, 0xe9, 0xde, 0xd4, 0x27, 0xcf, 0x57, 0x7e, 0xa6, 0x27, 0xcf, 0xf3,
	0xcf, 0x51, 0xc3, 0xb7, 0x7f, 0x8e, 0x5a, 0x03, 0x31, 0x4d, 0x38, 0xfd, 0xea, 0x64, 0xfa, 0x70,
	0x2a, 0x9a, 0xfd, 0x04, 0xeb, 0xd1, 0x12, 0xd5, 0xf6, 0x3b, 0x4d, 0x95, 0xd2, 0x31, 0x25, 0xf9,
	0x1c, 0xb6, 0xfd, 0xa8, 0x2e, 0x9e, 0x93, 0x66, 0x83, 0x98, 0x3f, 0xa0, 0xe3, 0x0f, 0x4e, 0xf2,
	0x11, 0xc2, 0xa9, 0x28, 0xe4, 0x3e, 0xcc, 0xc7, 0xee, 0x49, 0x54, 0x59, 0x9f, 0xcc, 0x7d, 0x4e,
	0x1b, 0xb7, 0xdd, 0x93, 0x48, 0x5c, 0xb6, 0xe5, 0xb8, 0x68, 0xa6, 0x07, 0x5f, 0x0f, 0x58, 0x28,
	0x9f, 0x0a, 0x17, 0x85, 0xea, 0x9b, 0xb0, 0x62, 0xbb, 0x27, 0x3c, 0xa8, 0x1c, 0x8d, 0xef, 0x35,
	0x88, 0x9c, 0x5a, 0x79, 0xaf, 0xe1, 0x09, 0x47, 0x89, 0x66, 0x5d, 0x0f, 0xfd, 0x24, 0x7b, 0x3d,
	0xf4, 0x82, 0xce, 0x88, 0x36, 0x32, 0xd7, 0x47, 0xab, 0xff, 0x71, 0x4e, 0xa4, 0x13, 0x66, 0x16,
	0x49, 0x33, 0xb7, 0xe8, 0xe2, 0x71, 0x28, 0xfa, 0x55, 0x8b, 0x4e, 0x5c, 0x6b, 0xe9, 0xe6, 0xca,
	0xfc, 0xf5, 0x85, 0xcc, 0x12, 0x4e, 0xfe, 0x51, 0xc0, 0x5a, 0x66, 0x65, 0x7a, 0xe4, 0x36, 0x2c,
	0xfb, 0x91, 0x73, 0x34, 0x3a, 0x2f, 0x5e, 0xf7, 0x5a, 0xf2, 0xa3, 0x5d, 0x84, 0x92, 0x1f, 0xf1,
	0x94, 0x5d, 0x16, 0x3a, 0x7d, 0x16, 0xbb, 0x22, 0xc8, 0x32, 0x3f, 0xf9, 0xb6, 0x4e, 0xda, 0x29,
	0x4e, 0x94, 0x3e, 0x64, 0xbf, 0x7e, 0x94, 0x2d, 0x92, 0x4f, 0x80, 0x0c, 0x18, 0xf3, 0x9c, 0x6e,
	0xd0, 0x1f, 0xf6, 0x78, 0x40, 0xd7, 0x0d, 0xcf, 0x65, 0x36, 0x62, 0x92, 0xd9, 0x88, 0x08, 0xf5,
	0x6c, 0x3d, 0x79, 0x37, 0x27, 0x16, 0xae, 0xb1, 0x16, 0xc5, 0x63, 0x54, 0x63, 0x30, 0x57, 0x5a,
	0x9f, 0xc3, 0xf6, 0x71, 0x10, 0x6a, 0x2f, 0xbb, 0xbd, 0x91, 0x37, 0xbe, 0xa9, 0x26, 0x16, 0xf0,
	0x78, 0x4e, 0x4d, 0x43, 0x21, 0x0f, 0xe0, 0x7a, 0xa6, 0x8d, 0x9c, 0xfa, 0x14, 0x97, 0xce, 0xaf,
	0x8d, 0xab, 0x1b, 0x19, 0x45, 0xfa, 0x01, 0x10, 0x26, 0x99, 0x39, 0x31, 0xeb, 0x0f, 0x7b, 0x6e,
	0xcc, 0x92, 0x97, 0xe0, 0xb6, 0x92, 0x1a, 0x3b, 0xa9, 0xa8, 0xfe, 0x22, 0x6c, 0x4d, 0xa8, 0x35,
	0xa2, 0xc3, 0x46, 0x5e, 0x37, 0xca, 0xac, 0xfe, 0xda, 0xab, 0xd5, 0x22, 0x5d, 0xcf, 0x29, 0xc4,
	0xea, 0x77, 0x60, 0x35, 0xa3, 0x82, 0xc8, 0x0e, 0xbf, 0xe0, 0x71, 0xc4, 0x13, 0x53, 0x79, 0xe4,
	0x48, 0x94, 0xaa, 0xa7, 0x50, 0x9d, 0xad, 0xb8, 0x48, 0x0d, 0xd6, 0xb8, 0xe2, 0x92, 0x30, 0x49,
	0x9b, 0x83, 0x89, 0x07, 0xf7, 0xb2, 0x94, 0x32, 0x36, 0x55, 0x80, 0x56, 0x03, 0x58, 0xcf, 0xcd,
	0x08, 0xdc, 0xdf, 0x22, 0xc6, 0x9f, 0xa2, 0xfd, 0x76, 0xfb, 0x9b, 0x20, 0xe2, 0x13, 0xfb, 0x26,
	0x2c, 0xb9, 0xb1, 0xd3, 0x0f, 0x22, 0x91, 0x68, 0xbc, 0xf5, 0xa8, 0xfc, 0xc1, 0x47, 0x74, 0xd1,
	0x8d, 0x5b, 0x41, 0x14, 0x57, 0x7f, 0x6b, 0x09, 0xd6, 0x73, 0x22, 0x22, 0x55, 0x58, 0x4e, 0xf2,
	0x78, 0x65, 0x58, 0x2d, 0x2d, 0x93, 0xe7, 0xb0, 0xc9, 0x5e, 0x0e, 0x43, 0xf1, 0x54, 0x99, 0xe8,
	0x91, 0xb8, 0xc3, 0xf6, 0xd1, 0xab, 0x65, 0x7f, 0x57, 0x4b, 0x29, 0xc5, 0xfa, 0x63, 0xb9, 0x32,
	0x8f, 0x4e, 0xcb, 0x76, 0xc4, 0x71, 0x96, 0xe3, 0x05, 0xa3, 0xe4, 0xed, 0xd3, 0x12, 0x7f, 0x50,
	0x5d, 0x56, 0x73, 0xe5, 0xd0, 0xe0, 0x95, 0x53, 0xa8, 0xa2, 0x38, 0x44, 0xc5, 0x38, 0x2f, 0x37,
	0xe9, 0x3c, 0x95, 0xc5, 0x2b, 0x49, 0x0c, 0xd5, 0xa9, 0x54, 0xd9, 0x5d, 0xf6, 0xd3, 0x4b, 0x0c,
	0x29, 0xd9, 0x38, 0x04, 0x5b, 0xbe, 0x8d, 0x5d, 0xa1, 0xd7, 0xa7, 0xb4, 0xc8, 0x27, 0xca, 0x64,
	0xab, 0x62, 0x84, 0xd9, 0x9d, 0xf8, 0xdb, 0xb4, 0x2a, 0x44, 0x30, 0xb5, 0xd5, 0x71, 0x55, 0xf5,
	0xfb, 0x40, 0x26, 0xbb, 0x49, 0xbe, 0xc3, 0xff, 0xb7, 0x44, 0xa6, 0x2f, 0x72, 0xda, 0xae, 0xe7,
	0xd8, 0x64, 0x89, 0xc7, 0x2c, 0x67, 0x10, 0x97, 0x0a, 0xc4, 0xb5, 0xbf, 0x57, 0x86, 0x8d, 0xfc,
	0x47, 0x47, 0x93, 0x51, 0xfb, 0xaa, 0xa3, 0x36, 0x1d, 0xdb, 0x54, 0xae, 0xa0, 0x9d, 0x6a, 0x98,
	0xb6, 0x93, 0x42, 0x78, 0xca, 0x44, 0x53, 0xa5, 0xfb, 0x1a, 0x75, 0xec, 0x03, 0xd5, 0x50, 0xca,
	0x3c, 0xe7, 0x6c, 0x0c, 0x70, 0x4c, 0x3a, 0xc6, 0x9e, 0xe3, 0x7e, 0x79, 0x4b, 0x6d, 0x36, 0x13,
	0xf4, 0x79, 0x74, 0x63, 0xb3, 0x90, 0x1c, 0xfe, 0x82, 0x3c, 0x3e, 0xb7, 0x55, 0xdd, 0xb0, 0x94,
	0xc5, 0xa4, 0xf5, 0x14, 0xb2, 0x24, 0x32, 0x4c, 0x44, 0x3a, 0x4e, 0xc3, 0xd9, 0x7d, 0xa6, 0x2c,
	0xf3, 0x20, 0xd0, 0x18, 0x47, 0x40, 0x79, 0x1e, 0x03, 0xd5, 0xf6, 0xb5, 0xa7, 0x0a, 0xf0, 0x74,
	0x1d, 0xdd, 0xb2, 0x1d, 0xf3, 0x50, 0xa3, 0x4d, 0xb5, 0xad, 0xac, 0x8a, 0xc3, 0x7d, 0xcb, 0x76,
	0x90, 0x2e, 0x81, 0xae, 0x89, 0xf4, 0x38, 0xcb, 0x76, 0xf6, 0x3a, 0xcd, 0xe6, 0xb8, 0x49, 0x1e,
	0x92, 0x99, 0x80, 0x8b, 0x66, 0x36, 0x76, 0x37, 0xa1, 0x20, 0xd0, 0xbf, 0x56, 0x82, 0x95, 0xd4,
	0x4c, 0x40, 0x07, 0x58, 0x1a, 0x0a, 0xca, 0x15, 0xf9, 0x44, 0x82, 0xc8, 0x55, 0x2a, 0xf3, 0x28,
	0x84, 0x4c, 0x95, 0xe1, 0x0e, 0x57, 0xe2, 0x98, 0xcd, 0x91, 0xb7, 0xe0, 0x8d, 0xa4, 0xa6, 0x90,
	0xb6, 0x96, 0x22, 0xcd, 0x4f, 0xf3, 0xa6, 0x17, 0xd0, 0xf5, 0xd8, 0xd5, 0x9b, 0x4d, 0xf4, 0xe7,
	0xa4, 0x3b, 0xb2, 0x58, 0x9b, 0x5f, 0x2e, 0x29, 0xa5, 0xf7, 0x32, 0xc7, 0xe9, 0xb5, 0xdf, 0x29,
	0x65, 0xb7, 0x69, 0xde, 0xcf, 0x1b, 0x70, 0x6d, 0xb7, 0xf3, 0x4c, 0xa3, 0x8e, 0xa5, 0xf1, 0x0f,
	0xa3, 0xee, 0xed, 0xe9, 0x06, 0xba, 0x9d, 0x57, 0xd0, 0x73, 0xcd, 0x57, 0x19, 0xb6, 0x3e, 0xae,
	0x2f, 0x89, 0x94, 0x25, 0xac, 0x17, 0x7f, 0xd3, 0x9a, 0x32, 0x79, 0x0d, 0x6e, 0xe4, 0x6a, 0x72,
	0x84, 0x73, 0x64, 0x73, 0x1c, 0xea, 0x9b, 0xaf, 0x96, 0x97, 0xf9, 0x21, 0x7f, 0x4b, 0xa3, 0xfb,
	0x9a, 0xb2, 0x30, 0xdb, 0x6d, 0x5d, 0xc4, 0xaf, 0x94, 0xfa, 0x5c, 0xda, 0x53, 0x84, 0xa3, 0x1b,
	0xb4, 0xb4, 0xbb, 0x08, 0xf3, 0x68, 0xd3, 0xef, 0xae, 0xc0, 0x92, 0xb4, 0x72, 0x6b, 0x5f, 0xc1,
	0x6a, 0x3d, 0x18, 0xc4, 0xec, 0xa5, 0x78, 0x72, 0x4e, 0xfc, 0xfb, 0x0f, 0x2c, 0x3e, 0x4e, 0xdf,
	0xfe, 0xc8, 0x40, 0xf8, 0xd3, 0xa6, 0xa2, 0x74, 0x98, 0x39, 0xaa, 0xcf, 0xc1, 0x6a, 0xbf, 0x5e,
	0x86, 0xcd, 0xc2, 0x3f, 0x5a, 0x41, 0x2b, 0x8b, 0x9d, 0x89, 0xf0, 0x35, 0xbf, 0x3d, 0xca, 0x0b,
	0xe2, 0xb0, 0x3b, 0x66, 0x27, 0x41, 0x78, 0x2e, 0x39, 0xa5, 0x65, 0xfe, 0x6c, 0xde, 0xe8, 0xa8,
	0x9e, 0x54, 0xcb, 0xff, 0x6a, 0x94, 0x01, 0xf1, 0x13, 0xea, 0xcc, 0x2b, 0x31, 0xf2, 0x02, 0x6f,
	0x06, 0x44, 0x74, 0x58, 0x8e, 0xd8, 0x19, 0x0b, 0x93, 0xc3, 0xf4, 0x8d, 0xbc, 0xfd, 0x5c, 0xe8,
	0xe4, 0x5d, 0x4b, 0xe2, 0x3e, 0x4a, 0x3c, 0x40, 0x9a, 0x92, 0xd7, 0xf6, 0x61, 0x39, 0xa9, 0xce,
	0xa6, 0xb6, 0xf2, 0xeb, 0xba, 0x86, 0x49, 0x5b, 0x6a, 0x53, 0xa4, 0x60, 0xb4, 0x74, 0xc3, 0xa4,
	0x4a, 0x99, 0xff, 0x54, 0x7f, 0x64, 0x52, 0x91, 0x62, 0x53, 0xa7, 0xba, 0xad, 0xd7, 0xd5, 0xa6,
	0x32, 0x5f, 0xfb, 0x8d, 0x12, 0xac, 0xe7, 0x22, 0xd1, 0x84, 0x16, 0xef, 0xe2, 0x7e, 0xbb, 0xb8,
	0xf5, 0xb8, 0xb7, 0x63, 0x36, 0xb5, 0x87, 0xb0, 0x35, 0x81, 0x98, 0xef, 0xf7, 0x0e, 0x90, 0x7c,
	0xa8, 0xc4, 0xd1, 0xda, 0xfb, 0x4a, 0xa9, 0xf6, 0x4f, 0x4a, 0x70, 0x75, 0xca, 0xc5, 0x24, 0xf2,
	0x10, 0x16, 0x85, 0x57, 0x71, 0xe9, 0xff, 0x59, 0x25, 0xf1, 0xd1, 0x0d, 0x76, 0xe3, 0x38, 0xf4,
	0x8f, 0x46, 0x71, 0x32, 0x61, 0xc6, 0x00, 0x9c, 0x71, 0xa3, 0x88, 0xd9, 0xc1, 0x30, 0xd0, 0x5e,
	0xc6, 0xf2, 0xa0, 0x24, 0x03, 0x21, 0x1a, 0x6c, 0x26, 0xda, 0x43, 0x06, 0xe6, 0xa5, 0x21, 0x7a,
	0x33, 0x9f, 0x7e, 0x92, 0x43, 0xa1, 0x45, 0x9a, 0xda, 0x3f, 0x2f, 0xc1, 0x66, 0x01, 0x89, 0x5f,
	0xbf, 0xe4, 0xf9, 0x68, 0x99, 0xeb, 0x7b, 0x19, 0x48, 0xe1, 0x5f, 0x75, 0x95, 0x7f, 0x0a, 0x9f,
	0xfc, 0x6d, 0x58, 0xf7, 0xfc, 0x90, 0x75, 0xe3, 0xde, 0xb9, 0x3a, 0x1c, 0xf6, 0x92, 0x33, 0xb1,
	0x3c, 0x90, 0xfc, 0x00, 0xd6, 0x06, 0xec, 0x65, 0xec, 0x9c, 0x5e, 0x7e, 0x7c, 0xab, 0x48, 0x90,
	0x8c, 0x6d, 0x0f, 0x48, 0xf2, 0x8f, 0x7e, 0xd8, 0xf8, 0xdf, 0x46, 0x15, 0xde, 0xbd, 0x2a, 0x4f,
	0x7f, 0xa9, 0xb2, 0xcc, 0x0f, 0x1c, 0xf8, 0xef, 0xda, 0xdf, 0x9d, 0x83, 0xa5, 0xbd, 0x5e, 0xf0,
	0x35, 0x2e, 0xd8, 0xe7, 0x50, 0x11, 0x3e, 0xe9, 0x24, 0x67, 0xce, 0x6c, 0xea, 0xed, 0xd3, 0x2c,
	0x16, 0x9d, 0x49, 0x4f, 0x0e, 0x61, 0xc7, 0x63, 0x51, 0x3c, 0x85, 0x73, 0xf9, 0x52, 0x9c, 0x67,
	0x50, 0x93, 0x87, 0xdc, 0xe4, 0x8b, 0x83, 0x6e, 0xd0, 0x93, 0x8f, 0x06, 0xe4, 0x6e, 0x4b, 0xcb,
	0xa1, 0xa1, 0x2c, 0x39, 0x0e, 0x4d, 0xb1, 0x71, 0x26, 0x1c, 0xf7, 0x82, 0xaf, 0x45, 0x02, 0x03,
	0xbf, 0x39, 0x53, 0xa2, 0x19, 0x08, 0xa9, 0xc0, 0x92, 0x4c, 0x1a, 0xe0, 0x57, 0x5e, 0xe6, 0x68,
	0x52, 0x24, 0xef, 0xc3, 0x56, 0x1c, 0xba, 0x83, 0x48, 0x3c, 0xf3, 0x2b, 0x19, 0x2c, 0x72, 0x9c,
	0xc9, 0x0a, 0x61, 0x3f, 0x77, 0x99, 0x7f, 0x96, 0xa2, 0x2e, 0x71, 0xd4, 0x02, 0xb4, 0x76, 0x0f,
	0x96, 0x93, 0x5e, 0x92, 0x25, 0x98, 0xb3, 0xeb, 0x6d, 0x91, 0xbc, 0xd7, 0x69, 0xb4, 0x95, 0x32,
	0x21, 0xb0, 0x2e, 0xd7, 0xb1, 0xd3, 0xa6, 0xa6, 0x6d, 0x2a, 0xbf, 0xbb, 0x54, 0xab, 0xc3, 0x92,
	0x7c, 0xdc, 0x17, 0xb5, 0x6a, 0xcf, 0x8d, 0xfd, 0x78, 0xe4, 0x89, 0x49, 0x5d, 0xa2, 0x69, 0x19,
	0x27, 0x45, 0x2f, 0x18, 0x9c, 0x88, 0xca, 0xb2, 0xb8, 0x0d, 0x92, 0x02, 0xde, 0xfb, 0x18, 0x60,
	0x1c, 0x07, 0x10, 0xef, 0x16, 0xf0, 0x48, 0x80, 0x38, 0x67, 0x6a, 0x68, 0x4d, 0xcd, 0x4e, 0x9e,
	0x25, 0x90, 0xb7, 0x01, 0x94, 0xf2, 0xee, 0xfb, 0xf0, 0x46, 0x37, 0xe8, 0xdf, 0x3d, 0xeb, 0xc7,
	0xa3, 0xf0, 0x28, 0xb8, 0x9b, 0x5c, 0x62, 0x90, 0x92, 0xbf, 0xeb, 0xc5, 0xc1, 0xee, 0x4a, 0xfa,
	0xff, 0xf1, 0xfe, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfb, 0xcb, 0x25, 0xe7, 0x2b, 0x6f, 0x00,
	0x00,
}
