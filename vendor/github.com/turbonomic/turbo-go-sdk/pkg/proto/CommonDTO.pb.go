// Code generated by protoc-gen-go.
// source: CommonDTO.proto
// DO NOT EDIT!

package proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Enumerates supported DTO types
type UpdateType int32

const (
	// The DTO represents complete state of a new or existing entity.
	UpdateType_UPDATED UpdateType = 0
	// Entity was deleted. DTO must contain only identifying property that are necessary
	// to locate the entity on the server side.
	UpdateType_DELETED UpdateType = 1
)

var UpdateType_name = map[int32]string{
	0: "UPDATED",
	1: "DELETED",
}
var UpdateType_value = map[string]int32{
	"UPDATED": 0,
	"DELETED": 1,
}

func (x UpdateType) Enum() *UpdateType {
	p := new(UpdateType)
	*p = x
	return p
}
func (x UpdateType) String() string {
	return proto.EnumName(UpdateType_name, int32(x))
}
func (x *UpdateType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UpdateType_value, data, "UpdateType")
	if err != nil {
		return err
	}
	*x = UpdateType(value)
	return nil
}
func (UpdateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type EntityDTO_EntityType int32

const (
	EntityDTO_SWITCH                        EntityDTO_EntityType = 0
	EntityDTO_VIRTUAL_DATACENTER            EntityDTO_EntityType = 1
	EntityDTO_STORAGE                       EntityDTO_EntityType = 2
	EntityDTO_SERVICE                       EntityDTO_EntityType = 3
	EntityDTO_DATABASE_SERVER               EntityDTO_EntityType = 4
	EntityDTO_SAVINGS                       EntityDTO_EntityType = 5
	EntityDTO_OPERATOR                      EntityDTO_EntityType = 6
	EntityDTO_WEB_SERVER                    EntityDTO_EntityType = 7
	EntityDTO_RIGHT_SIZER                   EntityDTO_EntityType = 8
	EntityDTO_THREE_TIER_APPLICATION        EntityDTO_EntityType = 9
	EntityDTO_VIRTUAL_MACHINE               EntityDTO_EntityType = 10
	EntityDTO_DISK_ARRAY                    EntityDTO_EntityType = 11
	EntityDTO_DATACENTER                    EntityDTO_EntityType = 12
	EntityDTO_INFRASTRUCTURE                EntityDTO_EntityType = 13
	EntityDTO_PHYSICAL_MACHINE              EntityDTO_EntityType = 14
	EntityDTO_CHASSIS                       EntityDTO_EntityType = 15
	EntityDTO_LICENSING_SERVICE             EntityDTO_EntityType = 16
	EntityDTO_BUSINESS_USER                 EntityDTO_EntityType = 17
	EntityDTO_STORAGE_CONTROLLER            EntityDTO_EntityType = 18
	EntityDTO_HYPERVISOR                    EntityDTO_EntityType = 19
	EntityDTO_BUSINESS_ENTITY               EntityDTO_EntityType = 20
	EntityDTO_IO_MODULE                     EntityDTO_EntityType = 21
	EntityDTO_ACTION_MANAGER                EntityDTO_EntityType = 22
	EntityDTO_VLAN                          EntityDTO_EntityType = 23
	EntityDTO_APPLICATION_SERVER            EntityDTO_EntityType = 24
	EntityDTO_BUSINESS                      EntityDTO_EntityType = 25
	EntityDTO_VIRTUAL_APPLICATION           EntityDTO_EntityType = 26
	EntityDTO_NETWORKING_ENDPOINT           EntityDTO_EntityType = 27
	EntityDTO_BUSINESS_ACCOUNT              EntityDTO_EntityType = 28
	EntityDTO_IP                            EntityDTO_EntityType = 29
	EntityDTO_SERVICE_ENTITY_TEMPLATE       EntityDTO_EntityType = 30
	EntityDTO_PORT                          EntityDTO_EntityType = 31
	EntityDTO_NETWORK                       EntityDTO_EntityType = 32
	EntityDTO_APPLICATION                   EntityDTO_EntityType = 33
	EntityDTO_THIS_ENTITY                   EntityDTO_EntityType = 34
	EntityDTO_COMPUTE_RESOURCE              EntityDTO_EntityType = 35
	EntityDTO_MAC                           EntityDTO_EntityType = 36
	EntityDTO_INTERNET                      EntityDTO_EntityType = 37
	EntityDTO_MOVER                         EntityDTO_EntityType = 38
	EntityDTO_DISTRIBUTED_VIRTUAL_PORTGROUP EntityDTO_EntityType = 39
	EntityDTO_CONTAINER                     EntityDTO_EntityType = 40
	EntityDTO_CONTAINER_POD                 EntityDTO_EntityType = 41
	EntityDTO_LOGICAL_POOL                  EntityDTO_EntityType = 42
	EntityDTO_CLOUD_SERVICE                 EntityDTO_EntityType = 43
	EntityDTO_DPOD                          EntityDTO_EntityType = 44
	EntityDTO_VPOD                          EntityDTO_EntityType = 45
	EntityDTO_DATABASE                      EntityDTO_EntityType = 46
	EntityDTO_LOAD_BALANCER                 EntityDTO_EntityType = 47
	EntityDTO_BUSINESS_APPLICATION          EntityDTO_EntityType = 48
	EntityDTO_PROCESSOR_POOL                EntityDTO_EntityType = 49
	EntityDTO_STORAGE_VOLUME                EntityDTO_EntityType = 50
	// 2047 is the largest tag value encoded in 2 bytes
	EntityDTO_UNKNOWN EntityDTO_EntityType = 2047
)

var EntityDTO_EntityType_name = map[int32]string{
	0:    "SWITCH",
	1:    "VIRTUAL_DATACENTER",
	2:    "STORAGE",
	3:    "SERVICE",
	4:    "DATABASE_SERVER",
	5:    "SAVINGS",
	6:    "OPERATOR",
	7:    "WEB_SERVER",
	8:    "RIGHT_SIZER",
	9:    "THREE_TIER_APPLICATION",
	10:   "VIRTUAL_MACHINE",
	11:   "DISK_ARRAY",
	12:   "DATACENTER",
	13:   "INFRASTRUCTURE",
	14:   "PHYSICAL_MACHINE",
	15:   "CHASSIS",
	16:   "LICENSING_SERVICE",
	17:   "BUSINESS_USER",
	18:   "STORAGE_CONTROLLER",
	19:   "HYPERVISOR",
	20:   "BUSINESS_ENTITY",
	21:   "IO_MODULE",
	22:   "ACTION_MANAGER",
	23:   "VLAN",
	24:   "APPLICATION_SERVER",
	25:   "BUSINESS",
	26:   "VIRTUAL_APPLICATION",
	27:   "NETWORKING_ENDPOINT",
	28:   "BUSINESS_ACCOUNT",
	29:   "IP",
	30:   "SERVICE_ENTITY_TEMPLATE",
	31:   "PORT",
	32:   "NETWORK",
	33:   "APPLICATION",
	34:   "THIS_ENTITY",
	35:   "COMPUTE_RESOURCE",
	36:   "MAC",
	37:   "INTERNET",
	38:   "MOVER",
	39:   "DISTRIBUTED_VIRTUAL_PORTGROUP",
	40:   "CONTAINER",
	41:   "CONTAINER_POD",
	42:   "LOGICAL_POOL",
	43:   "CLOUD_SERVICE",
	44:   "DPOD",
	45:   "VPOD",
	46:   "DATABASE",
	47:   "LOAD_BALANCER",
	48:   "BUSINESS_APPLICATION",
	49:   "PROCESSOR_POOL",
	50:   "STORAGE_VOLUME",
	2047: "UNKNOWN",
}
var EntityDTO_EntityType_value = map[string]int32{
	"SWITCH":                 0,
	"VIRTUAL_DATACENTER":     1,
	"STORAGE":                2,
	"SERVICE":                3,
	"DATABASE_SERVER":        4,
	"SAVINGS":                5,
	"OPERATOR":               6,
	"WEB_SERVER":             7,
	"RIGHT_SIZER":            8,
	"THREE_TIER_APPLICATION": 9,
	"VIRTUAL_MACHINE":        10,
	"DISK_ARRAY":             11,
	"DATACENTER":             12,
	"INFRASTRUCTURE":         13,
	"PHYSICAL_MACHINE":       14,
	"CHASSIS":                15,
	"LICENSING_SERVICE":      16,
	"BUSINESS_USER":          17,
	"STORAGE_CONTROLLER":     18,
	"HYPERVISOR":             19,
	"BUSINESS_ENTITY":        20,
	"IO_MODULE":              21,
	"ACTION_MANAGER":         22,
	"VLAN":                   23,
	"APPLICATION_SERVER":     24,
	"BUSINESS":               25,
	"VIRTUAL_APPLICATION":    26,
	"NETWORKING_ENDPOINT":    27,
	"BUSINESS_ACCOUNT":       28,
	"IP":                     29,
	"SERVICE_ENTITY_TEMPLATE": 30,
	"PORT":             31,
	"NETWORK":          32,
	"APPLICATION":      33,
	"THIS_ENTITY":      34,
	"COMPUTE_RESOURCE": 35,
	"MAC":              36,
	"INTERNET":         37,
	"MOVER":            38,
	"DISTRIBUTED_VIRTUAL_PORTGROUP": 39,
	"CONTAINER":                     40,
	"CONTAINER_POD":                 41,
	"LOGICAL_POOL":                  42,
	"CLOUD_SERVICE":                 43,
	"DPOD":                          44,
	"VPOD":                          45,
	"DATABASE":                      46,
	"LOAD_BALANCER":                 47,
	"BUSINESS_APPLICATION":          48,
	"PROCESSOR_POOL":                49,
	"STORAGE_VOLUME":                50,
	"UNKNOWN":                       2047,
}

func (x EntityDTO_EntityType) Enum() *EntityDTO_EntityType {
	p := new(EntityDTO_EntityType)
	*p = x
	return p
}
func (x EntityDTO_EntityType) String() string {
	return proto.EnumName(EntityDTO_EntityType_name, int32(x))
}
func (x *EntityDTO_EntityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_EntityType_value, data, "EntityDTO_EntityType")
	if err != nil {
		return err
	}
	*x = EntityDTO_EntityType(value)
	return nil
}
func (EntityDTO_EntityType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 0} }

// Enum for power state.
type EntityDTO_PowerState int32

const (
	EntityDTO_POWERED_ON         EntityDTO_PowerState = 1
	EntityDTO_POWERED_OFF        EntityDTO_PowerState = 2
	EntityDTO_SUSPENDED          EntityDTO_PowerState = 3
	EntityDTO_POWERSTATE_UNKNOWN EntityDTO_PowerState = 4
)

var EntityDTO_PowerState_name = map[int32]string{
	1: "POWERED_ON",
	2: "POWERED_OFF",
	3: "SUSPENDED",
	4: "POWERSTATE_UNKNOWN",
}
var EntityDTO_PowerState_value = map[string]int32{
	"POWERED_ON":         1,
	"POWERED_OFF":        2,
	"SUSPENDED":          3,
	"POWERSTATE_UNKNOWN": 4,
}

func (x EntityDTO_PowerState) Enum() *EntityDTO_PowerState {
	p := new(EntityDTO_PowerState)
	*p = x
	return p
}
func (x EntityDTO_PowerState) String() string {
	return proto.EnumName(EntityDTO_PowerState_name, int32(x))
}
func (x *EntityDTO_PowerState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_PowerState_value, data, "EntityDTO_PowerState")
	if err != nil {
		return err
	}
	*x = EntityDTO_PowerState(value)
	return nil
}
func (EntityDTO_PowerState) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 1} }

// Enum for storage type.
type EntityDTO_StorageType int32

const (
	EntityDTO_GENERIC_BLOCK       EntityDTO_StorageType = 1
	EntityDTO_ISCSI               EntityDTO_StorageType = 2
	EntityDTO_FIBER_CHANNEL       EntityDTO_StorageType = 3
	EntityDTO_FCOE                EntityDTO_StorageType = 4
	EntityDTO_OBJECT              EntityDTO_StorageType = 5
	EntityDTO_GENERIC_FILE_SYSTEM EntityDTO_StorageType = 6
	EntityDTO_NFS                 EntityDTO_StorageType = 7
	EntityDTO_CIFS_SMB            EntityDTO_StorageType = 8
	EntityDTO_LOCAL               EntityDTO_StorageType = 9
	EntityDTO_OTHER               EntityDTO_StorageType = 10
	EntityDTO_VMFS                EntityDTO_StorageType = 11
)

var EntityDTO_StorageType_name = map[int32]string{
	1:  "GENERIC_BLOCK",
	2:  "ISCSI",
	3:  "FIBER_CHANNEL",
	4:  "FCOE",
	5:  "OBJECT",
	6:  "GENERIC_FILE_SYSTEM",
	7:  "NFS",
	8:  "CIFS_SMB",
	9:  "LOCAL",
	10: "OTHER",
	11: "VMFS",
}
var EntityDTO_StorageType_value = map[string]int32{
	"GENERIC_BLOCK":       1,
	"ISCSI":               2,
	"FIBER_CHANNEL":       3,
	"FCOE":                4,
	"OBJECT":              5,
	"GENERIC_FILE_SYSTEM": 6,
	"NFS":      7,
	"CIFS_SMB": 8,
	"LOCAL":    9,
	"OTHER":    10,
	"VMFS":     11,
}

func (x EntityDTO_StorageType) Enum() *EntityDTO_StorageType {
	p := new(EntityDTO_StorageType)
	*p = x
	return p
}
func (x EntityDTO_StorageType) String() string {
	return proto.EnumName(EntityDTO_StorageType_name, int32(x))
}
func (x *EntityDTO_StorageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_StorageType_value, data, "EntityDTO_StorageType")
	if err != nil {
		return err
	}
	*x = EntityDTO_StorageType(value)
	return nil
}
func (EntityDTO_StorageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 2} }

// Type of a file in use by the virtual machine
type EntityDTO_VirtualMachineFileType int32

const (
	EntityDTO_CONFIGURATION EntityDTO_VirtualMachineFileType = 1
	EntityDTO_DISK          EntityDTO_VirtualMachineFileType = 2
	EntityDTO_SNAPSHOT      EntityDTO_VirtualMachineFileType = 3
	EntityDTO_MEMORY        EntityDTO_VirtualMachineFileType = 4
	EntityDTO_SWAP          EntityDTO_VirtualMachineFileType = 5
	EntityDTO_LOG           EntityDTO_VirtualMachineFileType = 6
	EntityDTO_ISO           EntityDTO_VirtualMachineFileType = 7
	EntityDTO_ESXCONSOLE    EntityDTO_VirtualMachineFileType = 8
)

var EntityDTO_VirtualMachineFileType_name = map[int32]string{
	1: "CONFIGURATION",
	2: "DISK",
	3: "SNAPSHOT",
	4: "MEMORY",
	5: "SWAP",
	6: "LOG",
	7: "ISO",
	8: "ESXCONSOLE",
}
var EntityDTO_VirtualMachineFileType_value = map[string]int32{
	"CONFIGURATION": 1,
	"DISK":          2,
	"SNAPSHOT":      3,
	"MEMORY":        4,
	"SWAP":          5,
	"LOG":           6,
	"ISO":           7,
	"ESXCONSOLE":    8,
}

func (x EntityDTO_VirtualMachineFileType) Enum() *EntityDTO_VirtualMachineFileType {
	p := new(EntityDTO_VirtualMachineFileType)
	*p = x
	return p
}
func (x EntityDTO_VirtualMachineFileType) String() string {
	return proto.EnumName(EntityDTO_VirtualMachineFileType_name, int32(x))
}
func (x *EntityDTO_VirtualMachineFileType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_VirtualMachineFileType_value, data, "EntityDTO_VirtualMachineFileType")
	if err != nil {
		return err
	}
	*x = EntityDTO_VirtualMachineFileType(value)
	return nil
}
func (EntityDTO_VirtualMachineFileType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 3}
}

// A virtual datacenter may be either a consumer or producer
type EntityDTO_VirtualDatacenterRole int32

const (
	EntityDTO_CONSUMER EntityDTO_VirtualDatacenterRole = 1
	EntityDTO_PRODUCER EntityDTO_VirtualDatacenterRole = 2
)

var EntityDTO_VirtualDatacenterRole_name = map[int32]string{
	1: "CONSUMER",
	2: "PRODUCER",
}
var EntityDTO_VirtualDatacenterRole_value = map[string]int32{
	"CONSUMER": 1,
	"PRODUCER": 2,
}

func (x EntityDTO_VirtualDatacenterRole) Enum() *EntityDTO_VirtualDatacenterRole {
	p := new(EntityDTO_VirtualDatacenterRole)
	*p = x
	return p
}
func (x EntityDTO_VirtualDatacenterRole) String() string {
	return proto.EnumName(EntityDTO_VirtualDatacenterRole_name, int32(x))
}
func (x *EntityDTO_VirtualDatacenterRole) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_VirtualDatacenterRole_value, data, "EntityDTO_VirtualDatacenterRole")
	if err != nil {
		return err
	}
	*x = EntityDTO_VirtualDatacenterRole(value)
	return nil
}
func (EntityDTO_VirtualDatacenterRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 4}
}

// A virtual datacenter allocation model may be either allocationpool, payasyougo, or
// reservationpool
type EntityDTO_VirtualDatacenterAllocationModel int32

const (
	EntityDTO_ALLOCATION_POOL  EntityDTO_VirtualDatacenterAllocationModel = 1
	EntityDTO_PAY_AS_YOU_GO    EntityDTO_VirtualDatacenterAllocationModel = 2
	EntityDTO_RESERVATION_POOL EntityDTO_VirtualDatacenterAllocationModel = 3
)

var EntityDTO_VirtualDatacenterAllocationModel_name = map[int32]string{
	1: "ALLOCATION_POOL",
	2: "PAY_AS_YOU_GO",
	3: "RESERVATION_POOL",
}
var EntityDTO_VirtualDatacenterAllocationModel_value = map[string]int32{
	"ALLOCATION_POOL":  1,
	"PAY_AS_YOU_GO":    2,
	"RESERVATION_POOL": 3,
}

func (x EntityDTO_VirtualDatacenterAllocationModel) Enum() *EntityDTO_VirtualDatacenterAllocationModel {
	p := new(EntityDTO_VirtualDatacenterAllocationModel)
	*p = x
	return p
}
func (x EntityDTO_VirtualDatacenterAllocationModel) String() string {
	return proto.EnumName(EntityDTO_VirtualDatacenterAllocationModel_name, int32(x))
}
func (x *EntityDTO_VirtualDatacenterAllocationModel) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_VirtualDatacenterAllocationModel_value, data, "EntityDTO_VirtualDatacenterAllocationModel")
	if err != nil {
		return err
	}
	*x = EntityDTO_VirtualDatacenterAllocationModel(value)
	return nil
}
func (EntityDTO_VirtualDatacenterAllocationModel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 5}
}

// Names for communicating the number of various types of disks.
type EntityDTO_NumDiskNames int32

const (
	// Number of discovered solid state drives.
	EntityDTO_NUM_SSD EntityDTO_NumDiskNames = 1
	// Number of discovered 7200 RPM disks.
	EntityDTO_NUM_7200_DISKS EntityDTO_NumDiskNames = 2
	// Number of discovered 10000 RPM disks.
	EntityDTO_NUM_10K_DISKS EntityDTO_NumDiskNames = 3
	// Number of discovered 15000 RPM disks.
	EntityDTO_NUM_15K_DISKS EntityDTO_NumDiskNames = 4
	// Number of discovered VSeries disks.
	EntityDTO_NUM_VSERIES_DISKS EntityDTO_NumDiskNames = 5
)

var EntityDTO_NumDiskNames_name = map[int32]string{
	1: "NUM_SSD",
	2: "NUM_7200_DISKS",
	3: "NUM_10K_DISKS",
	4: "NUM_15K_DISKS",
	5: "NUM_VSERIES_DISKS",
}
var EntityDTO_NumDiskNames_value = map[string]int32{
	"NUM_SSD":           1,
	"NUM_7200_DISKS":    2,
	"NUM_10K_DISKS":     3,
	"NUM_15K_DISKS":     4,
	"NUM_VSERIES_DISKS": 5,
}

func (x EntityDTO_NumDiskNames) Enum() *EntityDTO_NumDiskNames {
	p := new(EntityDTO_NumDiskNames)
	*p = x
	return p
}
func (x EntityDTO_NumDiskNames) String() string {
	return proto.EnumName(EntityDTO_NumDiskNames_name, int32(x))
}
func (x *EntityDTO_NumDiskNames) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_NumDiskNames_value, data, "EntityDTO_NumDiskNames")
	if err != nil {
		return err
	}
	*x = EntityDTO_NumDiskNames(value)
	return nil
}
func (EntityDTO_NumDiskNames) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 6} }

// Specifies the origin of an entity, either DISCOVERED or PROXY
// DISCOVERED: An entity discovered by the probe that maps to a real resource found
// when probing the target.
// PROXY: An entity supplied by the probe to fill out a required part of the supply chain.
// For example, a probe discovering Virtual Machines may supply a Guestload Application proxy
// to complete its supply chain.
// Some proxy entities may be replaced by discovered entities found by another probe."
type EntityDTO_EntityOrigin int32

const (
	EntityDTO_DISCOVERED  EntityDTO_EntityOrigin = 1
	EntityDTO_PROXY       EntityDTO_EntityOrigin = 2
	EntityDTO_REPLACEABLE EntityDTO_EntityOrigin = 3
)

var EntityDTO_EntityOrigin_name = map[int32]string{
	1: "DISCOVERED",
	2: "PROXY",
	3: "REPLACEABLE",
}
var EntityDTO_EntityOrigin_value = map[string]int32{
	"DISCOVERED":  1,
	"PROXY":       2,
	"REPLACEABLE": 3,
}

func (x EntityDTO_EntityOrigin) Enum() *EntityDTO_EntityOrigin {
	p := new(EntityDTO_EntityOrigin)
	*p = x
	return p
}
func (x EntityDTO_EntityOrigin) String() string {
	return proto.EnumName(EntityDTO_EntityOrigin_name, int32(x))
}
func (x *EntityDTO_EntityOrigin) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_EntityOrigin_value, data, "EntityDTO_EntityOrigin")
	if err != nil {
		return err
	}
	*x = EntityDTO_EntityOrigin(value)
	return nil
}
func (EntityDTO_EntityOrigin) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 7} }

type EntityDTO_VirtualMachineData_VMBillingType int32

const (
	// Regular on-demand VMs - this is the default type.
	//
	EntityDTO_VirtualMachineData_ONDEMAND EntityDTO_VirtualMachineData_VMBillingType = 0
	// VM bids for compute resources but could be interrupted - lower pricing.
	// In AWS, it is called fleet Spot Instances.
	// In Azure, it is called low priority VMs.
	// In GCE, it is called preemptible VMs.
	//
	EntityDTO_VirtualMachineData_BIDDING EntityDTO_VirtualMachineData_VMBillingType = 1
	// VM runs on a dedicated host - higher pricing.
	//
	EntityDTO_VirtualMachineData_DEDICATED EntityDTO_VirtualMachineData_VMBillingType = 2
	// Reserved in advance - great pricing.
	//
	EntityDTO_VirtualMachineData_RESERVED EntityDTO_VirtualMachineData_VMBillingType = 3
)

var EntityDTO_VirtualMachineData_VMBillingType_name = map[int32]string{
	0: "ONDEMAND",
	1: "BIDDING",
	2: "DEDICATED",
	3: "RESERVED",
}
var EntityDTO_VirtualMachineData_VMBillingType_value = map[string]int32{
	"ONDEMAND":  0,
	"BIDDING":   1,
	"DEDICATED": 2,
	"RESERVED":  3,
}

func (x EntityDTO_VirtualMachineData_VMBillingType) Enum() *EntityDTO_VirtualMachineData_VMBillingType {
	p := new(EntityDTO_VirtualMachineData_VMBillingType)
	*p = x
	return p
}
func (x EntityDTO_VirtualMachineData_VMBillingType) String() string {
	return proto.EnumName(EntityDTO_VirtualMachineData_VMBillingType_name, int32(x))
}
func (x *EntityDTO_VirtualMachineData_VMBillingType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_VirtualMachineData_VMBillingType_value, data, "EntityDTO_VirtualMachineData_VMBillingType")
	if err != nil {
		return err
	}
	*x = EntityDTO_VirtualMachineData_VMBillingType(value)
	return nil
}
func (EntityDTO_VirtualMachineData_VMBillingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 7, 0}
}

type CommodityDTO_CommodityType int32

const (
	CommodityDTO_CLUSTER                    CommodityDTO_CommodityType = 0
	CommodityDTO_THREADS                    CommodityDTO_CommodityType = 1
	CommodityDTO_CPU_ALLOCATION             CommodityDTO_CommodityType = 2
	CommodityDTO_NUMBER_CONSUMERS           CommodityDTO_CommodityType = 3
	CommodityDTO_FLOW_ALLOCATION            CommodityDTO_CommodityType = 4
	CommodityDTO_Q1_VCPU                    CommodityDTO_CommodityType = 5
	CommodityDTO_STORAGE_PROVISIONED        CommodityDTO_CommodityType = 6
	CommodityDTO_LICENSE_COMMODITY          CommodityDTO_CommodityType = 7
	CommodityDTO_STORAGE_AMOUNT             CommodityDTO_CommodityType = 8
	CommodityDTO_Q16_VCPU                   CommodityDTO_CommodityType = 9
	CommodityDTO_Q32_VCPU                   CommodityDTO_CommodityType = 10
	CommodityDTO_SAME_CLUSTER_MOVE_SVC      CommodityDTO_CommodityType = 11
	CommodityDTO_Q3_VCPU                    CommodityDTO_CommodityType = 12
	CommodityDTO_SLA_COMMODITY              CommodityDTO_CommodityType = 13
	CommodityDTO_CROSS_CLUSTER_MOVE_SVC     CommodityDTO_CommodityType = 14
	CommodityDTO_NUMBER_CONSUMERS_PM        CommodityDTO_CommodityType = 15
	CommodityDTO_STORAGE_ALLOCATION         CommodityDTO_CommodityType = 16
	CommodityDTO_Q8_VCPU                    CommodityDTO_CommodityType = 17
	CommodityDTO_SPACE                      CommodityDTO_CommodityType = 18
	CommodityDTO_Q6_VCPU                    CommodityDTO_CommodityType = 19
	CommodityDTO_POWER                      CommodityDTO_CommodityType = 20
	CommodityDTO_MEM                        CommodityDTO_CommodityType = 21
	CommodityDTO_STORAGE_LATENCY            CommodityDTO_CommodityType = 22
	CommodityDTO_Q7_VCPU                    CommodityDTO_CommodityType = 23
	CommodityDTO_COOLING                    CommodityDTO_CommodityType = 24
	CommodityDTO_PORT_CHANEL                CommodityDTO_CommodityType = 25
	CommodityDTO_VCPU                       CommodityDTO_CommodityType = 26
	CommodityDTO_QN_VCPU                    CommodityDTO_CommodityType = 27
	CommodityDTO_CPU_PROVISIONED            CommodityDTO_CommodityType = 28
	CommodityDTO_RIGHT_SIZE_SVC             CommodityDTO_CommodityType = 29
	CommodityDTO_MOVE                       CommodityDTO_CommodityType = 30
	CommodityDTO_Q2_VCPU                    CommodityDTO_CommodityType = 31
	CommodityDTO_Q5_VCPU                    CommodityDTO_CommodityType = 32
	CommodityDTO_SWAPPING                   CommodityDTO_CommodityType = 33
	CommodityDTO_SEGMENTATION               CommodityDTO_CommodityType = 34
	CommodityDTO_FLOW                       CommodityDTO_CommodityType = 35
	CommodityDTO_DATASTORE                  CommodityDTO_CommodityType = 36
	CommodityDTO_CROSS_CLOUD_MOVE_SVC       CommodityDTO_CommodityType = 37
	CommodityDTO_RIGHT_SIZE_DOWN            CommodityDTO_CommodityType = 38
	CommodityDTO_IO_THROUGHPUT              CommodityDTO_CommodityType = 39
	CommodityDTO_CPU                        CommodityDTO_CommodityType = 40
	CommodityDTO_BALLOONING                 CommodityDTO_CommodityType = 41
	CommodityDTO_VDC                        CommodityDTO_CommodityType = 42
	CommodityDTO_Q64_VCPU                   CommodityDTO_CommodityType = 43
	CommodityDTO_CONNECTION                 CommodityDTO_CommodityType = 44
	CommodityDTO_MEM_PROVISIONED            CommodityDTO_CommodityType = 45
	CommodityDTO_STORAGE                    CommodityDTO_CommodityType = 46
	CommodityDTO_NET_THROUGHPUT             CommodityDTO_CommodityType = 47
	CommodityDTO_NUMBER_CONSUMERS_STORAGE   CommodityDTO_CommodityType = 48
	CommodityDTO_TRANSACTION                CommodityDTO_CommodityType = 49
	CommodityDTO_MEM_ALLOCATION             CommodityDTO_CommodityType = 50
	CommodityDTO_DSPM_ACCESS                CommodityDTO_CommodityType = 51
	CommodityDTO_RESPONSE_TIME              CommodityDTO_CommodityType = 52
	CommodityDTO_VMEM                       CommodityDTO_CommodityType = 53
	CommodityDTO_ACTION_PERMIT              CommodityDTO_CommodityType = 54
	CommodityDTO_DATACENTER                 CommodityDTO_CommodityType = 55
	CommodityDTO_APPLICATION                CommodityDTO_CommodityType = 56
	CommodityDTO_NETWORK                    CommodityDTO_CommodityType = 57
	CommodityDTO_Q4_VCPU                    CommodityDTO_CommodityType = 58
	CommodityDTO_STORAGE_CLUSTER            CommodityDTO_CommodityType = 59
	CommodityDTO_EXTENT                     CommodityDTO_CommodityType = 60
	CommodityDTO_ACCESS                     CommodityDTO_CommodityType = 61
	CommodityDTO_RIGHT_SIZE_UP              CommodityDTO_CommodityType = 62
	CommodityDTO_VAPP_ACCESS                CommodityDTO_CommodityType = 63
	CommodityDTO_STORAGE_ACCESS             CommodityDTO_CommodityType = 64
	CommodityDTO_VSTORAGE                   CommodityDTO_CommodityType = 65
	CommodityDTO_DRS_SEGMENTATION           CommodityDTO_CommodityType = 66
	CommodityDTO_DB_MEM                     CommodityDTO_CommodityType = 67
	CommodityDTO_TRANSACTION_LOG            CommodityDTO_CommodityType = 68
	CommodityDTO_DB_CACHE_HIT_RATE          CommodityDTO_CommodityType = 69
	CommodityDTO_HOT_STORAGE                CommodityDTO_CommodityType = 70
	CommodityDTO_COLLECTION_TIME            CommodityDTO_CommodityType = 71
	CommodityDTO_BUFFER_COMMODITY           CommodityDTO_CommodityType = 72
	CommodityDTO_SOFTWARE_LICENSE_COMMODITY CommodityDTO_CommodityType = 73
	CommodityDTO_VMPM_ACCESS                CommodityDTO_CommodityType = 74
	CommodityDTO_HA_COMMODITY               CommodityDTO_CommodityType = 75
	CommodityDTO_NETWORK_POLICY             CommodityDTO_CommodityType = 76
	CommodityDTO_HEAP                       CommodityDTO_CommodityType = 77
	CommodityDTO_DISK_ARRAY_ACCESS          CommodityDTO_CommodityType = 78
	CommodityDTO_SERVICE_LEVEL_CLUSTER      CommodityDTO_CommodityType = 79
	CommodityDTO_PROCESSING_UNITS           CommodityDTO_CommodityType = 80
	// 2047 is the largest tag value encoded in 2 bytes
	CommodityDTO_UNKNOWN CommodityDTO_CommodityType = 2047
)

var CommodityDTO_CommodityType_name = map[int32]string{
	0:    "CLUSTER",
	1:    "THREADS",
	2:    "CPU_ALLOCATION",
	3:    "NUMBER_CONSUMERS",
	4:    "FLOW_ALLOCATION",
	5:    "Q1_VCPU",
	6:    "STORAGE_PROVISIONED",
	7:    "LICENSE_COMMODITY",
	8:    "STORAGE_AMOUNT",
	9:    "Q16_VCPU",
	10:   "Q32_VCPU",
	11:   "SAME_CLUSTER_MOVE_SVC",
	12:   "Q3_VCPU",
	13:   "SLA_COMMODITY",
	14:   "CROSS_CLUSTER_MOVE_SVC",
	15:   "NUMBER_CONSUMERS_PM",
	16:   "STORAGE_ALLOCATION",
	17:   "Q8_VCPU",
	18:   "SPACE",
	19:   "Q6_VCPU",
	20:   "POWER",
	21:   "MEM",
	22:   "STORAGE_LATENCY",
	23:   "Q7_VCPU",
	24:   "COOLING",
	25:   "PORT_CHANEL",
	26:   "VCPU",
	27:   "QN_VCPU",
	28:   "CPU_PROVISIONED",
	29:   "RIGHT_SIZE_SVC",
	30:   "MOVE",
	31:   "Q2_VCPU",
	32:   "Q5_VCPU",
	33:   "SWAPPING",
	34:   "SEGMENTATION",
	35:   "FLOW",
	36:   "DATASTORE",
	37:   "CROSS_CLOUD_MOVE_SVC",
	38:   "RIGHT_SIZE_DOWN",
	39:   "IO_THROUGHPUT",
	40:   "CPU",
	41:   "BALLOONING",
	42:   "VDC",
	43:   "Q64_VCPU",
	44:   "CONNECTION",
	45:   "MEM_PROVISIONED",
	46:   "STORAGE",
	47:   "NET_THROUGHPUT",
	48:   "NUMBER_CONSUMERS_STORAGE",
	49:   "TRANSACTION",
	50:   "MEM_ALLOCATION",
	51:   "DSPM_ACCESS",
	52:   "RESPONSE_TIME",
	53:   "VMEM",
	54:   "ACTION_PERMIT",
	55:   "DATACENTER",
	56:   "APPLICATION",
	57:   "NETWORK",
	58:   "Q4_VCPU",
	59:   "STORAGE_CLUSTER",
	60:   "EXTENT",
	61:   "ACCESS",
	62:   "RIGHT_SIZE_UP",
	63:   "VAPP_ACCESS",
	64:   "STORAGE_ACCESS",
	65:   "VSTORAGE",
	66:   "DRS_SEGMENTATION",
	67:   "DB_MEM",
	68:   "TRANSACTION_LOG",
	69:   "DB_CACHE_HIT_RATE",
	70:   "HOT_STORAGE",
	71:   "COLLECTION_TIME",
	72:   "BUFFER_COMMODITY",
	73:   "SOFTWARE_LICENSE_COMMODITY",
	74:   "VMPM_ACCESS",
	75:   "HA_COMMODITY",
	76:   "NETWORK_POLICY",
	77:   "HEAP",
	78:   "DISK_ARRAY_ACCESS",
	79:   "SERVICE_LEVEL_CLUSTER",
	80:   "PROCESSING_UNITS",
	2047: "UNKNOWN",
}
var CommodityDTO_CommodityType_value = map[string]int32{
	"CLUSTER":                    0,
	"THREADS":                    1,
	"CPU_ALLOCATION":             2,
	"NUMBER_CONSUMERS":           3,
	"FLOW_ALLOCATION":            4,
	"Q1_VCPU":                    5,
	"STORAGE_PROVISIONED":        6,
	"LICENSE_COMMODITY":          7,
	"STORAGE_AMOUNT":             8,
	"Q16_VCPU":                   9,
	"Q32_VCPU":                   10,
	"SAME_CLUSTER_MOVE_SVC":      11,
	"Q3_VCPU":                    12,
	"SLA_COMMODITY":              13,
	"CROSS_CLUSTER_MOVE_SVC":     14,
	"NUMBER_CONSUMERS_PM":        15,
	"STORAGE_ALLOCATION":         16,
	"Q8_VCPU":                    17,
	"SPACE":                      18,
	"Q6_VCPU":                    19,
	"POWER":                      20,
	"MEM":                        21,
	"STORAGE_LATENCY":            22,
	"Q7_VCPU":                    23,
	"COOLING":                    24,
	"PORT_CHANEL":                25,
	"VCPU":                       26,
	"QN_VCPU":                    27,
	"CPU_PROVISIONED":            28,
	"RIGHT_SIZE_SVC":             29,
	"MOVE":                       30,
	"Q2_VCPU":                    31,
	"Q5_VCPU":                    32,
	"SWAPPING":                   33,
	"SEGMENTATION":               34,
	"FLOW":                       35,
	"DATASTORE":                  36,
	"CROSS_CLOUD_MOVE_SVC":       37,
	"RIGHT_SIZE_DOWN":            38,
	"IO_THROUGHPUT":              39,
	"CPU":                        40,
	"BALLOONING":                 41,
	"VDC":                        42,
	"Q64_VCPU":                   43,
	"CONNECTION":                 44,
	"MEM_PROVISIONED":            45,
	"STORAGE":                    46,
	"NET_THROUGHPUT":             47,
	"NUMBER_CONSUMERS_STORAGE":   48,
	"TRANSACTION":                49,
	"MEM_ALLOCATION":             50,
	"DSPM_ACCESS":                51,
	"RESPONSE_TIME":              52,
	"VMEM":                       53,
	"ACTION_PERMIT":              54,
	"DATACENTER":                 55,
	"APPLICATION":                56,
	"NETWORK":                    57,
	"Q4_VCPU":                    58,
	"STORAGE_CLUSTER":            59,
	"EXTENT":                     60,
	"ACCESS":                     61,
	"RIGHT_SIZE_UP":              62,
	"VAPP_ACCESS":                63,
	"STORAGE_ACCESS":             64,
	"VSTORAGE":                   65,
	"DRS_SEGMENTATION":           66,
	"DB_MEM":                     67,
	"TRANSACTION_LOG":            68,
	"DB_CACHE_HIT_RATE":          69,
	"HOT_STORAGE":                70,
	"COLLECTION_TIME":            71,
	"BUFFER_COMMODITY":           72,
	"SOFTWARE_LICENSE_COMMODITY": 73,
	"VMPM_ACCESS":                74,
	"HA_COMMODITY":               75,
	"NETWORK_POLICY":             76,
	"HEAP":                       77,
	"DISK_ARRAY_ACCESS":          78,
	"SERVICE_LEVEL_CLUSTER":      79,
	"PROCESSING_UNITS":           80,
	"UNKNOWN":                    2047,
}

func (x CommodityDTO_CommodityType) Enum() *CommodityDTO_CommodityType {
	p := new(CommodityDTO_CommodityType)
	*p = x
	return p
}
func (x CommodityDTO_CommodityType) String() string {
	return proto.EnumName(CommodityDTO_CommodityType_name, int32(x))
}
func (x *CommodityDTO_CommodityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CommodityDTO_CommodityType_value, data, "CommodityDTO_CommodityType")
	if err != nil {
		return err
	}
	*x = CommodityDTO_CommodityType(value)
	return nil
}
func (CommodityDTO_CommodityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{1, 0}
}

// Enum type notifying constraint's type
type GroupDTO_ConstraintType int32

const (
	GroupDTO_BUYER_SELLER_AFFINITY      GroupDTO_ConstraintType = 0
	GroupDTO_BUYER_SELLER_ANTI_AFFINITY GroupDTO_ConstraintType = 1
	GroupDTO_BUYER_BUYER_AFFINITY       GroupDTO_ConstraintType = 2
	GroupDTO_BUYER_BUYER_ANTI_AFFINITY  GroupDTO_ConstraintType = 3
	GroupDTO_CLUSTER                    GroupDTO_ConstraintType = 4
	GroupDTO_MERGE                      GroupDTO_ConstraintType = 5
	GroupDTO_SERVICE_LEVEL_CLUSTER      GroupDTO_ConstraintType = 6
)

var GroupDTO_ConstraintType_name = map[int32]string{
	0: "BUYER_SELLER_AFFINITY",
	1: "BUYER_SELLER_ANTI_AFFINITY",
	2: "BUYER_BUYER_AFFINITY",
	3: "BUYER_BUYER_ANTI_AFFINITY",
	4: "CLUSTER",
	5: "MERGE",
	6: "SERVICE_LEVEL_CLUSTER",
}
var GroupDTO_ConstraintType_value = map[string]int32{
	"BUYER_SELLER_AFFINITY":      0,
	"BUYER_SELLER_ANTI_AFFINITY": 1,
	"BUYER_BUYER_AFFINITY":       2,
	"BUYER_BUYER_ANTI_AFFINITY":  3,
	"CLUSTER":                    4,
	"MERGE":                      5,
	"SERVICE_LEVEL_CLUSTER":      6,
}

func (x GroupDTO_ConstraintType) Enum() *GroupDTO_ConstraintType {
	p := new(GroupDTO_ConstraintType)
	*p = x
	return p
}
func (x GroupDTO_ConstraintType) String() string {
	return proto.EnumName(GroupDTO_ConstraintType_name, int32(x))
}
func (x *GroupDTO_ConstraintType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GroupDTO_ConstraintType_value, data, "GroupDTO_ConstraintType")
	if err != nil {
		return err
	}
	*x = GroupDTO_ConstraintType(value)
	return nil
}
func (GroupDTO_ConstraintType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{3, 0} }

// Enum notifying expression type used to match entities' property value
// with target value in SelectionSpec
type GroupDTO_SelectionSpec_ExpressionType int32

const (
	GroupDTO_SelectionSpec_EQUAL_TO                 GroupDTO_SelectionSpec_ExpressionType = 0
	GroupDTO_SelectionSpec_NOT_EQUAL_TO             GroupDTO_SelectionSpec_ExpressionType = 1
	GroupDTO_SelectionSpec_LARGER_THAN              GroupDTO_SelectionSpec_ExpressionType = 2
	GroupDTO_SelectionSpec_LARGER_THAN_OR_EQUAL_TO  GroupDTO_SelectionSpec_ExpressionType = 3
	GroupDTO_SelectionSpec_SMALLER_THAN             GroupDTO_SelectionSpec_ExpressionType = 4
	GroupDTO_SelectionSpec_SMALLER_THAN_OR_EQUAL_TO GroupDTO_SelectionSpec_ExpressionType = 5
	GroupDTO_SelectionSpec_CONTAINS                 GroupDTO_SelectionSpec_ExpressionType = 6
	GroupDTO_SelectionSpec_NOT_CONTAINS             GroupDTO_SelectionSpec_ExpressionType = 7
	GroupDTO_SelectionSpec_CONTAINED_BY             GroupDTO_SelectionSpec_ExpressionType = 8
	GroupDTO_SelectionSpec_NOT_CONTAINED_BY         GroupDTO_SelectionSpec_ExpressionType = 9
	GroupDTO_SelectionSpec_REGEX                    GroupDTO_SelectionSpec_ExpressionType = 10
	GroupDTO_SelectionSpec_LIST_OVERLAP             GroupDTO_SelectionSpec_ExpressionType = 11
	GroupDTO_SelectionSpec_LIST_NOT_OVERLAP         GroupDTO_SelectionSpec_ExpressionType = 12
	GroupDTO_SelectionSpec_LIST_FULL_CONTAINS       GroupDTO_SelectionSpec_ExpressionType = 13
	GroupDTO_SelectionSpec_LIST_FULL_CONTAINED_BY   GroupDTO_SelectionSpec_ExpressionType = 14
)

var GroupDTO_SelectionSpec_ExpressionType_name = map[int32]string{
	0:  "EQUAL_TO",
	1:  "NOT_EQUAL_TO",
	2:  "LARGER_THAN",
	3:  "LARGER_THAN_OR_EQUAL_TO",
	4:  "SMALLER_THAN",
	5:  "SMALLER_THAN_OR_EQUAL_TO",
	6:  "CONTAINS",
	7:  "NOT_CONTAINS",
	8:  "CONTAINED_BY",
	9:  "NOT_CONTAINED_BY",
	10: "REGEX",
	11: "LIST_OVERLAP",
	12: "LIST_NOT_OVERLAP",
	13: "LIST_FULL_CONTAINS",
	14: "LIST_FULL_CONTAINED_BY",
}
var GroupDTO_SelectionSpec_ExpressionType_value = map[string]int32{
	"EQUAL_TO":                 0,
	"NOT_EQUAL_TO":             1,
	"LARGER_THAN":              2,
	"LARGER_THAN_OR_EQUAL_TO":  3,
	"SMALLER_THAN":             4,
	"SMALLER_THAN_OR_EQUAL_TO": 5,
	"CONTAINS":                 6,
	"NOT_CONTAINS":             7,
	"CONTAINED_BY":             8,
	"NOT_CONTAINED_BY":         9,
	"REGEX":                    10,
	"LIST_OVERLAP":             11,
	"LIST_NOT_OVERLAP":         12,
	"LIST_FULL_CONTAINS":       13,
	"LIST_FULL_CONTAINED_BY":   14,
}

func (x GroupDTO_SelectionSpec_ExpressionType) Enum() *GroupDTO_SelectionSpec_ExpressionType {
	p := new(GroupDTO_SelectionSpec_ExpressionType)
	*p = x
	return p
}
func (x GroupDTO_SelectionSpec_ExpressionType) String() string {
	return proto.EnumName(GroupDTO_SelectionSpec_ExpressionType_name, int32(x))
}
func (x *GroupDTO_SelectionSpec_ExpressionType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GroupDTO_SelectionSpec_ExpressionType_value, data, "GroupDTO_SelectionSpec_ExpressionType")
	if err != nil {
		return err
	}
	*x = GroupDTO_SelectionSpec_ExpressionType(value)
	return nil
}
func (GroupDTO_SelectionSpec_ExpressionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{3, 5, 0}
}

type NotificationDTO_Severity int32

const (
	NotificationDTO_UNKNOWN  NotificationDTO_Severity = 0
	NotificationDTO_NORMAL   NotificationDTO_Severity = 1
	NotificationDTO_MINOR    NotificationDTO_Severity = 2
	NotificationDTO_MAJOR    NotificationDTO_Severity = 3
	NotificationDTO_CRITICAL NotificationDTO_Severity = 4
)

var NotificationDTO_Severity_name = map[int32]string{
	0: "UNKNOWN",
	1: "NORMAL",
	2: "MINOR",
	3: "MAJOR",
	4: "CRITICAL",
}
var NotificationDTO_Severity_value = map[string]int32{
	"UNKNOWN":  0,
	"NORMAL":   1,
	"MINOR":    2,
	"MAJOR":    3,
	"CRITICAL": 4,
}

func (x NotificationDTO_Severity) Enum() *NotificationDTO_Severity {
	p := new(NotificationDTO_Severity)
	*p = x
	return p
}
func (x NotificationDTO_Severity) String() string {
	return proto.EnumName(NotificationDTO_Severity_name, int32(x))
}
func (x *NotificationDTO_Severity) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NotificationDTO_Severity_value, data, "NotificationDTO_Severity")
	if err != nil {
		return err
	}
	*x = NotificationDTO_Severity(value)
	return nil
}
func (NotificationDTO_Severity) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{5, 0} }

type CustomTypeDef_MetadataNamespace int32

const (
	CustomTypeDef_UNKNOWN            CustomTypeDef_MetadataNamespace = 0
	CustomTypeDef_NETWORK_POLICY_EPG CustomTypeDef_MetadataNamespace = 1
)

var CustomTypeDef_MetadataNamespace_name = map[int32]string{
	0: "UNKNOWN",
	1: "NETWORK_POLICY_EPG",
}
var CustomTypeDef_MetadataNamespace_value = map[string]int32{
	"UNKNOWN":            0,
	"NETWORK_POLICY_EPG": 1,
}

func (x CustomTypeDef_MetadataNamespace) Enum() *CustomTypeDef_MetadataNamespace {
	p := new(CustomTypeDef_MetadataNamespace)
	*p = x
	return p
}
func (x CustomTypeDef_MetadataNamespace) String() string {
	return proto.EnumName(CustomTypeDef_MetadataNamespace_name, int32(x))
}
func (x *CustomTypeDef_MetadataNamespace) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CustomTypeDef_MetadataNamespace_value, data, "CustomTypeDef_MetadataNamespace")
	if err != nil {
		return err
	}
	*x = CustomTypeDef_MetadataNamespace(value)
	return nil
}
func (CustomTypeDef_MetadataNamespace) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{6, 0}
}

// Only TCP and UDP are supported.
type FlowDTO_Protocol int32

const (
	FlowDTO_TCP           FlowDTO_Protocol = 1
	FlowDTO_UDP           FlowDTO_Protocol = 2
	FlowDTO_UNKNOWN_PROTO FlowDTO_Protocol = 1000
)

var FlowDTO_Protocol_name = map[int32]string{
	1:    "TCP",
	2:    "UDP",
	1000: "UNKNOWN_PROTO",
}
var FlowDTO_Protocol_value = map[string]int32{
	"TCP":           1,
	"UDP":           2,
	"UNKNOWN_PROTO": 1000,
}

func (x FlowDTO_Protocol) Enum() *FlowDTO_Protocol {
	p := new(FlowDTO_Protocol)
	*p = x
	return p
}
func (x FlowDTO_Protocol) String() string {
	return proto.EnumName(FlowDTO_Protocol_name, int32(x))
}
func (x *FlowDTO_Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FlowDTO_Protocol_value, data, "FlowDTO_Protocol")
	if err != nil {
		return err
	}
	*x = FlowDTO_Protocol(value)
	return nil
}
func (FlowDTO_Protocol) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{8, 0} }

//
// The EntityDTO message represents an Entity discovered in the target that your probe is
// monitoring
//
// Each entity must have a unique ID to identify it in the Operations Manager market.
// Many targets provide unique IDs for their entities, or you can generate your own.
// To guarantee that it's unique, you can give the ID a prefix that identifies your
// probe and the given target.
//
// Specify entity type by setting an 'EntityType' value to the 'entity' field.
//
// The 'displayName' value appears in the product GUI and in reports to identify the entity.
//
// An entity can maintain a list of commodities that it sells (see 'CommodityDTO').
//
// An entity can maintain a map of commodities bought (see {@code CommodityDTO}). Each map key is the unique ID of the
// provider entity. For each provider, the map entry is a list of the commodities bought from that provider.
//
// The entity's list of properties stores metadata about the entity - for example, you would store
// the entity's IP address as a property. To stitch this entity into the Operations Manager topology,
// you will create an ExternalEntityLink. That link includes the properties
// that Operations Manager can use to match the discovered entity and stitch it in.
//
type EntityDTO struct {
	EntityType  *EntityDTO_EntityType `protobuf:"varint,1,req,name=entityType,enum=common_dto.EntityDTO_EntityType" json:"entityType,omitempty"`
	Id          *string               `protobuf:"bytes,2,req,name=id" json:"id,omitempty"`
	DisplayName *string               `protobuf:"bytes,3,opt,name=displayName" json:"displayName,omitempty"`
	// The {@link CommodityDTO} items this entity sells to its consumers.
	// This is a map of sold commodities where
	CommoditiesSold []*CommodityDTO `protobuf:"bytes,4,rep,name=commoditiesSold" json:"commoditiesSold,omitempty"`
	// The {@link CommodityDTO} items this entity buys from the different providers.
	// This is a map of bought commodities where:<ul>
	CommoditiesBought []*EntityDTO_CommodityBought `protobuf:"bytes,5,rep,name=commoditiesBought" json:"commoditiesBought,omitempty"`
	// List of the IDs of the entities that this entity is underlying. For example, an IO Module can underly
	// physical machines, or a physical machine can underly datastores.
	Underlying []string `protobuf:"bytes,6,rep,name=underlying" json:"underlying,omitempty"`
	// list of <string, string, string> namespace, key, value triplets
	EntityProperties []*EntityDTO_EntityProperty `protobuf:"bytes,7,rep,name=entityProperties" json:"entityProperties,omitempty"`
	// Specifies the source of the entity (ie DISCOVERED or PROXY).
	// For further details see the comments for EntityOrigin.
	Origin *EntityDTO_EntityOrigin `protobuf:"varint,8,opt,name=origin,enum=common_dto.EntityDTO_EntityOrigin,def=1" json:"origin,omitempty"`
	// Proxy entities may be replaced by entities discovered by another probe.
	// Some proxy entities are aware of the entity replacing them based on a set of property values.
	// Before replacing they may also transfer the commodity data to the server entity
	ReplacementEntityData *EntityDTO_ReplacementEntityMetaData `protobuf:"bytes,9,opt,name=replacementEntityData" json:"replacementEntityData,omitempty"`
	// Specifies if the entity is monitored or not.
	// If this field is false, state of the entity will be set to NOT_MONITORED in server.
	// NOT_MONITORED state will imply that the entity is not participating in the Market Analysis.
	Monitored *bool `protobuf:"varint,10,opt,name=monitored,def=1" json:"monitored,omitempty"`
	// Specifies the power state of the entity.
	PowerState *EntityDTO_PowerState `protobuf:"varint,11,opt,name=powerState,enum=common_dto.EntityDTO_PowerState,def=1" json:"powerState,omitempty"`
	// Specified properties required for the behavior of the entity as a consumer.
	ConsumerPolicy *EntityDTO_ConsumerPolicy `protobuf:"bytes,12,opt,name=consumerPolicy" json:"consumerPolicy,omitempty"`
	// Specified properties required for the behavior of the entity as a provider.
	ProviderPolicy *EntityDTO_ProviderPolicy `protobuf:"bytes,13,opt,name=providerPolicy" json:"providerPolicy,omitempty"`
	// Specifies ID of the entity that this entity is owned by. For example, an Chassis is
	// owned by Network.
	OwnedBy *string `protobuf:"bytes,14,opt,name=ownedBy" json:"ownedBy,omitempty"`
	// Notifications associated with the entity
	Notification []*NotificationDTO `protobuf:"bytes,15,rep,name=notification" json:"notification,omitempty"`
	// This flag indicates if proxy entity should be kept in repository if it cannot be merged
	// with any real entity. The flag has effect on proxy entities only.
	KeepStandalone *bool `protobuf:"varint,16,opt,name=keepStandalone,def=1" json:"keepStandalone,omitempty"`
	// If there is a related profile, the id can be specified here
	ProfileId *string `protobuf:"bytes,17,opt,name=profileId" json:"profileId,omitempty"`
	// Specifies entity DTO type (can be a new/existing entity or deleted entity).
	UpdateType *UpdateType `protobuf:"varint,18,opt,name=updateType,enum=common_dto.UpdateType,def=0" json:"updateType,omitempty"`
	// List of the IDs of the entities that this entity is layeredOver. For example, a datastore
	// can be layeredOver physical machines; a physical machine can be layeredOver IO Module.
	LayeredOver []string `protobuf:"bytes,19,rep,name=layeredOver" json:"layeredOver,omitempty"`
	// An entity may replace one or more other entities in the topology
	// This attribute allows specification of specific entity or entities to replace based on
	// their id. For example - a VDC may replace a set of resource pools
	ReplacesEntityId []string `protobuf:"bytes,20,rep,name=replacesEntityId" json:"replacesEntityId,omitempty"`
	// Notifies if the entity is in maintenance.
	Maintenance *bool `protobuf:"varint,21,opt,name=maintenance,def=0" json:"maintenance,omitempty"`
	// Collection of entity type's specific data
	//
	// Types that are valid to be assigned to EntityData:
	//	*EntityDTO_StorageData_
	//	*EntityDTO_DiskArrayData_
	//	*EntityDTO_ApplicationData_
	//	*EntityDTO_VirtualMachineData_
	//	*EntityDTO_PhysicalMachineData_
	//	*EntityDTO_VirtualDatacenterData_
	//	*EntityDTO_StorageControllerData_
	//	*EntityDTO_LogicalPoolData_
	//	*EntityDTO_VirtualApplicationData_
	//	*EntityDTO_ProcessorPoolData_
	EntityData isEntityDTO_EntityData `protobuf_oneof:"entity_data"`
	// Data for entities related to the given entity but not specifically part of the
	// the market. For example, PhysicalMachines are related to
	// Memory, Processor, and IO entities through a composedOf relationship.
	//
	// Types that are valid to be assigned to RelatedEntityData:
	//	*EntityDTO_VirtualMachineRelatedData_
	//	*EntityDTO_PhysicalMachineRelatedData_
	//	*EntityDTO_StorageControllerRelatedData_
	RelatedEntityData isEntityDTO_RelatedEntityData `protobuf_oneof:"related_entity_data"`
	XXX_unrecognized  []byte                        `json:"-"`
}

func (m *EntityDTO) Reset()                    { *m = EntityDTO{} }
func (m *EntityDTO) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO) ProtoMessage()               {}
func (*EntityDTO) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

const Default_EntityDTO_Origin EntityDTO_EntityOrigin = EntityDTO_DISCOVERED
const Default_EntityDTO_Monitored bool = true
const Default_EntityDTO_PowerState EntityDTO_PowerState = EntityDTO_POWERED_ON
const Default_EntityDTO_KeepStandalone bool = true
const Default_EntityDTO_UpdateType UpdateType = UpdateType_UPDATED
const Default_EntityDTO_Maintenance bool = false

type isEntityDTO_EntityData interface {
	isEntityDTO_EntityData()
}
type isEntityDTO_RelatedEntityData interface {
	isEntityDTO_RelatedEntityData()
}

type EntityDTO_StorageData_ struct {
	StorageData *EntityDTO_StorageData `protobuf:"bytes,500,opt,name=storage_data,json=storageData,oneof"`
}
type EntityDTO_DiskArrayData_ struct {
	DiskArrayData *EntityDTO_DiskArrayData `protobuf:"bytes,501,opt,name=disk_array_data,json=diskArrayData,oneof"`
}
type EntityDTO_ApplicationData_ struct {
	ApplicationData *EntityDTO_ApplicationData `protobuf:"bytes,502,opt,name=application_data,json=applicationData,oneof"`
}
type EntityDTO_VirtualMachineData_ struct {
	VirtualMachineData *EntityDTO_VirtualMachineData `protobuf:"bytes,503,opt,name=virtual_machine_data,json=virtualMachineData,oneof"`
}
type EntityDTO_PhysicalMachineData_ struct {
	PhysicalMachineData *EntityDTO_PhysicalMachineData `protobuf:"bytes,504,opt,name=physical_machine_data,json=physicalMachineData,oneof"`
}
type EntityDTO_VirtualDatacenterData_ struct {
	VirtualDatacenterData *EntityDTO_VirtualDatacenterData `protobuf:"bytes,505,opt,name=virtual_datacenter_data,json=virtualDatacenterData,oneof"`
}
type EntityDTO_StorageControllerData_ struct {
	StorageControllerData *EntityDTO_StorageControllerData `protobuf:"bytes,506,opt,name=storage_controller_data,json=storageControllerData,oneof"`
}
type EntityDTO_LogicalPoolData_ struct {
	LogicalPoolData *EntityDTO_LogicalPoolData `protobuf:"bytes,507,opt,name=logical_pool_data,json=logicalPoolData,oneof"`
}
type EntityDTO_VirtualApplicationData_ struct {
	VirtualApplicationData *EntityDTO_VirtualApplicationData `protobuf:"bytes,508,opt,name=virtual_application_data,json=virtualApplicationData,oneof"`
}
type EntityDTO_ProcessorPoolData_ struct {
	ProcessorPoolData *EntityDTO_ProcessorPoolData `protobuf:"bytes,509,opt,name=processor_pool_data,json=processorPoolData,oneof"`
}
type EntityDTO_VirtualMachineRelatedData_ struct {
	VirtualMachineRelatedData *EntityDTO_VirtualMachineRelatedData `protobuf:"bytes,1000,opt,name=virtual_machine_related_data,json=virtualMachineRelatedData,oneof"`
}
type EntityDTO_PhysicalMachineRelatedData_ struct {
	PhysicalMachineRelatedData *EntityDTO_PhysicalMachineRelatedData `protobuf:"bytes,1001,opt,name=physical_machine_related_data,json=physicalMachineRelatedData,oneof"`
}
type EntityDTO_StorageControllerRelatedData_ struct {
	StorageControllerRelatedData *EntityDTO_StorageControllerRelatedData `protobuf:"bytes,1002,opt,name=storage_controller_related_data,json=storageControllerRelatedData,oneof"`
}

func (*EntityDTO_StorageData_) isEntityDTO_EntityData()                         {}
func (*EntityDTO_DiskArrayData_) isEntityDTO_EntityData()                       {}
func (*EntityDTO_ApplicationData_) isEntityDTO_EntityData()                     {}
func (*EntityDTO_VirtualMachineData_) isEntityDTO_EntityData()                  {}
func (*EntityDTO_PhysicalMachineData_) isEntityDTO_EntityData()                 {}
func (*EntityDTO_VirtualDatacenterData_) isEntityDTO_EntityData()               {}
func (*EntityDTO_StorageControllerData_) isEntityDTO_EntityData()               {}
func (*EntityDTO_LogicalPoolData_) isEntityDTO_EntityData()                     {}
func (*EntityDTO_VirtualApplicationData_) isEntityDTO_EntityData()              {}
func (*EntityDTO_ProcessorPoolData_) isEntityDTO_EntityData()                   {}
func (*EntityDTO_VirtualMachineRelatedData_) isEntityDTO_RelatedEntityData()    {}
func (*EntityDTO_PhysicalMachineRelatedData_) isEntityDTO_RelatedEntityData()   {}
func (*EntityDTO_StorageControllerRelatedData_) isEntityDTO_RelatedEntityData() {}

func (m *EntityDTO) GetEntityData() isEntityDTO_EntityData {
	if m != nil {
		return m.EntityData
	}
	return nil
}
func (m *EntityDTO) GetRelatedEntityData() isEntityDTO_RelatedEntityData {
	if m != nil {
		return m.RelatedEntityData
	}
	return nil
}

func (m *EntityDTO) GetEntityType() EntityDTO_EntityType {
	if m != nil && m.EntityType != nil {
		return *m.EntityType
	}
	return EntityDTO_SWITCH
}

func (m *EntityDTO) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *EntityDTO) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityDTO) GetCommoditiesSold() []*CommodityDTO {
	if m != nil {
		return m.CommoditiesSold
	}
	return nil
}

func (m *EntityDTO) GetCommoditiesBought() []*EntityDTO_CommodityBought {
	if m != nil {
		return m.CommoditiesBought
	}
	return nil
}

func (m *EntityDTO) GetUnderlying() []string {
	if m != nil {
		return m.Underlying
	}
	return nil
}

func (m *EntityDTO) GetEntityProperties() []*EntityDTO_EntityProperty {
	if m != nil {
		return m.EntityProperties
	}
	return nil
}

func (m *EntityDTO) GetOrigin() EntityDTO_EntityOrigin {
	if m != nil && m.Origin != nil {
		return *m.Origin
	}
	return Default_EntityDTO_Origin
}

func (m *EntityDTO) GetReplacementEntityData() *EntityDTO_ReplacementEntityMetaData {
	if m != nil {
		return m.ReplacementEntityData
	}
	return nil
}

func (m *EntityDTO) GetMonitored() bool {
	if m != nil && m.Monitored != nil {
		return *m.Monitored
	}
	return Default_EntityDTO_Monitored
}

func (m *EntityDTO) GetPowerState() EntityDTO_PowerState {
	if m != nil && m.PowerState != nil {
		return *m.PowerState
	}
	return Default_EntityDTO_PowerState
}

func (m *EntityDTO) GetConsumerPolicy() *EntityDTO_ConsumerPolicy {
	if m != nil {
		return m.ConsumerPolicy
	}
	return nil
}

func (m *EntityDTO) GetProviderPolicy() *EntityDTO_ProviderPolicy {
	if m != nil {
		return m.ProviderPolicy
	}
	return nil
}

func (m *EntityDTO) GetOwnedBy() string {
	if m != nil && m.OwnedBy != nil {
		return *m.OwnedBy
	}
	return ""
}

func (m *EntityDTO) GetNotification() []*NotificationDTO {
	if m != nil {
		return m.Notification
	}
	return nil
}

func (m *EntityDTO) GetKeepStandalone() bool {
	if m != nil && m.KeepStandalone != nil {
		return *m.KeepStandalone
	}
	return Default_EntityDTO_KeepStandalone
}

func (m *EntityDTO) GetProfileId() string {
	if m != nil && m.ProfileId != nil {
		return *m.ProfileId
	}
	return ""
}

func (m *EntityDTO) GetUpdateType() UpdateType {
	if m != nil && m.UpdateType != nil {
		return *m.UpdateType
	}
	return Default_EntityDTO_UpdateType
}

func (m *EntityDTO) GetLayeredOver() []string {
	if m != nil {
		return m.LayeredOver
	}
	return nil
}

func (m *EntityDTO) GetReplacesEntityId() []string {
	if m != nil {
		return m.ReplacesEntityId
	}
	return nil
}

func (m *EntityDTO) GetMaintenance() bool {
	if m != nil && m.Maintenance != nil {
		return *m.Maintenance
	}
	return Default_EntityDTO_Maintenance
}

func (m *EntityDTO) GetStorageData() *EntityDTO_StorageData {
	if x, ok := m.GetEntityData().(*EntityDTO_StorageData_); ok {
		return x.StorageData
	}
	return nil
}

func (m *EntityDTO) GetDiskArrayData() *EntityDTO_DiskArrayData {
	if x, ok := m.GetEntityData().(*EntityDTO_DiskArrayData_); ok {
		return x.DiskArrayData
	}
	return nil
}

func (m *EntityDTO) GetApplicationData() *EntityDTO_ApplicationData {
	if x, ok := m.GetEntityData().(*EntityDTO_ApplicationData_); ok {
		return x.ApplicationData
	}
	return nil
}

func (m *EntityDTO) GetVirtualMachineData() *EntityDTO_VirtualMachineData {
	if x, ok := m.GetEntityData().(*EntityDTO_VirtualMachineData_); ok {
		return x.VirtualMachineData
	}
	return nil
}

func (m *EntityDTO) GetPhysicalMachineData() *EntityDTO_PhysicalMachineData {
	if x, ok := m.GetEntityData().(*EntityDTO_PhysicalMachineData_); ok {
		return x.PhysicalMachineData
	}
	return nil
}

func (m *EntityDTO) GetVirtualDatacenterData() *EntityDTO_VirtualDatacenterData {
	if x, ok := m.GetEntityData().(*EntityDTO_VirtualDatacenterData_); ok {
		return x.VirtualDatacenterData
	}
	return nil
}

func (m *EntityDTO) GetStorageControllerData() *EntityDTO_StorageControllerData {
	if x, ok := m.GetEntityData().(*EntityDTO_StorageControllerData_); ok {
		return x.StorageControllerData
	}
	return nil
}

func (m *EntityDTO) GetLogicalPoolData() *EntityDTO_LogicalPoolData {
	if x, ok := m.GetEntityData().(*EntityDTO_LogicalPoolData_); ok {
		return x.LogicalPoolData
	}
	return nil
}

func (m *EntityDTO) GetVirtualApplicationData() *EntityDTO_VirtualApplicationData {
	if x, ok := m.GetEntityData().(*EntityDTO_VirtualApplicationData_); ok {
		return x.VirtualApplicationData
	}
	return nil
}

func (m *EntityDTO) GetProcessorPoolData() *EntityDTO_ProcessorPoolData {
	if x, ok := m.GetEntityData().(*EntityDTO_ProcessorPoolData_); ok {
		return x.ProcessorPoolData
	}
	return nil
}

func (m *EntityDTO) GetVirtualMachineRelatedData() *EntityDTO_VirtualMachineRelatedData {
	if x, ok := m.GetRelatedEntityData().(*EntityDTO_VirtualMachineRelatedData_); ok {
		return x.VirtualMachineRelatedData
	}
	return nil
}

func (m *EntityDTO) GetPhysicalMachineRelatedData() *EntityDTO_PhysicalMachineRelatedData {
	if x, ok := m.GetRelatedEntityData().(*EntityDTO_PhysicalMachineRelatedData_); ok {
		return x.PhysicalMachineRelatedData
	}
	return nil
}

func (m *EntityDTO) GetStorageControllerRelatedData() *EntityDTO_StorageControllerRelatedData {
	if x, ok := m.GetRelatedEntityData().(*EntityDTO_StorageControllerRelatedData_); ok {
		return x.StorageControllerRelatedData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EntityDTO) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EntityDTO_OneofMarshaler, _EntityDTO_OneofUnmarshaler, _EntityDTO_OneofSizer, []interface{}{
		(*EntityDTO_StorageData_)(nil),
		(*EntityDTO_DiskArrayData_)(nil),
		(*EntityDTO_ApplicationData_)(nil),
		(*EntityDTO_VirtualMachineData_)(nil),
		(*EntityDTO_PhysicalMachineData_)(nil),
		(*EntityDTO_VirtualDatacenterData_)(nil),
		(*EntityDTO_StorageControllerData_)(nil),
		(*EntityDTO_LogicalPoolData_)(nil),
		(*EntityDTO_VirtualApplicationData_)(nil),
		(*EntityDTO_ProcessorPoolData_)(nil),
		(*EntityDTO_VirtualMachineRelatedData_)(nil),
		(*EntityDTO_PhysicalMachineRelatedData_)(nil),
		(*EntityDTO_StorageControllerRelatedData_)(nil),
	}
}

func _EntityDTO_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EntityDTO)
	// entity_data
	switch x := m.EntityData.(type) {
	case *EntityDTO_StorageData_:
		b.EncodeVarint(500<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageData); err != nil {
			return err
		}
	case *EntityDTO_DiskArrayData_:
		b.EncodeVarint(501<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiskArrayData); err != nil {
			return err
		}
	case *EntityDTO_ApplicationData_:
		b.EncodeVarint(502<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ApplicationData); err != nil {
			return err
		}
	case *EntityDTO_VirtualMachineData_:
		b.EncodeVarint(503<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualMachineData); err != nil {
			return err
		}
	case *EntityDTO_PhysicalMachineData_:
		b.EncodeVarint(504<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PhysicalMachineData); err != nil {
			return err
		}
	case *EntityDTO_VirtualDatacenterData_:
		b.EncodeVarint(505<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualDatacenterData); err != nil {
			return err
		}
	case *EntityDTO_StorageControllerData_:
		b.EncodeVarint(506<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageControllerData); err != nil {
			return err
		}
	case *EntityDTO_LogicalPoolData_:
		b.EncodeVarint(507<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogicalPoolData); err != nil {
			return err
		}
	case *EntityDTO_VirtualApplicationData_:
		b.EncodeVarint(508<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualApplicationData); err != nil {
			return err
		}
	case *EntityDTO_ProcessorPoolData_:
		b.EncodeVarint(509<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProcessorPoolData); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EntityDTO.EntityData has unexpected type %T", x)
	}
	// related_entity_data
	switch x := m.RelatedEntityData.(type) {
	case *EntityDTO_VirtualMachineRelatedData_:
		b.EncodeVarint(1000<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualMachineRelatedData); err != nil {
			return err
		}
	case *EntityDTO_PhysicalMachineRelatedData_:
		b.EncodeVarint(1001<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PhysicalMachineRelatedData); err != nil {
			return err
		}
	case *EntityDTO_StorageControllerRelatedData_:
		b.EncodeVarint(1002<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageControllerRelatedData); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EntityDTO.RelatedEntityData has unexpected type %T", x)
	}
	return nil
}

func _EntityDTO_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EntityDTO)
	switch tag {
	case 500: // entity_data.storage_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_StorageData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_StorageData_{msg}
		return true, err
	case 501: // entity_data.disk_array_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_DiskArrayData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_DiskArrayData_{msg}
		return true, err
	case 502: // entity_data.application_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_ApplicationData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_ApplicationData_{msg}
		return true, err
	case 503: // entity_data.virtual_machine_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_VirtualMachineData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_VirtualMachineData_{msg}
		return true, err
	case 504: // entity_data.physical_machine_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_PhysicalMachineData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_PhysicalMachineData_{msg}
		return true, err
	case 505: // entity_data.virtual_datacenter_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_VirtualDatacenterData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_VirtualDatacenterData_{msg}
		return true, err
	case 506: // entity_data.storage_controller_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_StorageControllerData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_StorageControllerData_{msg}
		return true, err
	case 507: // entity_data.logical_pool_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_LogicalPoolData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_LogicalPoolData_{msg}
		return true, err
	case 508: // entity_data.virtual_application_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_VirtualApplicationData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_VirtualApplicationData_{msg}
		return true, err
	case 509: // entity_data.processor_pool_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_ProcessorPoolData)
		err := b.DecodeMessage(msg)
		m.EntityData = &EntityDTO_ProcessorPoolData_{msg}
		return true, err
	case 1000: // related_entity_data.virtual_machine_related_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_VirtualMachineRelatedData)
		err := b.DecodeMessage(msg)
		m.RelatedEntityData = &EntityDTO_VirtualMachineRelatedData_{msg}
		return true, err
	case 1001: // related_entity_data.physical_machine_related_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_PhysicalMachineRelatedData)
		err := b.DecodeMessage(msg)
		m.RelatedEntityData = &EntityDTO_PhysicalMachineRelatedData_{msg}
		return true, err
	case 1002: // related_entity_data.storage_controller_related_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_StorageControllerRelatedData)
		err := b.DecodeMessage(msg)
		m.RelatedEntityData = &EntityDTO_StorageControllerRelatedData_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EntityDTO_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EntityDTO)
	// entity_data
	switch x := m.EntityData.(type) {
	case *EntityDTO_StorageData_:
		s := proto.Size(x.StorageData)
		n += proto.SizeVarint(500<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_DiskArrayData_:
		s := proto.Size(x.DiskArrayData)
		n += proto.SizeVarint(501<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_ApplicationData_:
		s := proto.Size(x.ApplicationData)
		n += proto.SizeVarint(502<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_VirtualMachineData_:
		s := proto.Size(x.VirtualMachineData)
		n += proto.SizeVarint(503<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_PhysicalMachineData_:
		s := proto.Size(x.PhysicalMachineData)
		n += proto.SizeVarint(504<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_VirtualDatacenterData_:
		s := proto.Size(x.VirtualDatacenterData)
		n += proto.SizeVarint(505<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_StorageControllerData_:
		s := proto.Size(x.StorageControllerData)
		n += proto.SizeVarint(506<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_LogicalPoolData_:
		s := proto.Size(x.LogicalPoolData)
		n += proto.SizeVarint(507<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_VirtualApplicationData_:
		s := proto.Size(x.VirtualApplicationData)
		n += proto.SizeVarint(508<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_ProcessorPoolData_:
		s := proto.Size(x.ProcessorPoolData)
		n += proto.SizeVarint(509<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// related_entity_data
	switch x := m.RelatedEntityData.(type) {
	case *EntityDTO_VirtualMachineRelatedData_:
		s := proto.Size(x.VirtualMachineRelatedData)
		n += proto.SizeVarint(1000<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_PhysicalMachineRelatedData_:
		s := proto.Size(x.PhysicalMachineRelatedData)
		n += proto.SizeVarint(1001<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EntityDTO_StorageControllerRelatedData_:
		s := proto.Size(x.StorageControllerRelatedData)
		n += proto.SizeVarint(1002<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EntityDTO_CommodityBought struct {
	// ID of the provider entity
	ProviderId *string `protobuf:"bytes,1,req,name=providerId" json:"providerId,omitempty"`
	// list of CommodityDTO items bought from the provider entity
	Bought []*CommodityDTO `protobuf:"bytes,2,rep,name=bought" json:"bought,omitempty"`
	// The provider type should be specified along with the provider id
	ProviderType *EntityDTO_EntityType `protobuf:"varint,3,opt,name=providerType,enum=common_dto.EntityDTO_EntityType" json:"providerType,omitempty"`
	// Define a related sub division of the commodities bought - for example vDisk
	SubDivision      *EntityDTO_SubDivisionData `protobuf:"bytes,4,opt,name=subDivision" json:"subDivision,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *EntityDTO_CommodityBought) Reset()                    { *m = EntityDTO_CommodityBought{} }
func (m *EntityDTO_CommodityBought) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_CommodityBought) ProtoMessage()               {}
func (*EntityDTO_CommodityBought) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 0} }

func (m *EntityDTO_CommodityBought) GetProviderId() string {
	if m != nil && m.ProviderId != nil {
		return *m.ProviderId
	}
	return ""
}

func (m *EntityDTO_CommodityBought) GetBought() []*CommodityDTO {
	if m != nil {
		return m.Bought
	}
	return nil
}

func (m *EntityDTO_CommodityBought) GetProviderType() EntityDTO_EntityType {
	if m != nil && m.ProviderType != nil {
		return *m.ProviderType
	}
	return EntityDTO_SWITCH
}

func (m *EntityDTO_CommodityBought) GetSubDivision() *EntityDTO_SubDivisionData {
	if m != nil {
		return m.SubDivision
	}
	return nil
}

type EntityDTO_SubDivisionData struct {
	// id of the SubDivision
	SubDivisionId *string `protobuf:"bytes,1,req,name=subDivisionId" json:"subDivisionId,omitempty"`
	// String identifying the replication type needed for cost calculations
	RedundancyType *string `protobuf:"bytes,2,opt,name=redundancyType" json:"redundancyType,omitempty"`
	// float iops capacity of SubDivision needed for cost calculations
	StorageAccessCapacity *float32 `protobuf:"fixed32,3,opt,name=storageAccessCapacity" json:"storageAccessCapacity,omitempty"`
	// float storage capacity of SubDivision needed for cost calculations
	StorageAmountCapacity *float32 `protobuf:"fixed32,4,opt,name=storageAmountCapacity" json:"storageAmountCapacity,omitempty"`
	// display name for the SubDivision
	DisplayName      *string `protobuf:"bytes,5,opt,name=displayName" json:"displayName,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_SubDivisionData) Reset()                    { *m = EntityDTO_SubDivisionData{} }
func (m *EntityDTO_SubDivisionData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_SubDivisionData) ProtoMessage()               {}
func (*EntityDTO_SubDivisionData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 1} }

func (m *EntityDTO_SubDivisionData) GetSubDivisionId() string {
	if m != nil && m.SubDivisionId != nil {
		return *m.SubDivisionId
	}
	return ""
}

func (m *EntityDTO_SubDivisionData) GetRedundancyType() string {
	if m != nil && m.RedundancyType != nil {
		return *m.RedundancyType
	}
	return ""
}

func (m *EntityDTO_SubDivisionData) GetStorageAccessCapacity() float32 {
	if m != nil && m.StorageAccessCapacity != nil {
		return *m.StorageAccessCapacity
	}
	return 0
}

func (m *EntityDTO_SubDivisionData) GetStorageAmountCapacity() float32 {
	if m != nil && m.StorageAmountCapacity != nil {
		return *m.StorageAmountCapacity
	}
	return 0
}

func (m *EntityDTO_SubDivisionData) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

type EntityDTO_StorageData struct {
	StorageType    *EntityDTO_StorageType `protobuf:"varint,1,opt,name=storageType,enum=common_dto.EntityDTO_StorageType" json:"storageType,omitempty"`
	IpAddress      *string                `protobuf:"bytes,2,opt,name=ipAddress" json:"ipAddress,omitempty"`
	ExportPath     *string                `protobuf:"bytes,3,opt,name=exportPath" json:"exportPath,omitempty"`
	StorageId      *string                `protobuf:"bytes,4,opt,name=storageId" json:"storageId,omitempty"`
	LunUuid        *string                `protobuf:"bytes,5,opt,name=lunUuid" json:"lunUuid,omitempty"`
	LunId          *int32                 `protobuf:"varint,6,opt,name=lunId" json:"lunId,omitempty"`
	Wwn            *string                `protobuf:"bytes,7,opt,name=wwn" json:"wwn,omitempty"`
	NotClusterable *bool                  `protobuf:"varint,8,opt,name=notClusterable,def=0" json:"notClusterable,omitempty"`
	ExternalName   []string               `protobuf:"bytes,9,rep,name=externalName" json:"externalName,omitempty"`
	// Files residing on the storage, if available
	File             []*EntityDTO_StorageData_StorageFileDescriptor `protobuf:"bytes,10,rep,name=file" json:"file,omitempty"`
	XXX_unrecognized []byte                                         `json:"-"`
}

func (m *EntityDTO_StorageData) Reset()                    { *m = EntityDTO_StorageData{} }
func (m *EntityDTO_StorageData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_StorageData) ProtoMessage()               {}
func (*EntityDTO_StorageData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 2} }

const Default_EntityDTO_StorageData_NotClusterable bool = false

func (m *EntityDTO_StorageData) GetStorageType() EntityDTO_StorageType {
	if m != nil && m.StorageType != nil {
		return *m.StorageType
	}
	return EntityDTO_GENERIC_BLOCK
}

func (m *EntityDTO_StorageData) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *EntityDTO_StorageData) GetExportPath() string {
	if m != nil && m.ExportPath != nil {
		return *m.ExportPath
	}
	return ""
}

func (m *EntityDTO_StorageData) GetStorageId() string {
	if m != nil && m.StorageId != nil {
		return *m.StorageId
	}
	return ""
}

func (m *EntityDTO_StorageData) GetLunUuid() string {
	if m != nil && m.LunUuid != nil {
		return *m.LunUuid
	}
	return ""
}

func (m *EntityDTO_StorageData) GetLunId() int32 {
	if m != nil && m.LunId != nil {
		return *m.LunId
	}
	return 0
}

func (m *EntityDTO_StorageData) GetWwn() string {
	if m != nil && m.Wwn != nil {
		return *m.Wwn
	}
	return ""
}

func (m *EntityDTO_StorageData) GetNotClusterable() bool {
	if m != nil && m.NotClusterable != nil {
		return *m.NotClusterable
	}
	return Default_EntityDTO_StorageData_NotClusterable
}

func (m *EntityDTO_StorageData) GetExternalName() []string {
	if m != nil {
		return m.ExternalName
	}
	return nil
}

func (m *EntityDTO_StorageData) GetFile() []*EntityDTO_StorageData_StorageFileDescriptor {
	if m != nil {
		return m.File
	}
	return nil
}

type EntityDTO_StorageData_StorageFileDescriptor struct {
	// Full pathname with Unix-style separators
	Path *string `protobuf:"bytes,1,req,name=path" json:"path,omitempty"`
	// File size
	SizeKb *int64 `protobuf:"varint,2,req,name=sizeKb" json:"sizeKb,omitempty"`
	// Modification time in UTC milliseconds since epoch
	ModificationTimeMs *int64 `protobuf:"varint,3,req,name=modificationTimeMs" json:"modificationTimeMs,omitempty"`
	// Type of the file, if known
	Type *EntityDTO_VirtualMachineFileType `protobuf:"varint,4,opt,name=type,enum=common_dto.EntityDTO_VirtualMachineFileType" json:"type,omitempty"`
	// IOPS provisioned needed for cost calculations
	IopsProvisioned *int32 `protobuf:"varint,5,opt,name=iopsProvisioned" json:"iopsProvisioned,omitempty"`
	// String identifying the replication type needed for cost calculations
	RedundancyType   *string `protobuf:"bytes,6,opt,name=redundancyType" json:"redundancyType,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) Reset() {
	*m = EntityDTO_StorageData_StorageFileDescriptor{}
}
func (m *EntityDTO_StorageData_StorageFileDescriptor) String() string {
	return proto.CompactTextString(m)
}
func (*EntityDTO_StorageData_StorageFileDescriptor) ProtoMessage() {}
func (*EntityDTO_StorageData_StorageFileDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 2, 0}
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetSizeKb() int64 {
	if m != nil && m.SizeKb != nil {
		return *m.SizeKb
	}
	return 0
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetModificationTimeMs() int64 {
	if m != nil && m.ModificationTimeMs != nil {
		return *m.ModificationTimeMs
	}
	return 0
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetType() EntityDTO_VirtualMachineFileType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return EntityDTO_CONFIGURATION
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetIopsProvisioned() int32 {
	if m != nil && m.IopsProvisioned != nil {
		return *m.IopsProvisioned
	}
	return 0
}

func (m *EntityDTO_StorageData_StorageFileDescriptor) GetRedundancyType() string {
	if m != nil && m.RedundancyType != nil {
		return *m.RedundancyType
	}
	return ""
}

type EntityDTO_DiskArrayData struct {
	StorageId []string `protobuf:"bytes,1,rep,name=storageId" json:"storageId,omitempty"`
	// Optionally provide information about the IOPS the disk array is capable of.
	// Either provide the exact IOPS capacity directly, or supply
	// the counts for various types of disks so that it can be computed.
	//
	// Types that are valid to be assigned to IopsData:
	//	*EntityDTO_DiskArrayData_IopsCapacity
	//	*EntityDTO_DiskArrayData_DiskCounts
	IopsData             isEntityDTO_DiskArrayData_IopsData `protobuf_oneof:"iops_data"`
	SupportsVolumeResize *bool                              `protobuf:"varint,4,opt,name=supportsVolumeResize,def=0" json:"supportsVolumeResize,omitempty"`
	XXX_unrecognized     []byte                             `json:"-"`
}

func (m *EntityDTO_DiskArrayData) Reset()                    { *m = EntityDTO_DiskArrayData{} }
func (m *EntityDTO_DiskArrayData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_DiskArrayData) ProtoMessage()               {}
func (*EntityDTO_DiskArrayData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 3} }

const Default_EntityDTO_DiskArrayData_SupportsVolumeResize bool = false

type isEntityDTO_DiskArrayData_IopsData interface {
	isEntityDTO_DiskArrayData_IopsData()
}

type EntityDTO_DiskArrayData_IopsCapacity struct {
	IopsCapacity int64 `protobuf:"varint,2,opt,name=iopsCapacity,oneof"`
}
type EntityDTO_DiskArrayData_DiskCounts struct {
	DiskCounts *EntityDTO_DiskCountData `protobuf:"bytes,3,opt,name=diskCounts,oneof"`
}

func (*EntityDTO_DiskArrayData_IopsCapacity) isEntityDTO_DiskArrayData_IopsData() {}
func (*EntityDTO_DiskArrayData_DiskCounts) isEntityDTO_DiskArrayData_IopsData()   {}

func (m *EntityDTO_DiskArrayData) GetIopsData() isEntityDTO_DiskArrayData_IopsData {
	if m != nil {
		return m.IopsData
	}
	return nil
}

func (m *EntityDTO_DiskArrayData) GetStorageId() []string {
	if m != nil {
		return m.StorageId
	}
	return nil
}

func (m *EntityDTO_DiskArrayData) GetIopsCapacity() int64 {
	if x, ok := m.GetIopsData().(*EntityDTO_DiskArrayData_IopsCapacity); ok {
		return x.IopsCapacity
	}
	return 0
}

func (m *EntityDTO_DiskArrayData) GetDiskCounts() *EntityDTO_DiskCountData {
	if x, ok := m.GetIopsData().(*EntityDTO_DiskArrayData_DiskCounts); ok {
		return x.DiskCounts
	}
	return nil
}

func (m *EntityDTO_DiskArrayData) GetSupportsVolumeResize() bool {
	if m != nil && m.SupportsVolumeResize != nil {
		return *m.SupportsVolumeResize
	}
	return Default_EntityDTO_DiskArrayData_SupportsVolumeResize
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EntityDTO_DiskArrayData) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EntityDTO_DiskArrayData_OneofMarshaler, _EntityDTO_DiskArrayData_OneofUnmarshaler, _EntityDTO_DiskArrayData_OneofSizer, []interface{}{
		(*EntityDTO_DiskArrayData_IopsCapacity)(nil),
		(*EntityDTO_DiskArrayData_DiskCounts)(nil),
	}
}

func _EntityDTO_DiskArrayData_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EntityDTO_DiskArrayData)
	// iops_data
	switch x := m.IopsData.(type) {
	case *EntityDTO_DiskArrayData_IopsCapacity:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.IopsCapacity))
	case *EntityDTO_DiskArrayData_DiskCounts:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiskCounts); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EntityDTO_DiskArrayData.IopsData has unexpected type %T", x)
	}
	return nil
}

func _EntityDTO_DiskArrayData_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EntityDTO_DiskArrayData)
	switch tag {
	case 2: // iops_data.iopsCapacity
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.IopsData = &EntityDTO_DiskArrayData_IopsCapacity{int64(x)}
		return true, err
	case 3: // iops_data.diskCounts
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_DiskCountData)
		err := b.DecodeMessage(msg)
		m.IopsData = &EntityDTO_DiskArrayData_DiskCounts{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EntityDTO_DiskArrayData_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EntityDTO_DiskArrayData)
	// iops_data
	switch x := m.IopsData.(type) {
	case *EntityDTO_DiskArrayData_IopsCapacity:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IopsCapacity))
	case *EntityDTO_DiskArrayData_DiskCounts:
		s := proto.Size(x.DiskCounts)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EntityDTO_LogicalPoolData struct {
	StorageId             []string `protobuf:"bytes,1,rep,name=storageId" json:"storageId,omitempty"`
	ServiceLevelObjective *string  `protobuf:"bytes,2,opt,name=serviceLevelObjective" json:"serviceLevelObjective,omitempty"`
	// Optionally provide information about the IOPS the logical pool is capable of.
	// Either provide the exact IOPS capacity directly, or supply
	// the counts for various types of disks so that it can be computed.
	//
	// Types that are valid to be assigned to IopsData:
	//	*EntityDTO_LogicalPoolData_IopsCapacity
	//	*EntityDTO_LogicalPoolData_DiskCounts
	IopsData         isEntityDTO_LogicalPoolData_IopsData `protobuf_oneof:"iops_data"`
	XXX_unrecognized []byte                               `json:"-"`
}

func (m *EntityDTO_LogicalPoolData) Reset()                    { *m = EntityDTO_LogicalPoolData{} }
func (m *EntityDTO_LogicalPoolData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_LogicalPoolData) ProtoMessage()               {}
func (*EntityDTO_LogicalPoolData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 4} }

type isEntityDTO_LogicalPoolData_IopsData interface {
	isEntityDTO_LogicalPoolData_IopsData()
}

type EntityDTO_LogicalPoolData_IopsCapacity struct {
	IopsCapacity int64 `protobuf:"varint,3,opt,name=iopsCapacity,oneof"`
}
type EntityDTO_LogicalPoolData_DiskCounts struct {
	DiskCounts *EntityDTO_DiskCountData `protobuf:"bytes,4,opt,name=diskCounts,oneof"`
}

func (*EntityDTO_LogicalPoolData_IopsCapacity) isEntityDTO_LogicalPoolData_IopsData() {}
func (*EntityDTO_LogicalPoolData_DiskCounts) isEntityDTO_LogicalPoolData_IopsData()   {}

func (m *EntityDTO_LogicalPoolData) GetIopsData() isEntityDTO_LogicalPoolData_IopsData {
	if m != nil {
		return m.IopsData
	}
	return nil
}

func (m *EntityDTO_LogicalPoolData) GetStorageId() []string {
	if m != nil {
		return m.StorageId
	}
	return nil
}

func (m *EntityDTO_LogicalPoolData) GetServiceLevelObjective() string {
	if m != nil && m.ServiceLevelObjective != nil {
		return *m.ServiceLevelObjective
	}
	return ""
}

func (m *EntityDTO_LogicalPoolData) GetIopsCapacity() int64 {
	if x, ok := m.GetIopsData().(*EntityDTO_LogicalPoolData_IopsCapacity); ok {
		return x.IopsCapacity
	}
	return 0
}

func (m *EntityDTO_LogicalPoolData) GetDiskCounts() *EntityDTO_DiskCountData {
	if x, ok := m.GetIopsData().(*EntityDTO_LogicalPoolData_DiskCounts); ok {
		return x.DiskCounts
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EntityDTO_LogicalPoolData) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EntityDTO_LogicalPoolData_OneofMarshaler, _EntityDTO_LogicalPoolData_OneofUnmarshaler, _EntityDTO_LogicalPoolData_OneofSizer, []interface{}{
		(*EntityDTO_LogicalPoolData_IopsCapacity)(nil),
		(*EntityDTO_LogicalPoolData_DiskCounts)(nil),
	}
}

func _EntityDTO_LogicalPoolData_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EntityDTO_LogicalPoolData)
	// iops_data
	switch x := m.IopsData.(type) {
	case *EntityDTO_LogicalPoolData_IopsCapacity:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.IopsCapacity))
	case *EntityDTO_LogicalPoolData_DiskCounts:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiskCounts); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EntityDTO_LogicalPoolData.IopsData has unexpected type %T", x)
	}
	return nil
}

func _EntityDTO_LogicalPoolData_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EntityDTO_LogicalPoolData)
	switch tag {
	case 3: // iops_data.iopsCapacity
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.IopsData = &EntityDTO_LogicalPoolData_IopsCapacity{int64(x)}
		return true, err
	case 4: // iops_data.diskCounts
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_DiskCountData)
		err := b.DecodeMessage(msg)
		m.IopsData = &EntityDTO_LogicalPoolData_DiskCounts{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EntityDTO_LogicalPoolData_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EntityDTO_LogicalPoolData)
	// iops_data
	switch x := m.IopsData.(type) {
	case *EntityDTO_LogicalPoolData_IopsCapacity:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IopsCapacity))
	case *EntityDTO_LogicalPoolData_DiskCounts:
		s := proto.Size(x.DiskCounts)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EntityDTO_ApplicationData struct {
	Type      *string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	IpAddress *string `protobuf:"bytes,2,opt,name=ipAddress" json:"ipAddress,omitempty"`
	Port      *string `protobuf:"bytes,3,opt,name=port" json:"port,omitempty"`
	// IP address of related application/VM. E.g. it can be database IP for application server.
	RelatedIpAddress *string `protobuf:"bytes,4,opt,name=relatedIpAddress" json:"relatedIpAddress,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_ApplicationData) Reset()                    { *m = EntityDTO_ApplicationData{} }
func (m *EntityDTO_ApplicationData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ApplicationData) ProtoMessage()               {}
func (*EntityDTO_ApplicationData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 5} }

func (m *EntityDTO_ApplicationData) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *EntityDTO_ApplicationData) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *EntityDTO_ApplicationData) GetPort() string {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return ""
}

func (m *EntityDTO_ApplicationData) GetRelatedIpAddress() string {
	if m != nil && m.RelatedIpAddress != nil {
		return *m.RelatedIpAddress
	}
	return ""
}

type EntityDTO_VirtualApplicationData struct {
	Type             *string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	IpAddress        *string `protobuf:"bytes,2,opt,name=ipAddress" json:"ipAddress,omitempty"`
	Port             *int32  `protobuf:"varint,3,opt,name=port" json:"port,omitempty"`
	ServiceType      *string `protobuf:"bytes,4,opt,name=serviceType" json:"serviceType,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_VirtualApplicationData) Reset()         { *m = EntityDTO_VirtualApplicationData{} }
func (m *EntityDTO_VirtualApplicationData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualApplicationData) ProtoMessage()    {}
func (*EntityDTO_VirtualApplicationData) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 6}
}

func (m *EntityDTO_VirtualApplicationData) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *EntityDTO_VirtualApplicationData) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *EntityDTO_VirtualApplicationData) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *EntityDTO_VirtualApplicationData) GetServiceType() string {
	if m != nil && m.ServiceType != nil {
		return *m.ServiceType
	}
	return ""
}

type EntityDTO_VirtualMachineData struct {
	IpAddress []string `protobuf:"bytes,1,rep,name=ipAddress" json:"ipAddress,omitempty"`
	// Carries specific properties for setting Entity State of this VM.
	VmState   *EntityDTO_VMState `protobuf:"bytes,2,opt,name=vmState" json:"vmState,omitempty"`
	GuestName *string            `protobuf:"bytes,3,opt,name=guestName" json:"guestName,omitempty"`
	// Annotation notes
	AnnotationNote []*EntityDTO_VirtualMachineData_AnnotationNote `protobuf:"bytes,4,rep,name=annotationNote" json:"annotationNote,omitempty"`
	// Files in use by vm
	File []*EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor `protobuf:"bytes,5,rep,name=file" json:"file,omitempty"`
	// Total number of CPUs for the VM
	NumCpus *int32 `protobuf:"varint,6,opt,name=numCpus" json:"numCpus,omitempty"`
	// Billing type of a cloud VM -
	// on-demand vs bidding vs dedicated vs reserved
	// Please see {@link VMBillingType}
	//
	BillingType *EntityDTO_VirtualMachineData_VMBillingType `protobuf:"varint,7,opt,name=billingType,enum=common_dto.EntityDTO_VirtualMachineData_VMBillingType" json:"billingType,omitempty"`
	// Cloud bidding VM product description -
	// which is one of the factors contributing to cloud VM cost
	//
	BiddingProductDescription *string `protobuf:"bytes,8,opt,name=biddingProductDescription" json:"biddingProductDescription,omitempty"`
	// Number of Elastic Ips
	//
	NumElasticIps    *int32 `protobuf:"varint,9,opt,name=numElasticIps" json:"numElasticIps,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_VirtualMachineData) Reset()                    { *m = EntityDTO_VirtualMachineData{} }
func (m *EntityDTO_VirtualMachineData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualMachineData) ProtoMessage()               {}
func (*EntityDTO_VirtualMachineData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 7} }

func (m *EntityDTO_VirtualMachineData) GetIpAddress() []string {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *EntityDTO_VirtualMachineData) GetVmState() *EntityDTO_VMState {
	if m != nil {
		return m.VmState
	}
	return nil
}

func (m *EntityDTO_VirtualMachineData) GetGuestName() string {
	if m != nil && m.GuestName != nil {
		return *m.GuestName
	}
	return ""
}

func (m *EntityDTO_VirtualMachineData) GetAnnotationNote() []*EntityDTO_VirtualMachineData_AnnotationNote {
	if m != nil {
		return m.AnnotationNote
	}
	return nil
}

func (m *EntityDTO_VirtualMachineData) GetFile() []*EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *EntityDTO_VirtualMachineData) GetNumCpus() int32 {
	if m != nil && m.NumCpus != nil {
		return *m.NumCpus
	}
	return 0
}

func (m *EntityDTO_VirtualMachineData) GetBillingType() EntityDTO_VirtualMachineData_VMBillingType {
	if m != nil && m.BillingType != nil {
		return *m.BillingType
	}
	return EntityDTO_VirtualMachineData_ONDEMAND
}

func (m *EntityDTO_VirtualMachineData) GetBiddingProductDescription() string {
	if m != nil && m.BiddingProductDescription != nil {
		return *m.BiddingProductDescription
	}
	return ""
}

func (m *EntityDTO_VirtualMachineData) GetNumElasticIps() int32 {
	if m != nil && m.NumElasticIps != nil {
		return *m.NumElasticIps
	}
	return 0
}

// Annotation note (currently used in VC only)
type EntityDTO_VirtualMachineData_AnnotationNote struct {
	// Annotation key
	Key *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	// Annotation value
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_VirtualMachineData_AnnotationNote) Reset() {
	*m = EntityDTO_VirtualMachineData_AnnotationNote{}
}
func (m *EntityDTO_VirtualMachineData_AnnotationNote) String() string {
	return proto.CompactTextString(m)
}
func (*EntityDTO_VirtualMachineData_AnnotationNote) ProtoMessage() {}
func (*EntityDTO_VirtualMachineData_AnnotationNote) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 7, 0}
}

func (m *EntityDTO_VirtualMachineData_AnnotationNote) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *EntityDTO_VirtualMachineData_AnnotationNote) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor struct {
	// Id of the storage on which the file resides
	StorageId *string `protobuf:"bytes,1,req,name=storageId" json:"storageId,omitempty"`
	// Full pathname with Unix-style separators
	Path *string `protobuf:"bytes,2,req,name=path" json:"path,omitempty"`
	// Size of the file
	SizeKb *int64 `protobuf:"varint,3,opt,name=sizeKb" json:"sizeKb,omitempty"`
	// Type of the file, if available
	Type             *EntityDTO_VirtualMachineFileType `protobuf:"varint,4,opt,name=type,enum=common_dto.EntityDTO_VirtualMachineFileType" json:"type,omitempty"`
	XXX_unrecognized []byte                            `json:"-"`
}

func (m *EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) Reset() {
	*m = EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor{}
}
func (m *EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) String() string {
	return proto.CompactTextString(m)
}
func (*EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) ProtoMessage() {}
func (*EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 7, 1}
}

func (m *EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) GetStorageId() string {
	if m != nil && m.StorageId != nil {
		return *m.StorageId
	}
	return ""
}

func (m *EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) GetSizeKb() int64 {
	if m != nil && m.SizeKb != nil {
		return *m.SizeKb
	}
	return 0
}

func (m *EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor) GetType() EntityDTO_VirtualMachineFileType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return EntityDTO_CONFIGURATION
}

type EntityDTO_StorageControllerData struct {
	// Optionally provide information about the IOPS the storage controller is capable of.
	// Either provide the exact IOPS capacity directly, or supply
	// the counts for various types of disks so that it can be computed.
	//
	// Types that are valid to be assigned to IopsData:
	//	*EntityDTO_StorageControllerData_IopsCapacity
	//	*EntityDTO_StorageControllerData_DiskCounts
	IopsData         isEntityDTO_StorageControllerData_IopsData `protobuf_oneof:"iops_data"`
	XXX_unrecognized []byte                                     `json:"-"`
}

func (m *EntityDTO_StorageControllerData) Reset()         { *m = EntityDTO_StorageControllerData{} }
func (m *EntityDTO_StorageControllerData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_StorageControllerData) ProtoMessage()    {}
func (*EntityDTO_StorageControllerData) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 8}
}

type isEntityDTO_StorageControllerData_IopsData interface {
	isEntityDTO_StorageControllerData_IopsData()
}

type EntityDTO_StorageControllerData_IopsCapacity struct {
	IopsCapacity int64 `protobuf:"varint,1,opt,name=iopsCapacity,oneof"`
}
type EntityDTO_StorageControllerData_DiskCounts struct {
	DiskCounts *EntityDTO_DiskCountData `protobuf:"bytes,2,opt,name=diskCounts,oneof"`
}

func (*EntityDTO_StorageControllerData_IopsCapacity) isEntityDTO_StorageControllerData_IopsData() {}
func (*EntityDTO_StorageControllerData_DiskCounts) isEntityDTO_StorageControllerData_IopsData()   {}

func (m *EntityDTO_StorageControllerData) GetIopsData() isEntityDTO_StorageControllerData_IopsData {
	if m != nil {
		return m.IopsData
	}
	return nil
}

func (m *EntityDTO_StorageControllerData) GetIopsCapacity() int64 {
	if x, ok := m.GetIopsData().(*EntityDTO_StorageControllerData_IopsCapacity); ok {
		return x.IopsCapacity
	}
	return 0
}

func (m *EntityDTO_StorageControllerData) GetDiskCounts() *EntityDTO_DiskCountData {
	if x, ok := m.GetIopsData().(*EntityDTO_StorageControllerData_DiskCounts); ok {
		return x.DiskCounts
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EntityDTO_StorageControllerData) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EntityDTO_StorageControllerData_OneofMarshaler, _EntityDTO_StorageControllerData_OneofUnmarshaler, _EntityDTO_StorageControllerData_OneofSizer, []interface{}{
		(*EntityDTO_StorageControllerData_IopsCapacity)(nil),
		(*EntityDTO_StorageControllerData_DiskCounts)(nil),
	}
}

func _EntityDTO_StorageControllerData_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EntityDTO_StorageControllerData)
	// iops_data
	switch x := m.IopsData.(type) {
	case *EntityDTO_StorageControllerData_IopsCapacity:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.IopsCapacity))
	case *EntityDTO_StorageControllerData_DiskCounts:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiskCounts); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EntityDTO_StorageControllerData.IopsData has unexpected type %T", x)
	}
	return nil
}

func _EntityDTO_StorageControllerData_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EntityDTO_StorageControllerData)
	switch tag {
	case 1: // iops_data.iopsCapacity
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.IopsData = &EntityDTO_StorageControllerData_IopsCapacity{int64(x)}
		return true, err
	case 2: // iops_data.diskCounts
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EntityDTO_DiskCountData)
		err := b.DecodeMessage(msg)
		m.IopsData = &EntityDTO_StorageControllerData_DiskCounts{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EntityDTO_StorageControllerData_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EntityDTO_StorageControllerData)
	// iops_data
	switch x := m.IopsData.(type) {
	case *EntityDTO_StorageControllerData_IopsCapacity:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IopsCapacity))
	case *EntityDTO_StorageControllerData_DiskCounts:
		s := proto.Size(x.DiskCounts)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EntityDTO_VMState struct {
	// Notifies if the VirtualMachine is connected.
	Connected        *bool  `protobuf:"varint,1,opt,name=connected,def=1" json:"connected,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_VMState) Reset()                    { *m = EntityDTO_VMState{} }
func (m *EntityDTO_VMState) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_VMState) ProtoMessage()               {}
func (*EntityDTO_VMState) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 9} }

const Default_EntityDTO_VMState_Connected bool = true

func (m *EntityDTO_VMState) GetConnected() bool {
	if m != nil && m.Connected != nil {
		return *m.Connected
	}
	return Default_EntityDTO_VMState_Connected
}

type EntityDTO_PhysicalMachineData struct {
	// Carries specific properties for setting Entity State of this PM.
	PmState *EntityDTO_PMState `protobuf:"bytes,1,opt,name=pmState" json:"pmState,omitempty"`
	// Total number of CPU sockets on the PM.
	NumCpuSockets *int32 `protobuf:"varint,2,opt,name=numCpuSockets" json:"numCpuSockets,omitempty"`
	// Total number of CPU cores on the PM.
	NumCpuCores *int32 `protobuf:"varint,3,opt,name=numCpuCores" json:"numCpuCores,omitempty"`
	// Total number of physical CPU threads on the PM.
	NumCpuThreads *int32 `protobuf:"varint,4,opt,name=numCpuThreads" json:"numCpuThreads,omitempty"`
	// CPU frequency for one CPU core for the PM.
	CpuCoreMhz       *int32 `protobuf:"varint,5,opt,name=cpuCoreMhz" json:"cpuCoreMhz,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_PhysicalMachineData) Reset()         { *m = EntityDTO_PhysicalMachineData{} }
func (m *EntityDTO_PhysicalMachineData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_PhysicalMachineData) ProtoMessage()    {}
func (*EntityDTO_PhysicalMachineData) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 10}
}

func (m *EntityDTO_PhysicalMachineData) GetPmState() *EntityDTO_PMState {
	if m != nil {
		return m.PmState
	}
	return nil
}

func (m *EntityDTO_PhysicalMachineData) GetNumCpuSockets() int32 {
	if m != nil && m.NumCpuSockets != nil {
		return *m.NumCpuSockets
	}
	return 0
}

func (m *EntityDTO_PhysicalMachineData) GetNumCpuCores() int32 {
	if m != nil && m.NumCpuCores != nil {
		return *m.NumCpuCores
	}
	return 0
}

func (m *EntityDTO_PhysicalMachineData) GetNumCpuThreads() int32 {
	if m != nil && m.NumCpuThreads != nil {
		return *m.NumCpuThreads
	}
	return 0
}

func (m *EntityDTO_PhysicalMachineData) GetCpuCoreMhz() int32 {
	if m != nil && m.CpuCoreMhz != nil {
		return *m.CpuCoreMhz
	}
	return 0
}

type EntityDTO_PMState struct {
	// Notifies if the PhysicalMachine is in maintenance.
	// The is only used by PM, for any other entity please use the 'maintenance'
	// field in EntityDTO.
	Maintenance *bool `protobuf:"varint,1,opt,name=maintenance,def=0" json:"maintenance,omitempty"`
	// Notifies if the PhysicalMachine is for failover.
	Failover         *bool  `protobuf:"varint,2,opt,name=failover,def=0" json:"failover,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_PMState) Reset()                    { *m = EntityDTO_PMState{} }
func (m *EntityDTO_PMState) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_PMState) ProtoMessage()               {}
func (*EntityDTO_PMState) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 11} }

const Default_EntityDTO_PMState_Maintenance bool = false
const Default_EntityDTO_PMState_Failover bool = false

func (m *EntityDTO_PMState) GetMaintenance() bool {
	if m != nil && m.Maintenance != nil {
		return *m.Maintenance
	}
	return Default_EntityDTO_PMState_Maintenance
}

func (m *EntityDTO_PMState) GetFailover() bool {
	if m != nil && m.Failover != nil {
		return *m.Failover
	}
	return Default_EntityDTO_PMState_Failover
}

// Properties specific for a particular type of virtual datacenter
type EntityDTO_VirtualDatacenterTypeProps struct {
	Role             *EntityDTO_VirtualDatacenterRole `protobuf:"varint,1,opt,name=role,enum=common_dto.EntityDTO_VirtualDatacenterRole,def=1" json:"role,omitempty"`
	SupportsNesting  *bool                            `protobuf:"varint,2,opt,name=supportsNesting,def=0" json:"supportsNesting,omitempty"`
	NestedConsumer   *bool                            `protobuf:"varint,3,opt,name=nestedConsumer,def=0" json:"nestedConsumer,omitempty"`
	XXX_unrecognized []byte                           `json:"-"`
}

func (m *EntityDTO_VirtualDatacenterTypeProps) Reset()         { *m = EntityDTO_VirtualDatacenterTypeProps{} }
func (m *EntityDTO_VirtualDatacenterTypeProps) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualDatacenterTypeProps) ProtoMessage()    {}
func (*EntityDTO_VirtualDatacenterTypeProps) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 12}
}

const Default_EntityDTO_VirtualDatacenterTypeProps_Role EntityDTO_VirtualDatacenterRole = EntityDTO_CONSUMER
const Default_EntityDTO_VirtualDatacenterTypeProps_SupportsNesting bool = false
const Default_EntityDTO_VirtualDatacenterTypeProps_NestedConsumer bool = false

func (m *EntityDTO_VirtualDatacenterTypeProps) GetRole() EntityDTO_VirtualDatacenterRole {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return Default_EntityDTO_VirtualDatacenterTypeProps_Role
}

func (m *EntityDTO_VirtualDatacenterTypeProps) GetSupportsNesting() bool {
	if m != nil && m.SupportsNesting != nil {
		return *m.SupportsNesting
	}
	return Default_EntityDTO_VirtualDatacenterTypeProps_SupportsNesting
}

func (m *EntityDTO_VirtualDatacenterTypeProps) GetNestedConsumer() bool {
	if m != nil && m.NestedConsumer != nil {
		return *m.NestedConsumer
	}
	return Default_EntityDTO_VirtualDatacenterTypeProps_NestedConsumer
}

type EntityDTO_VirtualDatacenterData struct {
	PmUuid             []string                                    `protobuf:"bytes,1,rep,name=pmUuid" json:"pmUuid,omitempty"`
	VmUuid             []string                                    `protobuf:"bytes,2,rep,name=vmUuid" json:"vmUuid,omitempty"`
	SupportsStorage    *bool                                       `protobuf:"varint,3,opt,name=supportsStorage,def=1" json:"supportsStorage,omitempty"`
	VdcTypeProps       *EntityDTO_VirtualDatacenterTypeProps       `protobuf:"bytes,4,opt,name=vdc_type_props,json=vdcTypeProps" json:"vdc_type_props,omitempty"`
	VdcAllocationModel *EntityDTO_VirtualDatacenterAllocationModel `protobuf:"varint,5,opt,name=vdc_allocation_model,json=vdcAllocationModel,enum=common_dto.EntityDTO_VirtualDatacenterAllocationModel" json:"vdc_allocation_model,omitempty"`
	XXX_unrecognized   []byte                                      `json:"-"`
}

func (m *EntityDTO_VirtualDatacenterData) Reset()         { *m = EntityDTO_VirtualDatacenterData{} }
func (m *EntityDTO_VirtualDatacenterData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualDatacenterData) ProtoMessage()    {}
func (*EntityDTO_VirtualDatacenterData) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 13}
}

const Default_EntityDTO_VirtualDatacenterData_SupportsStorage bool = true

func (m *EntityDTO_VirtualDatacenterData) GetPmUuid() []string {
	if m != nil {
		return m.PmUuid
	}
	return nil
}

func (m *EntityDTO_VirtualDatacenterData) GetVmUuid() []string {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *EntityDTO_VirtualDatacenterData) GetSupportsStorage() bool {
	if m != nil && m.SupportsStorage != nil {
		return *m.SupportsStorage
	}
	return Default_EntityDTO_VirtualDatacenterData_SupportsStorage
}

func (m *EntityDTO_VirtualDatacenterData) GetVdcTypeProps() *EntityDTO_VirtualDatacenterTypeProps {
	if m != nil {
		return m.VdcTypeProps
	}
	return nil
}

func (m *EntityDTO_VirtualDatacenterData) GetVdcAllocationModel() EntityDTO_VirtualDatacenterAllocationModel {
	if m != nil && m.VdcAllocationModel != nil {
		return *m.VdcAllocationModel
	}
	return EntityDTO_ALLOCATION_POOL
}

type EntityDTO_EntityProperty struct {
	Namespace        *string `protobuf:"bytes,1,req,name=namespace" json:"namespace,omitempty"`
	Name             *string `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	Value            *string `protobuf:"bytes,3,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_EntityProperty) Reset()                    { *m = EntityDTO_EntityProperty{} }
func (m *EntityDTO_EntityProperty) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_EntityProperty) ProtoMessage()               {}
func (*EntityDTO_EntityProperty) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 14} }

func (m *EntityDTO_EntityProperty) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *EntityDTO_EntityProperty) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *EntityDTO_EntityProperty) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type EntityDTO_VirtualMachineRelatedData struct {
	Memory           *EntityDTO_MemoryData      `protobuf:"bytes,1,opt,name=memory" json:"memory,omitempty"`
	Processor        []*EntityDTO_ProcessorData `protobuf:"bytes,2,rep,name=processor" json:"processor,omitempty"`
	Io               []*EntityDTO_IoData        `protobuf:"bytes,3,rep,name=io" json:"io,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *EntityDTO_VirtualMachineRelatedData) Reset()         { *m = EntityDTO_VirtualMachineRelatedData{} }
func (m *EntityDTO_VirtualMachineRelatedData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualMachineRelatedData) ProtoMessage()    {}
func (*EntityDTO_VirtualMachineRelatedData) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 15}
}

func (m *EntityDTO_VirtualMachineRelatedData) GetMemory() *EntityDTO_MemoryData {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *EntityDTO_VirtualMachineRelatedData) GetProcessor() []*EntityDTO_ProcessorData {
	if m != nil {
		return m.Processor
	}
	return nil
}

func (m *EntityDTO_VirtualMachineRelatedData) GetIo() []*EntityDTO_IoData {
	if m != nil {
		return m.Io
	}
	return nil
}

type EntityDTO_PhysicalMachineRelatedData struct {
	Memory           *EntityDTO_MemoryData      `protobuf:"bytes,1,opt,name=memory" json:"memory,omitempty"`
	Processor        []*EntityDTO_ProcessorData `protobuf:"bytes,2,rep,name=processor" json:"processor,omitempty"`
	Io               []*EntityDTO_IoData        `protobuf:"bytes,3,rep,name=io" json:"io,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *EntityDTO_PhysicalMachineRelatedData) Reset()         { *m = EntityDTO_PhysicalMachineRelatedData{} }
func (m *EntityDTO_PhysicalMachineRelatedData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_PhysicalMachineRelatedData) ProtoMessage()    {}
func (*EntityDTO_PhysicalMachineRelatedData) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 16}
}

func (m *EntityDTO_PhysicalMachineRelatedData) GetMemory() *EntityDTO_MemoryData {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *EntityDTO_PhysicalMachineRelatedData) GetProcessor() []*EntityDTO_ProcessorData {
	if m != nil {
		return m.Processor
	}
	return nil
}

func (m *EntityDTO_PhysicalMachineRelatedData) GetIo() []*EntityDTO_IoData {
	if m != nil {
		return m.Io
	}
	return nil
}

type EntityDTO_StorageControllerRelatedData struct {
	Memory           *EntityDTO_MemoryData      `protobuf:"bytes,1,opt,name=memory" json:"memory,omitempty"`
	Processor        []*EntityDTO_ProcessorData `protobuf:"bytes,2,rep,name=processor" json:"processor,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *EntityDTO_StorageControllerRelatedData) Reset() {
	*m = EntityDTO_StorageControllerRelatedData{}
}
func (m *EntityDTO_StorageControllerRelatedData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_StorageControllerRelatedData) ProtoMessage()    {}
func (*EntityDTO_StorageControllerRelatedData) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 17}
}

func (m *EntityDTO_StorageControllerRelatedData) GetMemory() *EntityDTO_MemoryData {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *EntityDTO_StorageControllerRelatedData) GetProcessor() []*EntityDTO_ProcessorData {
	if m != nil {
		return m.Processor
	}
	return nil
}

type EntityDTO_MemoryData struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	DisplayName      *string  `protobuf:"bytes,2,opt,name=displayName" json:"displayName,omitempty"`
	Capacity         *float64 `protobuf:"fixed64,3,opt,name=capacity" json:"capacity,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityDTO_MemoryData) Reset()                    { *m = EntityDTO_MemoryData{} }
func (m *EntityDTO_MemoryData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_MemoryData) ProtoMessage()               {}
func (*EntityDTO_MemoryData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 18} }

func (m *EntityDTO_MemoryData) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *EntityDTO_MemoryData) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityDTO_MemoryData) GetCapacity() float64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

type EntityDTO_ProcessorData struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	DisplayName      *string  `protobuf:"bytes,2,opt,name=displayName" json:"displayName,omitempty"`
	Capacity         *float64 `protobuf:"fixed64,3,opt,name=capacity" json:"capacity,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityDTO_ProcessorData) Reset()                    { *m = EntityDTO_ProcessorData{} }
func (m *EntityDTO_ProcessorData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ProcessorData) ProtoMessage()               {}
func (*EntityDTO_ProcessorData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 19} }

func (m *EntityDTO_ProcessorData) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *EntityDTO_ProcessorData) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityDTO_ProcessorData) GetCapacity() float64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

type EntityDTO_IoData struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	DisplayName      *string  `protobuf:"bytes,2,opt,name=displayName" json:"displayName,omitempty"`
	Speed            *float64 `protobuf:"fixed64,3,opt,name=speed" json:"speed,omitempty"`
	MacAddress       *string  `protobuf:"bytes,4,opt,name=macAddress" json:"macAddress,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityDTO_IoData) Reset()                    { *m = EntityDTO_IoData{} }
func (m *EntityDTO_IoData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_IoData) ProtoMessage()               {}
func (*EntityDTO_IoData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 20} }

func (m *EntityDTO_IoData) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *EntityDTO_IoData) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityDTO_IoData) GetSpeed() float64 {
	if m != nil && m.Speed != nil {
		return *m.Speed
	}
	return 0
}

func (m *EntityDTO_IoData) GetMacAddress() string {
	if m != nil && m.MacAddress != nil {
		return *m.MacAddress
	}
	return ""
}

// Represents the counts of various types of disk drives in a disk array.
// Each count represents the number of discovered disks of that speed.
type EntityDTO_DiskCountData struct {
	// If the hybrid flag is present, it modifies how the included disk counts are
	// used to compute IOPS capacity.
	Hybrid *bool `protobuf:"varint,1,opt,name=hybrid,def=0" json:"hybrid,omitempty"`
	// If the flashAvailable flag is present, it modifies how the included disk counts are
	// used to compute IOPS capacity.
	FlashAvailable *bool                  `protobuf:"varint,2,opt,name=flashAvailable,def=0" json:"flashAvailable,omitempty"`
	Disks          []*EntityDTO_DiskCount `protobuf:"bytes,3,rep,name=disks" json:"disks,omitempty"`
	// The calculateFromHostedEntities flag defines whether IOPS capacity must be calculated as
	// sum of capacities of underlying entities (Storages or Disk Arrays)
	CalculateFromHostedEntities *bool  `protobuf:"varint,4,opt,name=calculateFromHostedEntities,def=0" json:"calculateFromHostedEntities,omitempty"`
	XXX_unrecognized            []byte `json:"-"`
}

func (m *EntityDTO_DiskCountData) Reset()                    { *m = EntityDTO_DiskCountData{} }
func (m *EntityDTO_DiskCountData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_DiskCountData) ProtoMessage()               {}
func (*EntityDTO_DiskCountData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 21} }

const Default_EntityDTO_DiskCountData_Hybrid bool = false
const Default_EntityDTO_DiskCountData_FlashAvailable bool = false
const Default_EntityDTO_DiskCountData_CalculateFromHostedEntities bool = false

func (m *EntityDTO_DiskCountData) GetHybrid() bool {
	if m != nil && m.Hybrid != nil {
		return *m.Hybrid
	}
	return Default_EntityDTO_DiskCountData_Hybrid
}

func (m *EntityDTO_DiskCountData) GetFlashAvailable() bool {
	if m != nil && m.FlashAvailable != nil {
		return *m.FlashAvailable
	}
	return Default_EntityDTO_DiskCountData_FlashAvailable
}

func (m *EntityDTO_DiskCountData) GetDisks() []*EntityDTO_DiskCount {
	if m != nil {
		return m.Disks
	}
	return nil
}

func (m *EntityDTO_DiskCountData) GetCalculateFromHostedEntities() bool {
	if m != nil && m.CalculateFromHostedEntities != nil {
		return *m.CalculateFromHostedEntities
	}
	return Default_EntityDTO_DiskCountData_CalculateFromHostedEntities
}

type EntityDTO_DiskCount struct {
	// Usually derived from the NumDiskNames enum
	NumDiskName *string `protobuf:"bytes,1,req,name=numDiskName" json:"numDiskName,omitempty"`
	// The number of discovered disks of this type.
	NumDisks         *int64 `protobuf:"varint,2,req,name=numDisks" json:"numDisks,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_DiskCount) Reset()                    { *m = EntityDTO_DiskCount{} }
func (m *EntityDTO_DiskCount) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_DiskCount) ProtoMessage()               {}
func (*EntityDTO_DiskCount) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 22} }

func (m *EntityDTO_DiskCount) GetNumDiskName() string {
	if m != nil && m.NumDiskName != nil {
		return *m.NumDiskName
	}
	return ""
}

func (m *EntityDTO_DiskCount) GetNumDisks() int64 {
	if m != nil && m.NumDisks != nil {
		return *m.NumDisks
	}
	return 0
}

// Meta data representing the entity that will replace this proxy entity
type EntityDTO_ReplacementEntityMetaData struct {
	// Replacement entity is found by matching the values of the specified properties.
	// The value for the property must be set while building the entity. Specific properties
	// are pre-defined for some entity types. Generic properties can be set using
	// the EntityProperty.
	IdentifyingProp []string `protobuf:"bytes,1,rep,name=identifyingProp" json:"identifyingProp,omitempty"`
	// Proxy entities may also transfer their commodity data to the replacement entity
	BuyingCommTypes  []*EntityDTO_ReplacementCommodityPropertyData `protobuf:"bytes,2,rep,name=buyingCommTypes" json:"buyingCommTypes,omitempty"`
	SellingCommTypes []*EntityDTO_ReplacementCommodityPropertyData `protobuf:"bytes,3,rep,name=sellingCommTypes" json:"sellingCommTypes,omitempty"`
	// Metadata for matching external entity.
	// Name of the external property whose values will be examined
	// and matched to the values of the entity DTO properties listed above
	ExtEntityProp    []string `protobuf:"bytes,4,rep,name=extEntityProp" json:"extEntityProp,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityDTO_ReplacementEntityMetaData) Reset()         { *m = EntityDTO_ReplacementEntityMetaData{} }
func (m *EntityDTO_ReplacementEntityMetaData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_ReplacementEntityMetaData) ProtoMessage()    {}
func (*EntityDTO_ReplacementEntityMetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 23}
}

func (m *EntityDTO_ReplacementEntityMetaData) GetIdentifyingProp() []string {
	if m != nil {
		return m.IdentifyingProp
	}
	return nil
}

func (m *EntityDTO_ReplacementEntityMetaData) GetBuyingCommTypes() []*EntityDTO_ReplacementCommodityPropertyData {
	if m != nil {
		return m.BuyingCommTypes
	}
	return nil
}

func (m *EntityDTO_ReplacementEntityMetaData) GetSellingCommTypes() []*EntityDTO_ReplacementCommodityPropertyData {
	if m != nil {
		return m.SellingCommTypes
	}
	return nil
}

func (m *EntityDTO_ReplacementEntityMetaData) GetExtEntityProp() []string {
	if m != nil {
		return m.ExtEntityProp
	}
	return nil
}

// Data to specify which commodity types and properties
// should be patched when updating data in an entity from
// a proxy entity
type EntityDTO_ReplacementCommodityPropertyData struct {
	CommodityType    *CommodityDTO_CommodityType `protobuf:"varint,1,req,name=commodityType,enum=common_dto.CommodityDTO_CommodityType" json:"commodityType,omitempty"`
	PropertyName     []string                    `protobuf:"bytes,2,rep,name=propertyName" json:"propertyName,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *EntityDTO_ReplacementCommodityPropertyData) Reset() {
	*m = EntityDTO_ReplacementCommodityPropertyData{}
}
func (m *EntityDTO_ReplacementCommodityPropertyData) String() string {
	return proto.CompactTextString(m)
}
func (*EntityDTO_ReplacementCommodityPropertyData) ProtoMessage() {}
func (*EntityDTO_ReplacementCommodityPropertyData) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 24}
}

func (m *EntityDTO_ReplacementCommodityPropertyData) GetCommodityType() CommodityDTO_CommodityType {
	if m != nil && m.CommodityType != nil {
		return *m.CommodityType
	}
	return CommodityDTO_CLUSTER
}

func (m *EntityDTO_ReplacementCommodityPropertyData) GetPropertyName() []string {
	if m != nil {
		return m.PropertyName
	}
	return nil
}

type EntityDTO_ConsumerPolicy struct {
	// Boolean property to indicate if the entity will shop together with other associated
	// entities in the Market for resources.
	ShopsTogether *bool `protobuf:"varint,1,opt,name=shopsTogether,def=0" json:"shopsTogether,omitempty"`
	// Boolean property to indicate if the entity is controllable by Market.
	// Set as false if the entity cannot be moved, righted size, etc...
	Controllable     *bool  `protobuf:"varint,2,opt,name=controllable,def=1" json:"controllable,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_ConsumerPolicy) Reset()                    { *m = EntityDTO_ConsumerPolicy{} }
func (m *EntityDTO_ConsumerPolicy) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ConsumerPolicy) ProtoMessage()               {}
func (*EntityDTO_ConsumerPolicy) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 25} }

const Default_EntityDTO_ConsumerPolicy_ShopsTogether bool = false
const Default_EntityDTO_ConsumerPolicy_Controllable bool = true

func (m *EntityDTO_ConsumerPolicy) GetShopsTogether() bool {
	if m != nil && m.ShopsTogether != nil {
		return *m.ShopsTogether
	}
	return Default_EntityDTO_ConsumerPolicy_ShopsTogether
}

func (m *EntityDTO_ConsumerPolicy) GetControllable() bool {
	if m != nil && m.Controllable != nil {
		return *m.Controllable
	}
	return Default_EntityDTO_ConsumerPolicy_Controllable
}

type EntityDTO_ProviderPolicy struct {
	// Provides availableForPlacement placement policy
	AvailableForPlacement *bool `protobuf:"varint,1,opt,name=availableForPlacement,def=1" json:"availableForPlacement,omitempty"`
	// Provides localSupported placement policy
	LocalSupported   *bool  `protobuf:"varint,2,opt,name=localSupported,def=0" json:"localSupported,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_ProviderPolicy) Reset()                    { *m = EntityDTO_ProviderPolicy{} }
func (m *EntityDTO_ProviderPolicy) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ProviderPolicy) ProtoMessage()               {}
func (*EntityDTO_ProviderPolicy) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 26} }

const Default_EntityDTO_ProviderPolicy_AvailableForPlacement bool = true
const Default_EntityDTO_ProviderPolicy_LocalSupported bool = false

func (m *EntityDTO_ProviderPolicy) GetAvailableForPlacement() bool {
	if m != nil && m.AvailableForPlacement != nil {
		return *m.AvailableForPlacement
	}
	return Default_EntityDTO_ProviderPolicy_AvailableForPlacement
}

func (m *EntityDTO_ProviderPolicy) GetLocalSupported() bool {
	if m != nil && m.LocalSupported != nil {
		return *m.LocalSupported
	}
	return Default_EntityDTO_ProviderPolicy_LocalSupported
}

type EntityDTO_ProcessorPoolData struct {
	// Upper boundary of the Processing Units that can be utilized by VMs on the Processor Pool
	MaximumProcessingUnits *float32 `protobuf:"fixed32,1,req,name=maximumProcessingUnits" json:"maximumProcessingUnits,omitempty"`
	// Available Processing Units for VM on the Processor Pool
	AvailableProcessingUnits *float32 `protobuf:"fixed32,2,req,name=availableProcessingUnits" json:"availableProcessingUnits,omitempty"`
	// Used by Uncapped VMs during busy time
	ReservedProcessingUnits *float32 `protobuf:"fixed32,3,opt,name=reservedProcessingUnits" json:"reservedProcessingUnits,omitempty"`
	XXX_unrecognized        []byte   `json:"-"`
}

func (m *EntityDTO_ProcessorPoolData) Reset()                    { *m = EntityDTO_ProcessorPoolData{} }
func (m *EntityDTO_ProcessorPoolData) String() string            { return proto.CompactTextString(m) }
func (*EntityDTO_ProcessorPoolData) ProtoMessage()               {}
func (*EntityDTO_ProcessorPoolData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 27} }

func (m *EntityDTO_ProcessorPoolData) GetMaximumProcessingUnits() float32 {
	if m != nil && m.MaximumProcessingUnits != nil {
		return *m.MaximumProcessingUnits
	}
	return 0
}

func (m *EntityDTO_ProcessorPoolData) GetAvailableProcessingUnits() float32 {
	if m != nil && m.AvailableProcessingUnits != nil {
		return *m.AvailableProcessingUnits
	}
	return 0
}

func (m *EntityDTO_ProcessorPoolData) GetReservedProcessingUnits() float32 {
	if m != nil && m.ReservedProcessingUnits != nil {
		return *m.ReservedProcessingUnits
	}
	return 0
}

type CommodityDTO struct {
	// Represents the type of commodity. Check {@link Commodity} enumeration for the available
	// types.
	CommodityType *CommodityDTO_CommodityType `protobuf:"varint,1,req,name=commodityType,enum=common_dto.CommodityDTO_CommodityType" json:"commodityType,omitempty"`
	// Represents the key of this commodity.<br>
	// It is a String that represents a specific constraint for this commodity. A commodity bought
	// with a specific key can only buy from a commodity sold that has the same specific key (i.e.
	// those strings should match).
	Key *string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	// Represents how much of this resource is used.
	// Used is meaningful on both the buying and selling side.
	Used *float64 `protobuf:"fixed64,3,opt,name=used" json:"used,omitempty"`
	// Represents the reservation for this resource.
	// Reservation is only meaningful on the buying side and reserves resources for the buying
	// entity. For example, a VirtualMachine may only be using 1GB of RAM, but but if the VM
	// specifies a reservation of 2GB, it ensures the resources are available if its usage spikes.
	Reservation *float64 `protobuf:"fixed64,4,opt,name=reservation" json:"reservation,omitempty"`
	// Represents the maximum capacity of this resource.
	// Capacity should only be given on the selling side and is used to specify the quantity of a commodity
	// being provided by a given entity.
	Capacity *float64 `protobuf:"fixed64,5,opt,name=capacity" json:"capacity,omitempty"`
	// Represents the limit on this resource.
	// Limit is only meaningful on the selling side and is used to limit the amount of a commodity available
	// for sale on the market to below the value specified in the capacity. For example, a VM may have
	// a VMem capacity of 4GB, but 1GB of that is needed by its operating system. In this example, specify
	// a capacity of 4GB and a limit of 3GB to limit VMem available for sale to applications on the VM.
	Limit *float64 `protobuf:"fixed64,6,opt,name=limit" json:"limit,omitempty"`
	Peak  *float64 `protobuf:"fixed64,7,opt,name=peak" json:"peak,omitempty"`
	// Has meaning on both the buying and selling side.
	// Represents whether the commodity is active and currently participating in the market.
	// Commodities that are inactive will not factor into market recommendations but will still be visible
	// in the Operations Manager UI.
	// Commodities are active by default.
	Active *bool `protobuf:"varint,8,opt,name=active,def=1" json:"active,omitempty"`
	// Has meaning on both the buying and selling side.
	// Represents whether the commodity can be resized. This flag is used to signal to the market
	// whether a commodity is eligible to receive resize up and resize down recommendations.
	// Commodities are not resizable by default.
	Resizable *bool `protobuf:"varint,9,opt,name=resizable,def=0" json:"resizable,omitempty"`
	// The 'displayName' value appears in the product GUI and in reports to identify the commodity.
	DisplayName *string `protobuf:"bytes,10,opt,name=displayName" json:"displayName,omitempty"`
	// Implies if the commodity is thin provisioned.
	// If the commodity is thin provisioned it can be overprovisioned by resizing it.
	// By setting to false. we say overprovision by resizing up is not allowed.
	Thin *bool `protobuf:"varint,11,opt,name=thin,def=1" json:"thin,omitempty"`
	// Property to indicate if the 'used' value for the commodity will be computed by the server
	// or if it is provided by Mediation.
	// The default is 'false' since the Mediation will provide the used value and that will be
	// returned by the server.
	// In situations where Mediation is not able to obtain the used values, it should set
	// this property to 'true'.
	ComputedUsed *bool `protobuf:"varint,12,opt,name=computedUsed,def=0" json:"computedUsed,omitempty"`
	// Property to indicate the amount by which the commodity will be resized.
	UsedIncrement *float64 `protobuf:"fixed64,13,opt,name=usedIncrement" json:"usedIncrement,omitempty"`
	// Commodity properties map
	PropMap []*CommodityDTO_PropertiesList `protobuf:"bytes,14,rep,name=propMap" json:"propMap,omitempty"`
	// Specifies if 'used' value is reported as percentage
	IsUsedPct *bool `protobuf:"varint,15,opt,name=isUsedPct,def=0" json:"isUsedPct,omitempty"`
	// Maximum acceptable level of resource utilization (as percentage).
	// All the remainder of the resource above this value is considered as reserved.
	// E.g. for VMware host with a utilizationThresholdPct of 70, 70% of the commodity would be
	// permitted for use by consumers of the resource and 30% would be reserved as HA failover
	// capacity.
	UtilizationThresholdPct *float64 `protobuf:"fixed64,16,opt,name=utilizationThresholdPct" json:"utilizationThresholdPct,omitempty"`
	// Metadata for the invoking a custom pricing function for the commodity.
	PricingMetadata *CommodityDTO_PricingMetadata `protobuf:"bytes,17,opt,name=pricingMetadata" json:"pricingMetadata,omitempty"`
	// Collection of commodity type's specific data
	//
	// Types that are valid to be assigned to CommodityData:
	//	*CommodityDTO_StorageLatencyData_
	//	*CommodityDTO_StorageAccessData_
	//	*CommodityDTO_VstoragePartitionData
	//	*CommodityDTO_StorageProvisionedData_
	CommodityData isCommodityDTO_CommodityData `protobuf_oneof:"commodity_data"`
	// for VMem and VCpu include info on hot add/hot remove
	//
	// Types that are valid to be assigned to HotresizeData:
	//	*CommodityDTO_VmemData
	//	*CommodityDTO_VcpuData
	HotresizeData    isCommodityDTO_HotresizeData `protobuf_oneof:"hotresize_data"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *CommodityDTO) Reset()                    { *m = CommodityDTO{} }
func (m *CommodityDTO) String() string            { return proto.CompactTextString(m) }
func (*CommodityDTO) ProtoMessage()               {}
func (*CommodityDTO) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

const Default_CommodityDTO_Active bool = true
const Default_CommodityDTO_Resizable bool = false
const Default_CommodityDTO_Thin bool = true
const Default_CommodityDTO_ComputedUsed bool = false
const Default_CommodityDTO_IsUsedPct bool = false

type isCommodityDTO_CommodityData interface {
	isCommodityDTO_CommodityData()
}
type isCommodityDTO_HotresizeData interface {
	isCommodityDTO_HotresizeData()
}

type CommodityDTO_StorageLatencyData_ struct {
	StorageLatencyData *CommodityDTO_StorageLatencyData `protobuf:"bytes,500,opt,name=storage_latency_data,json=storageLatencyData,oneof"`
}
type CommodityDTO_StorageAccessData_ struct {
	StorageAccessData *CommodityDTO_StorageAccessData `protobuf:"bytes,501,opt,name=storage_access_data,json=storageAccessData,oneof"`
}
type CommodityDTO_VstoragePartitionData struct {
	VstoragePartitionData *VStoragePartitionData `protobuf:"bytes,502,opt,name=vstorage_partition_data,json=vstoragePartitionData,oneof"`
}
type CommodityDTO_StorageProvisionedData_ struct {
	StorageProvisionedData *CommodityDTO_StorageProvisionedData `protobuf:"bytes,503,opt,name=storage_provisioned_data,json=storageProvisionedData,oneof"`
}
type CommodityDTO_VmemData struct {
	VmemData *CommodityDTO_VMemData `protobuf:"bytes,200,opt,name=vmem_data,json=vmemData,oneof"`
}
type CommodityDTO_VcpuData struct {
	VcpuData *CommodityDTO_VCpuData `protobuf:"bytes,201,opt,name=vcpu_data,json=vcpuData,oneof"`
}

func (*CommodityDTO_StorageLatencyData_) isCommodityDTO_CommodityData()     {}
func (*CommodityDTO_StorageAccessData_) isCommodityDTO_CommodityData()      {}
func (*CommodityDTO_VstoragePartitionData) isCommodityDTO_CommodityData()   {}
func (*CommodityDTO_StorageProvisionedData_) isCommodityDTO_CommodityData() {}
func (*CommodityDTO_VmemData) isCommodityDTO_HotresizeData()                {}
func (*CommodityDTO_VcpuData) isCommodityDTO_HotresizeData()                {}

func (m *CommodityDTO) GetCommodityData() isCommodityDTO_CommodityData {
	if m != nil {
		return m.CommodityData
	}
	return nil
}
func (m *CommodityDTO) GetHotresizeData() isCommodityDTO_HotresizeData {
	if m != nil {
		return m.HotresizeData
	}
	return nil
}

func (m *CommodityDTO) GetCommodityType() CommodityDTO_CommodityType {
	if m != nil && m.CommodityType != nil {
		return *m.CommodityType
	}
	return CommodityDTO_CLUSTER
}

func (m *CommodityDTO) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *CommodityDTO) GetUsed() float64 {
	if m != nil && m.Used != nil {
		return *m.Used
	}
	return 0
}

func (m *CommodityDTO) GetReservation() float64 {
	if m != nil && m.Reservation != nil {
		return *m.Reservation
	}
	return 0
}

func (m *CommodityDTO) GetCapacity() float64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

func (m *CommodityDTO) GetLimit() float64 {
	if m != nil && m.Limit != nil {
		return *m.Limit
	}
	return 0
}

func (m *CommodityDTO) GetPeak() float64 {
	if m != nil && m.Peak != nil {
		return *m.Peak
	}
	return 0
}

func (m *CommodityDTO) GetActive() bool {
	if m != nil && m.Active != nil {
		return *m.Active
	}
	return Default_CommodityDTO_Active
}

func (m *CommodityDTO) GetResizable() bool {
	if m != nil && m.Resizable != nil {
		return *m.Resizable
	}
	return Default_CommodityDTO_Resizable
}

func (m *CommodityDTO) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *CommodityDTO) GetThin() bool {
	if m != nil && m.Thin != nil {
		return *m.Thin
	}
	return Default_CommodityDTO_Thin
}

func (m *CommodityDTO) GetComputedUsed() bool {
	if m != nil && m.ComputedUsed != nil {
		return *m.ComputedUsed
	}
	return Default_CommodityDTO_ComputedUsed
}

func (m *CommodityDTO) GetUsedIncrement() float64 {
	if m != nil && m.UsedIncrement != nil {
		return *m.UsedIncrement
	}
	return 0
}

func (m *CommodityDTO) GetPropMap() []*CommodityDTO_PropertiesList {
	if m != nil {
		return m.PropMap
	}
	return nil
}

func (m *CommodityDTO) GetIsUsedPct() bool {
	if m != nil && m.IsUsedPct != nil {
		return *m.IsUsedPct
	}
	return Default_CommodityDTO_IsUsedPct
}

func (m *CommodityDTO) GetUtilizationThresholdPct() float64 {
	if m != nil && m.UtilizationThresholdPct != nil {
		return *m.UtilizationThresholdPct
	}
	return 0
}

func (m *CommodityDTO) GetPricingMetadata() *CommodityDTO_PricingMetadata {
	if m != nil {
		return m.PricingMetadata
	}
	return nil
}

func (m *CommodityDTO) GetStorageLatencyData() *CommodityDTO_StorageLatencyData {
	if x, ok := m.GetCommodityData().(*CommodityDTO_StorageLatencyData_); ok {
		return x.StorageLatencyData
	}
	return nil
}

func (m *CommodityDTO) GetStorageAccessData() *CommodityDTO_StorageAccessData {
	if x, ok := m.GetCommodityData().(*CommodityDTO_StorageAccessData_); ok {
		return x.StorageAccessData
	}
	return nil
}

func (m *CommodityDTO) GetVstoragePartitionData() *VStoragePartitionData {
	if x, ok := m.GetCommodityData().(*CommodityDTO_VstoragePartitionData); ok {
		return x.VstoragePartitionData
	}
	return nil
}

func (m *CommodityDTO) GetStorageProvisionedData() *CommodityDTO_StorageProvisionedData {
	if x, ok := m.GetCommodityData().(*CommodityDTO_StorageProvisionedData_); ok {
		return x.StorageProvisionedData
	}
	return nil
}

func (m *CommodityDTO) GetVmemData() *CommodityDTO_VMemData {
	if x, ok := m.GetHotresizeData().(*CommodityDTO_VmemData); ok {
		return x.VmemData
	}
	return nil
}

func (m *CommodityDTO) GetVcpuData() *CommodityDTO_VCpuData {
	if x, ok := m.GetHotresizeData().(*CommodityDTO_VcpuData); ok {
		return x.VcpuData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CommodityDTO) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CommodityDTO_OneofMarshaler, _CommodityDTO_OneofUnmarshaler, _CommodityDTO_OneofSizer, []interface{}{
		(*CommodityDTO_StorageLatencyData_)(nil),
		(*CommodityDTO_StorageAccessData_)(nil),
		(*CommodityDTO_VstoragePartitionData)(nil),
		(*CommodityDTO_StorageProvisionedData_)(nil),
		(*CommodityDTO_VmemData)(nil),
		(*CommodityDTO_VcpuData)(nil),
	}
}

func _CommodityDTO_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CommodityDTO)
	// commodity_data
	switch x := m.CommodityData.(type) {
	case *CommodityDTO_StorageLatencyData_:
		b.EncodeVarint(500<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageLatencyData); err != nil {
			return err
		}
	case *CommodityDTO_StorageAccessData_:
		b.EncodeVarint(501<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageAccessData); err != nil {
			return err
		}
	case *CommodityDTO_VstoragePartitionData:
		b.EncodeVarint(502<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VstoragePartitionData); err != nil {
			return err
		}
	case *CommodityDTO_StorageProvisionedData_:
		b.EncodeVarint(503<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageProvisionedData); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CommodityDTO.CommodityData has unexpected type %T", x)
	}
	// hotresize_data
	switch x := m.HotresizeData.(type) {
	case *CommodityDTO_VmemData:
		b.EncodeVarint(200<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VmemData); err != nil {
			return err
		}
	case *CommodityDTO_VcpuData:
		b.EncodeVarint(201<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VcpuData); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CommodityDTO.HotresizeData has unexpected type %T", x)
	}
	return nil
}

func _CommodityDTO_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CommodityDTO)
	switch tag {
	case 500: // commodity_data.storage_latency_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommodityDTO_StorageLatencyData)
		err := b.DecodeMessage(msg)
		m.CommodityData = &CommodityDTO_StorageLatencyData_{msg}
		return true, err
	case 501: // commodity_data.storage_access_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommodityDTO_StorageAccessData)
		err := b.DecodeMessage(msg)
		m.CommodityData = &CommodityDTO_StorageAccessData_{msg}
		return true, err
	case 502: // commodity_data.vstorage_partition_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VStoragePartitionData)
		err := b.DecodeMessage(msg)
		m.CommodityData = &CommodityDTO_VstoragePartitionData{msg}
		return true, err
	case 503: // commodity_data.storage_provisioned_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommodityDTO_StorageProvisionedData)
		err := b.DecodeMessage(msg)
		m.CommodityData = &CommodityDTO_StorageProvisionedData_{msg}
		return true, err
	case 200: // hotresize_data.vmem_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommodityDTO_VMemData)
		err := b.DecodeMessage(msg)
		m.HotresizeData = &CommodityDTO_VmemData{msg}
		return true, err
	case 201: // hotresize_data.vcpu_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommodityDTO_VCpuData)
		err := b.DecodeMessage(msg)
		m.HotresizeData = &CommodityDTO_VcpuData{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CommodityDTO_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CommodityDTO)
	// commodity_data
	switch x := m.CommodityData.(type) {
	case *CommodityDTO_StorageLatencyData_:
		s := proto.Size(x.StorageLatencyData)
		n += proto.SizeVarint(500<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommodityDTO_StorageAccessData_:
		s := proto.Size(x.StorageAccessData)
		n += proto.SizeVarint(501<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommodityDTO_VstoragePartitionData:
		s := proto.Size(x.VstoragePartitionData)
		n += proto.SizeVarint(502<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommodityDTO_StorageProvisionedData_:
		s := proto.Size(x.StorageProvisionedData)
		n += proto.SizeVarint(503<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// hotresize_data
	switch x := m.HotresizeData.(type) {
	case *CommodityDTO_VmemData:
		s := proto.Size(x.VmemData)
		n += proto.SizeVarint(200<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommodityDTO_VcpuData:
		s := proto.Size(x.VcpuData)
		n += proto.SizeVarint(201<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Map property type to list of strings
type CommodityDTO_PropertiesList struct {
	Name             *string  `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Values           []string `protobuf:"bytes,2,rep,name=values" json:"values,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CommodityDTO_PropertiesList) Reset()                    { *m = CommodityDTO_PropertiesList{} }
func (m *CommodityDTO_PropertiesList) String() string            { return proto.CompactTextString(m) }
func (*CommodityDTO_PropertiesList) ProtoMessage()               {}
func (*CommodityDTO_PropertiesList) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1, 0} }

func (m *CommodityDTO_PropertiesList) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *CommodityDTO_PropertiesList) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type CommodityDTO_StorageLatencyData struct {
	SupportsDiskArrayLatency           *bool  `protobuf:"varint,1,opt,name=supportsDiskArrayLatency" json:"supportsDiskArrayLatency,omitempty"`
	SupportsStorageLatency             *bool  `protobuf:"varint,2,opt,name=supportsStorageLatency" json:"supportsStorageLatency,omitempty"`
	SupportsLogicalPoolLatency         *bool  `protobuf:"varint,3,opt,name=supportsLogicalPoolLatency" json:"supportsLogicalPoolLatency,omitempty"`
	SupportsLogicalPoolLatencyCapacity *bool  `protobuf:"varint,4,opt,name=supportsLogicalPoolLatencyCapacity" json:"supportsLogicalPoolLatencyCapacity,omitempty"`
	XXX_unrecognized                   []byte `json:"-"`
}

func (m *CommodityDTO_StorageLatencyData) Reset()         { *m = CommodityDTO_StorageLatencyData{} }
func (m *CommodityDTO_StorageLatencyData) String() string { return proto.CompactTextString(m) }
func (*CommodityDTO_StorageLatencyData) ProtoMessage()    {}
func (*CommodityDTO_StorageLatencyData) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{1, 1}
}

func (m *CommodityDTO_StorageLatencyData) GetSupportsDiskArrayLatency() bool {
	if m != nil && m.SupportsDiskArrayLatency != nil {
		return *m.SupportsDiskArrayLatency
	}
	return false
}

func (m *CommodityDTO_StorageLatencyData) GetSupportsStorageLatency() bool {
	if m != nil && m.SupportsStorageLatency != nil {
		return *m.SupportsStorageLatency
	}
	return false
}

func (m *CommodityDTO_StorageLatencyData) GetSupportsLogicalPoolLatency() bool {
	if m != nil && m.SupportsLogicalPoolLatency != nil {
		return *m.SupportsLogicalPoolLatency
	}
	return false
}

func (m *CommodityDTO_StorageLatencyData) GetSupportsLogicalPoolLatencyCapacity() bool {
	if m != nil && m.SupportsLogicalPoolLatencyCapacity != nil {
		return *m.SupportsLogicalPoolLatencyCapacity
	}
	return false
}

type CommodityDTO_StorageAccessData struct {
	SupportsDiskArrayIOPS   *bool  `protobuf:"varint,1,opt,name=supportsDiskArrayIOPS" json:"supportsDiskArrayIOPS,omitempty"`
	SupportsStorageIOPS     *bool  `protobuf:"varint,2,opt,name=supportsStorageIOPS" json:"supportsStorageIOPS,omitempty"`
	SupportsLogicalPoolIOPS *bool  `protobuf:"varint,3,opt,name=supportsLogicalPoolIOPS" json:"supportsLogicalPoolIOPS,omitempty"`
	XXX_unrecognized        []byte `json:"-"`
}

func (m *CommodityDTO_StorageAccessData) Reset()         { *m = CommodityDTO_StorageAccessData{} }
func (m *CommodityDTO_StorageAccessData) String() string { return proto.CompactTextString(m) }
func (*CommodityDTO_StorageAccessData) ProtoMessage()    {}
func (*CommodityDTO_StorageAccessData) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{1, 2}
}

func (m *CommodityDTO_StorageAccessData) GetSupportsDiskArrayIOPS() bool {
	if m != nil && m.SupportsDiskArrayIOPS != nil {
		return *m.SupportsDiskArrayIOPS
	}
	return false
}

func (m *CommodityDTO_StorageAccessData) GetSupportsStorageIOPS() bool {
	if m != nil && m.SupportsStorageIOPS != nil {
		return *m.SupportsStorageIOPS
	}
	return false
}

func (m *CommodityDTO_StorageAccessData) GetSupportsLogicalPoolIOPS() bool {
	if m != nil && m.SupportsLogicalPoolIOPS != nil {
		return *m.SupportsLogicalPoolIOPS
	}
	return false
}

type CommodityDTO_StorageProvisionedData struct {
	UsedAdjustment   *float64 `protobuf:"fixed64,1,opt,name=usedAdjustment" json:"usedAdjustment,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CommodityDTO_StorageProvisionedData) Reset()         { *m = CommodityDTO_StorageProvisionedData{} }
func (m *CommodityDTO_StorageProvisionedData) String() string { return proto.CompactTextString(m) }
func (*CommodityDTO_StorageProvisionedData) ProtoMessage()    {}
func (*CommodityDTO_StorageProvisionedData) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{1, 3}
}

func (m *CommodityDTO_StorageProvisionedData) GetUsedAdjustment() float64 {
	if m != nil && m.UsedAdjustment != nil {
		return *m.UsedAdjustment
	}
	return 0
}

type CommodityDTO_VMemData struct {
	HotAddSupported  *bool  `protobuf:"varint,1,opt,name=hotAddSupported,def=0" json:"hotAddSupported,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CommodityDTO_VMemData) Reset()                    { *m = CommodityDTO_VMemData{} }
func (m *CommodityDTO_VMemData) String() string            { return proto.CompactTextString(m) }
func (*CommodityDTO_VMemData) ProtoMessage()               {}
func (*CommodityDTO_VMemData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1, 4} }

const Default_CommodityDTO_VMemData_HotAddSupported bool = false

func (m *CommodityDTO_VMemData) GetHotAddSupported() bool {
	if m != nil && m.HotAddSupported != nil {
		return *m.HotAddSupported
	}
	return Default_CommodityDTO_VMemData_HotAddSupported
}

type CommodityDTO_VCpuData struct {
	HotAddSupported    *bool  `protobuf:"varint,1,opt,name=hotAddSupported,def=0" json:"hotAddSupported,omitempty"`
	HotRemoveSupported *bool  `protobuf:"varint,2,opt,name=hotRemoveSupported,def=0" json:"hotRemoveSupported,omitempty"`
	XXX_unrecognized   []byte `json:"-"`
}

func (m *CommodityDTO_VCpuData) Reset()                    { *m = CommodityDTO_VCpuData{} }
func (m *CommodityDTO_VCpuData) String() string            { return proto.CompactTextString(m) }
func (*CommodityDTO_VCpuData) ProtoMessage()               {}
func (*CommodityDTO_VCpuData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1, 5} }

const Default_CommodityDTO_VCpuData_HotAddSupported bool = false
const Default_CommodityDTO_VCpuData_HotRemoveSupported bool = false

func (m *CommodityDTO_VCpuData) GetHotAddSupported() bool {
	if m != nil && m.HotAddSupported != nil {
		return *m.HotAddSupported
	}
	return Default_CommodityDTO_VCpuData_HotAddSupported
}

func (m *CommodityDTO_VCpuData) GetHotRemoveSupported() bool {
	if m != nil && m.HotRemoveSupported != nil {
		return *m.HotRemoveSupported
	}
	return Default_CommodityDTO_VCpuData_HotRemoveSupported
}

// Metadata for invoking a custom pricing function for the commodity
type CommodityDTO_PricingMetadata struct {
	// Namespace of the handler for the pricing function for this commodity
	PricingHandlerNamespace *CustomTypeDef_MetadataNamespace `protobuf:"varint,1,req,name=pricingHandlerNamespace,enum=common_dto.CustomTypeDef_MetadataNamespace" json:"pricingHandlerNamespace,omitempty"`
	XXX_unrecognized        []byte                           `json:"-"`
}

func (m *CommodityDTO_PricingMetadata) Reset()                    { *m = CommodityDTO_PricingMetadata{} }
func (m *CommodityDTO_PricingMetadata) String() string            { return proto.CompactTextString(m) }
func (*CommodityDTO_PricingMetadata) ProtoMessage()               {}
func (*CommodityDTO_PricingMetadata) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1, 6} }

func (m *CommodityDTO_PricingMetadata) GetPricingHandlerNamespace() CustomTypeDef_MetadataNamespace {
	if m != nil && m.PricingHandlerNamespace != nil {
		return *m.PricingHandlerNamespace
	}
	return CustomTypeDef_UNKNOWN
}

// The partition that the VStorage sits on.  Used for display in the UI.
type VStoragePartitionData struct {
	Partition        *string `protobuf:"bytes,1,opt,name=partition" json:"partition,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *VStoragePartitionData) Reset()                    { *m = VStoragePartitionData{} }
func (m *VStoragePartitionData) String() string            { return proto.CompactTextString(m) }
func (*VStoragePartitionData) ProtoMessage()               {}
func (*VStoragePartitionData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *VStoragePartitionData) GetPartition() string {
	if m != nil && m.Partition != nil {
		return *m.Partition
	}
	return ""
}

// GroupDTO message carries information to setup Group and Constraint in server.
type GroupDTO struct {
	// Type of entities included in this group
	// Entity type is optional. If group already exists it can be retrieved from group entities.
	// Entity type can be empty for incremental discovery.
	EntityType *EntityDTO_EntityType `protobuf:"varint,1,opt,name=entity_type,json=entityType,enum=common_dto.EntityDTO_EntityType" json:"entity_type,omitempty"`
	// Display name for the group
	DisplayName *string `protobuf:"bytes,2,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
	// Information about the group
	// If the group is associated with any constraint, this is the place containing constraint information
	// Otherwise, it will be group name
	//
	// Types that are valid to be assigned to Info:
	//	*GroupDTO_GroupName
	//	*GroupDTO_ConstraintInfo_
	Info isGroupDTO_Info `protobuf_oneof:"info"`
	// Members information for the group
	// The group can be either dynamic or static
	// For dynamic group, it will be SelectionSpec used to select group members
	// For static group, it will be MembersList which contains a list of member uuids
	// For merge policy, it will be cluster uuid
	//
	// Types that are valid to be assigned to Members:
	//	*GroupDTO_SelectionSpecList_
	//	*GroupDTO_MemberList
	//	*GroupDTO_AddedAndRemovedMembers
	//	*GroupDTO_SourceGroupId
	Members isGroupDTO_Members `protobuf_oneof:"members"`
	// list of <string, string, string> namespace, key, value triplets
	EntityProperties []*EntityDTO_EntityProperty `protobuf:"bytes,9,rep,name=entityProperties" json:"entityProperties,omitempty"`
	// Specifies group DTO type (can be a new/existing group or deleted group).
	UpdateType       *UpdateType `protobuf:"varint,10,opt,name=updateType,enum=common_dto.UpdateType,def=0" json:"updateType,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *GroupDTO) Reset()                    { *m = GroupDTO{} }
func (m *GroupDTO) String() string            { return proto.CompactTextString(m) }
func (*GroupDTO) ProtoMessage()               {}
func (*GroupDTO) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

const Default_GroupDTO_UpdateType UpdateType = UpdateType_UPDATED

type isGroupDTO_Info interface {
	isGroupDTO_Info()
}
type isGroupDTO_Members interface {
	isGroupDTO_Members()
}

type GroupDTO_GroupName struct {
	GroupName string `protobuf:"bytes,3,opt,name=group_name,json=groupName,oneof"`
}
type GroupDTO_ConstraintInfo_ struct {
	ConstraintInfo *GroupDTO_ConstraintInfo `protobuf:"bytes,4,opt,name=constraint_info,json=constraintInfo,oneof"`
}
type GroupDTO_SelectionSpecList_ struct {
	SelectionSpecList *GroupDTO_SelectionSpecList `protobuf:"bytes,5,opt,name=selection_spec_list,json=selectionSpecList,oneof"`
}
type GroupDTO_MemberList struct {
	MemberList *GroupDTO_MembersList `protobuf:"bytes,6,opt,name=member_list,json=memberList,oneof"`
}
type GroupDTO_AddedAndRemovedMembers struct {
	AddedAndRemovedMembers *GroupDTO_AddedAndRemovedMembersList `protobuf:"bytes,7,opt,name=added_and_removed_members,json=addedAndRemovedMembers,oneof"`
}
type GroupDTO_SourceGroupId struct {
	SourceGroupId string `protobuf:"bytes,8,opt,name=source_group_id,json=sourceGroupId,oneof"`
}

func (*GroupDTO_GroupName) isGroupDTO_Info()                 {}
func (*GroupDTO_ConstraintInfo_) isGroupDTO_Info()           {}
func (*GroupDTO_SelectionSpecList_) isGroupDTO_Members()     {}
func (*GroupDTO_MemberList) isGroupDTO_Members()             {}
func (*GroupDTO_AddedAndRemovedMembers) isGroupDTO_Members() {}
func (*GroupDTO_SourceGroupId) isGroupDTO_Members()          {}

func (m *GroupDTO) GetInfo() isGroupDTO_Info {
	if m != nil {
		return m.Info
	}
	return nil
}
func (m *GroupDTO) GetMembers() isGroupDTO_Members {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *GroupDTO) GetEntityType() EntityDTO_EntityType {
	if m != nil && m.EntityType != nil {
		return *m.EntityType
	}
	return EntityDTO_SWITCH
}

func (m *GroupDTO) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *GroupDTO) GetGroupName() string {
	if x, ok := m.GetInfo().(*GroupDTO_GroupName); ok {
		return x.GroupName
	}
	return ""
}

func (m *GroupDTO) GetConstraintInfo() *GroupDTO_ConstraintInfo {
	if x, ok := m.GetInfo().(*GroupDTO_ConstraintInfo_); ok {
		return x.ConstraintInfo
	}
	return nil
}

func (m *GroupDTO) GetSelectionSpecList() *GroupDTO_SelectionSpecList {
	if x, ok := m.GetMembers().(*GroupDTO_SelectionSpecList_); ok {
		return x.SelectionSpecList
	}
	return nil
}

func (m *GroupDTO) GetMemberList() *GroupDTO_MembersList {
	if x, ok := m.GetMembers().(*GroupDTO_MemberList); ok {
		return x.MemberList
	}
	return nil
}

func (m *GroupDTO) GetAddedAndRemovedMembers() *GroupDTO_AddedAndRemovedMembersList {
	if x, ok := m.GetMembers().(*GroupDTO_AddedAndRemovedMembers); ok {
		return x.AddedAndRemovedMembers
	}
	return nil
}

func (m *GroupDTO) GetSourceGroupId() string {
	if x, ok := m.GetMembers().(*GroupDTO_SourceGroupId); ok {
		return x.SourceGroupId
	}
	return ""
}

func (m *GroupDTO) GetEntityProperties() []*EntityDTO_EntityProperty {
	if m != nil {
		return m.EntityProperties
	}
	return nil
}

func (m *GroupDTO) GetUpdateType() UpdateType {
	if m != nil && m.UpdateType != nil {
		return *m.UpdateType
	}
	return Default_GroupDTO_UpdateType
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GroupDTO) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GroupDTO_OneofMarshaler, _GroupDTO_OneofUnmarshaler, _GroupDTO_OneofSizer, []interface{}{
		(*GroupDTO_GroupName)(nil),
		(*GroupDTO_ConstraintInfo_)(nil),
		(*GroupDTO_SelectionSpecList_)(nil),
		(*GroupDTO_MemberList)(nil),
		(*GroupDTO_AddedAndRemovedMembers)(nil),
		(*GroupDTO_SourceGroupId)(nil),
	}
}

func _GroupDTO_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GroupDTO)
	// info
	switch x := m.Info.(type) {
	case *GroupDTO_GroupName:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.GroupName)
	case *GroupDTO_ConstraintInfo_:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConstraintInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GroupDTO.Info has unexpected type %T", x)
	}
	// members
	switch x := m.Members.(type) {
	case *GroupDTO_SelectionSpecList_:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SelectionSpecList); err != nil {
			return err
		}
	case *GroupDTO_MemberList:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MemberList); err != nil {
			return err
		}
	case *GroupDTO_AddedAndRemovedMembers:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddedAndRemovedMembers); err != nil {
			return err
		}
	case *GroupDTO_SourceGroupId:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.SourceGroupId)
	case nil:
	default:
		return fmt.Errorf("GroupDTO.Members has unexpected type %T", x)
	}
	return nil
}

func _GroupDTO_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GroupDTO)
	switch tag {
	case 3: // info.group_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Info = &GroupDTO_GroupName{x}
		return true, err
	case 4: // info.constraint_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GroupDTO_ConstraintInfo)
		err := b.DecodeMessage(msg)
		m.Info = &GroupDTO_ConstraintInfo_{msg}
		return true, err
	case 5: // members.selection_spec_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GroupDTO_SelectionSpecList)
		err := b.DecodeMessage(msg)
		m.Members = &GroupDTO_SelectionSpecList_{msg}
		return true, err
	case 6: // members.member_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GroupDTO_MembersList)
		err := b.DecodeMessage(msg)
		m.Members = &GroupDTO_MemberList{msg}
		return true, err
	case 7: // members.added_and_removed_members
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GroupDTO_AddedAndRemovedMembersList)
		err := b.DecodeMessage(msg)
		m.Members = &GroupDTO_AddedAndRemovedMembers{msg}
		return true, err
	case 8: // members.source_group_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Members = &GroupDTO_SourceGroupId{x}
		return true, err
	default:
		return false, nil
	}
}

func _GroupDTO_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GroupDTO)
	// info
	switch x := m.Info.(type) {
	case *GroupDTO_GroupName:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.GroupName)))
		n += len(x.GroupName)
	case *GroupDTO_ConstraintInfo_:
		s := proto.Size(x.ConstraintInfo)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// members
	switch x := m.Members.(type) {
	case *GroupDTO_SelectionSpecList_:
		s := proto.Size(x.SelectionSpecList)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GroupDTO_MemberList:
		s := proto.Size(x.MemberList)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GroupDTO_AddedAndRemovedMembers:
		s := proto.Size(x.AddedAndRemovedMembers)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GroupDTO_SourceGroupId:
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.SourceGroupId)))
		n += len(x.SourceGroupId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// ConstraintInfo contains all necessary information specific for Group associated with Constraint
type GroupDTO_ConstraintInfo struct {
	// Constraint type associated with this group.
	// If it is just a group, then the constraint type should be Group
	ConstraintType *GroupDTO_ConstraintType `protobuf:"varint,1,req,name=constraint_type,json=constraintType,enum=common_dto.GroupDTO_ConstraintType" json:"constraint_type,omitempty"`
	// Constraint id to notify
	ConstraintId *string `protobuf:"bytes,2,req,name=constraint_id,json=constraintId" json:"constraint_id,omitempty"`
	// Notify if this group is for buyers
	IsBuyer *bool `protobuf:"varint,3,opt,name=is_buyer,json=isBuyer,def=0" json:"is_buyer,omitempty"`
	// Notify the type of the seller if it is the buyer group.
	BuyerMetaData *GroupDTO_BuyerMetaData `protobuf:"bytes,4,opt,name=buyer_meta_data,json=buyerMetaData" json:"buyer_meta_data,omitempty"`
	// Notify if this group is for creating complementary group
	NeedComplementary *bool `protobuf:"varint,5,opt,name=need_complementary,json=needComplementary,def=0" json:"need_complementary,omitempty"`
	// Name for the constraint
	ConstraintName *string `protobuf:"bytes,6,req,name=constraint_name,json=constraintName" json:"constraint_name,omitempty"`
	// Consumers that should not be included in the cluster.
	ForExcludedConsumers *bool  `protobuf:"varint,7,opt,name=forExcludedConsumers,def=0" json:"forExcludedConsumers,omitempty"`
	XXX_unrecognized     []byte `json:"-"`
}

func (m *GroupDTO_ConstraintInfo) Reset()                    { *m = GroupDTO_ConstraintInfo{} }
func (m *GroupDTO_ConstraintInfo) String() string            { return proto.CompactTextString(m) }
func (*GroupDTO_ConstraintInfo) ProtoMessage()               {}
func (*GroupDTO_ConstraintInfo) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3, 0} }

const Default_GroupDTO_ConstraintInfo_IsBuyer bool = false
const Default_GroupDTO_ConstraintInfo_NeedComplementary bool = false
const Default_GroupDTO_ConstraintInfo_ForExcludedConsumers bool = false

func (m *GroupDTO_ConstraintInfo) GetConstraintType() GroupDTO_ConstraintType {
	if m != nil && m.ConstraintType != nil {
		return *m.ConstraintType
	}
	return GroupDTO_BUYER_SELLER_AFFINITY
}

func (m *GroupDTO_ConstraintInfo) GetConstraintId() string {
	if m != nil && m.ConstraintId != nil {
		return *m.ConstraintId
	}
	return ""
}

func (m *GroupDTO_ConstraintInfo) GetIsBuyer() bool {
	if m != nil && m.IsBuyer != nil {
		return *m.IsBuyer
	}
	return Default_GroupDTO_ConstraintInfo_IsBuyer
}

func (m *GroupDTO_ConstraintInfo) GetBuyerMetaData() *GroupDTO_BuyerMetaData {
	if m != nil {
		return m.BuyerMetaData
	}
	return nil
}

func (m *GroupDTO_ConstraintInfo) GetNeedComplementary() bool {
	if m != nil && m.NeedComplementary != nil {
		return *m.NeedComplementary
	}
	return Default_GroupDTO_ConstraintInfo_NeedComplementary
}

func (m *GroupDTO_ConstraintInfo) GetConstraintName() string {
	if m != nil && m.ConstraintName != nil {
		return *m.ConstraintName
	}
	return ""
}

func (m *GroupDTO_ConstraintInfo) GetForExcludedConsumers() bool {
	if m != nil && m.ForExcludedConsumers != nil {
		return *m.ForExcludedConsumers
	}
	return Default_GroupDTO_ConstraintInfo_ForExcludedConsumers
}

// List of SelectionSpec to select group members
type GroupDTO_SelectionSpecList struct {
	SelectionSpec    []*GroupDTO_SelectionSpec `protobuf:"bytes,1,rep,name=selection_spec,json=selectionSpec" json:"selection_spec,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *GroupDTO_SelectionSpecList) Reset()                    { *m = GroupDTO_SelectionSpecList{} }
func (m *GroupDTO_SelectionSpecList) String() string            { return proto.CompactTextString(m) }
func (*GroupDTO_SelectionSpecList) ProtoMessage()               {}
func (*GroupDTO_SelectionSpecList) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3, 1} }

func (m *GroupDTO_SelectionSpecList) GetSelectionSpec() []*GroupDTO_SelectionSpec {
	if m != nil {
		return m.SelectionSpec
	}
	return nil
}

// List of member uuids
type GroupDTO_MembersList struct {
	Member           []string `protobuf:"bytes,1,rep,name=member" json:"member,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupDTO_MembersList) Reset()                    { *m = GroupDTO_MembersList{} }
func (m *GroupDTO_MembersList) String() string            { return proto.CompactTextString(m) }
func (*GroupDTO_MembersList) ProtoMessage()               {}
func (*GroupDTO_MembersList) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3, 2} }

func (m *GroupDTO_MembersList) GetMember() []string {
	if m != nil {
		return m.Member
	}
	return nil
}

// List of members added and removed from the group.
type GroupDTO_AddedAndRemovedMembersList struct {
	AddedMembers     []string `protobuf:"bytes,1,rep,name=addedMembers" json:"addedMembers,omitempty"`
	RemovedMembers   []string `protobuf:"bytes,2,rep,name=removedMembers" json:"removedMembers,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupDTO_AddedAndRemovedMembersList) Reset()         { *m = GroupDTO_AddedAndRemovedMembersList{} }
func (m *GroupDTO_AddedAndRemovedMembersList) String() string { return proto.CompactTextString(m) }
func (*GroupDTO_AddedAndRemovedMembersList) ProtoMessage()    {}
func (*GroupDTO_AddedAndRemovedMembersList) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{3, 3}
}

func (m *GroupDTO_AddedAndRemovedMembersList) GetAddedMembers() []string {
	if m != nil {
		return m.AddedMembers
	}
	return nil
}

func (m *GroupDTO_AddedAndRemovedMembersList) GetRemovedMembers() []string {
	if m != nil {
		return m.RemovedMembers
	}
	return nil
}

type GroupDTO_BuyerMetaData struct {
	SellerType       *EntityDTO_EntityType `protobuf:"varint,1,opt,name=seller_type,json=sellerType,enum=common_dto.EntityDTO_EntityType" json:"seller_type,omitempty"`
	AtMost           *int32                `protobuf:"zigzag32,2,opt,name=at_most,json=atMost,def=-1" json:"at_most,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *GroupDTO_BuyerMetaData) Reset()                    { *m = GroupDTO_BuyerMetaData{} }
func (m *GroupDTO_BuyerMetaData) String() string            { return proto.CompactTextString(m) }
func (*GroupDTO_BuyerMetaData) ProtoMessage()               {}
func (*GroupDTO_BuyerMetaData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3, 4} }

const Default_GroupDTO_BuyerMetaData_AtMost int32 = -1

func (m *GroupDTO_BuyerMetaData) GetSellerType() EntityDTO_EntityType {
	if m != nil && m.SellerType != nil {
		return *m.SellerType
	}
	return EntityDTO_SWITCH
}

func (m *GroupDTO_BuyerMetaData) GetAtMost() int32 {
	if m != nil && m.AtMost != nil {
		return *m.AtMost
	}
	return Default_GroupDTO_BuyerMetaData_AtMost
}

// SelectionSpec is used to select group members by checking their property values
type GroupDTO_SelectionSpec struct {
	Property       *string                                `protobuf:"bytes,1,req,name=property" json:"property,omitempty"`
	ExpressionType *GroupDTO_SelectionSpec_ExpressionType `protobuf:"varint,2,req,name=expression_type,json=expressionType,enum=common_dto.GroupDTO_SelectionSpec_ExpressionType" json:"expression_type,omitempty"`
	// Types that are valid to be assigned to PropertyValue:
	//	*GroupDTO_SelectionSpec_PropertyValueDouble
	//	*GroupDTO_SelectionSpec_PropertyValueString
	//	*GroupDTO_SelectionSpec_PropertyValueStringList
	//	*GroupDTO_SelectionSpec_PropertyValueDoubleList
	PropertyValue    isGroupDTO_SelectionSpec_PropertyValue `protobuf_oneof:"propertyValue"`
	XXX_unrecognized []byte                                 `json:"-"`
}

func (m *GroupDTO_SelectionSpec) Reset()                    { *m = GroupDTO_SelectionSpec{} }
func (m *GroupDTO_SelectionSpec) String() string            { return proto.CompactTextString(m) }
func (*GroupDTO_SelectionSpec) ProtoMessage()               {}
func (*GroupDTO_SelectionSpec) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3, 5} }

type isGroupDTO_SelectionSpec_PropertyValue interface {
	isGroupDTO_SelectionSpec_PropertyValue()
}

type GroupDTO_SelectionSpec_PropertyValueDouble struct {
	PropertyValueDouble float64 `protobuf:"fixed64,3,opt,name=property_value_double,json=propertyValueDouble,oneof"`
}
type GroupDTO_SelectionSpec_PropertyValueString struct {
	PropertyValueString string `protobuf:"bytes,4,opt,name=property_value_string,json=propertyValueString,oneof"`
}
type GroupDTO_SelectionSpec_PropertyValueStringList struct {
	PropertyValueStringList *GroupDTO_SelectionSpec_PropertyStringList `protobuf:"bytes,5,opt,name=property_value_string_list,json=propertyValueStringList,oneof"`
}
type GroupDTO_SelectionSpec_PropertyValueDoubleList struct {
	PropertyValueDoubleList *GroupDTO_SelectionSpec_PropertyDoubleList `protobuf:"bytes,6,opt,name=property_value_double_list,json=propertyValueDoubleList,oneof"`
}

func (*GroupDTO_SelectionSpec_PropertyValueDouble) isGroupDTO_SelectionSpec_PropertyValue()     {}
func (*GroupDTO_SelectionSpec_PropertyValueString) isGroupDTO_SelectionSpec_PropertyValue()     {}
func (*GroupDTO_SelectionSpec_PropertyValueStringList) isGroupDTO_SelectionSpec_PropertyValue() {}
func (*GroupDTO_SelectionSpec_PropertyValueDoubleList) isGroupDTO_SelectionSpec_PropertyValue() {}

func (m *GroupDTO_SelectionSpec) GetPropertyValue() isGroupDTO_SelectionSpec_PropertyValue {
	if m != nil {
		return m.PropertyValue
	}
	return nil
}

func (m *GroupDTO_SelectionSpec) GetProperty() string {
	if m != nil && m.Property != nil {
		return *m.Property
	}
	return ""
}

func (m *GroupDTO_SelectionSpec) GetExpressionType() GroupDTO_SelectionSpec_ExpressionType {
	if m != nil && m.ExpressionType != nil {
		return *m.ExpressionType
	}
	return GroupDTO_SelectionSpec_EQUAL_TO
}

func (m *GroupDTO_SelectionSpec) GetPropertyValueDouble() float64 {
	if x, ok := m.GetPropertyValue().(*GroupDTO_SelectionSpec_PropertyValueDouble); ok {
		return x.PropertyValueDouble
	}
	return 0
}

func (m *GroupDTO_SelectionSpec) GetPropertyValueString() string {
	if x, ok := m.GetPropertyValue().(*GroupDTO_SelectionSpec_PropertyValueString); ok {
		return x.PropertyValueString
	}
	return ""
}

func (m *GroupDTO_SelectionSpec) GetPropertyValueStringList() *GroupDTO_SelectionSpec_PropertyStringList {
	if x, ok := m.GetPropertyValue().(*GroupDTO_SelectionSpec_PropertyValueStringList); ok {
		return x.PropertyValueStringList
	}
	return nil
}

func (m *GroupDTO_SelectionSpec) GetPropertyValueDoubleList() *GroupDTO_SelectionSpec_PropertyDoubleList {
	if x, ok := m.GetPropertyValue().(*GroupDTO_SelectionSpec_PropertyValueDoubleList); ok {
		return x.PropertyValueDoubleList
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GroupDTO_SelectionSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GroupDTO_SelectionSpec_OneofMarshaler, _GroupDTO_SelectionSpec_OneofUnmarshaler, _GroupDTO_SelectionSpec_OneofSizer, []interface{}{
		(*GroupDTO_SelectionSpec_PropertyValueDouble)(nil),
		(*GroupDTO_SelectionSpec_PropertyValueString)(nil),
		(*GroupDTO_SelectionSpec_PropertyValueStringList)(nil),
		(*GroupDTO_SelectionSpec_PropertyValueDoubleList)(nil),
	}
}

func _GroupDTO_SelectionSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GroupDTO_SelectionSpec)
	// propertyValue
	switch x := m.PropertyValue.(type) {
	case *GroupDTO_SelectionSpec_PropertyValueDouble:
		b.EncodeVarint(3<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.PropertyValueDouble))
	case *GroupDTO_SelectionSpec_PropertyValueString:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.PropertyValueString)
	case *GroupDTO_SelectionSpec_PropertyValueStringList:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PropertyValueStringList); err != nil {
			return err
		}
	case *GroupDTO_SelectionSpec_PropertyValueDoubleList:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PropertyValueDoubleList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GroupDTO_SelectionSpec.PropertyValue has unexpected type %T", x)
	}
	return nil
}

func _GroupDTO_SelectionSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GroupDTO_SelectionSpec)
	switch tag {
	case 3: // propertyValue.property_value_double
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.PropertyValue = &GroupDTO_SelectionSpec_PropertyValueDouble{math.Float64frombits(x)}
		return true, err
	case 4: // propertyValue.property_value_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PropertyValue = &GroupDTO_SelectionSpec_PropertyValueString{x}
		return true, err
	case 5: // propertyValue.property_value_string_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GroupDTO_SelectionSpec_PropertyStringList)
		err := b.DecodeMessage(msg)
		m.PropertyValue = &GroupDTO_SelectionSpec_PropertyValueStringList{msg}
		return true, err
	case 6: // propertyValue.property_value_double_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GroupDTO_SelectionSpec_PropertyDoubleList)
		err := b.DecodeMessage(msg)
		m.PropertyValue = &GroupDTO_SelectionSpec_PropertyValueDoubleList{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GroupDTO_SelectionSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GroupDTO_SelectionSpec)
	// propertyValue
	switch x := m.PropertyValue.(type) {
	case *GroupDTO_SelectionSpec_PropertyValueDouble:
		n += proto.SizeVarint(3<<3 | proto.WireFixed64)
		n += 8
	case *GroupDTO_SelectionSpec_PropertyValueString:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PropertyValueString)))
		n += len(x.PropertyValueString)
	case *GroupDTO_SelectionSpec_PropertyValueStringList:
		s := proto.Size(x.PropertyValueStringList)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GroupDTO_SelectionSpec_PropertyValueDoubleList:
		s := proto.Size(x.PropertyValueDoubleList)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// List of string type property value
type GroupDTO_SelectionSpec_PropertyStringList struct {
	PropertyValue    []string `protobuf:"bytes,1,rep,name=property_value,json=propertyValue" json:"property_value,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupDTO_SelectionSpec_PropertyStringList) Reset() {
	*m = GroupDTO_SelectionSpec_PropertyStringList{}
}
func (m *GroupDTO_SelectionSpec_PropertyStringList) String() string { return proto.CompactTextString(m) }
func (*GroupDTO_SelectionSpec_PropertyStringList) ProtoMessage()    {}
func (*GroupDTO_SelectionSpec_PropertyStringList) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{3, 5, 0}
}

func (m *GroupDTO_SelectionSpec_PropertyStringList) GetPropertyValue() []string {
	if m != nil {
		return m.PropertyValue
	}
	return nil
}

// List of double type property value
type GroupDTO_SelectionSpec_PropertyDoubleList struct {
	PropertyValue    []float64 `protobuf:"fixed64,1,rep,name=property_value,json=propertyValue" json:"property_value,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *GroupDTO_SelectionSpec_PropertyDoubleList) Reset() {
	*m = GroupDTO_SelectionSpec_PropertyDoubleList{}
}
func (m *GroupDTO_SelectionSpec_PropertyDoubleList) String() string { return proto.CompactTextString(m) }
func (*GroupDTO_SelectionSpec_PropertyDoubleList) ProtoMessage()    {}
func (*GroupDTO_SelectionSpec_PropertyDoubleList) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{3, 5, 1}
}

func (m *GroupDTO_SelectionSpec_PropertyDoubleList) GetPropertyValue() []float64 {
	if m != nil {
		return m.PropertyValue
	}
	return nil
}

// Context data.  This data may be related to action execution
// or this data may be used more generally.
type ContextData struct {
	ContextKey       *string `protobuf:"bytes,1,req,name=contextKey" json:"contextKey,omitempty"`
	ContextValue     *string `protobuf:"bytes,2,req,name=contextValue" json:"contextValue,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ContextData) Reset()                    { *m = ContextData{} }
func (m *ContextData) String() string            { return proto.CompactTextString(m) }
func (*ContextData) ProtoMessage()               {}
func (*ContextData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *ContextData) GetContextKey() string {
	if m != nil && m.ContextKey != nil {
		return *m.ContextKey
	}
	return ""
}

func (m *ContextData) GetContextValue() string {
	if m != nil && m.ContextValue != nil {
		return *m.ContextValue
	}
	return ""
}

// Notification on some event or condition.
type NotificationDTO struct {
	// Event name.
	Event *string `protobuf:"bytes,1,req,name=event" json:"event,omitempty"`
	// Notification category. For known notification categories use NotificationCategoryDTO enumeration.
	Category *string `protobuf:"bytes,2,req,name=category" json:"category,omitempty"`
	// Optional notification sub-category.
	SubCategory *string `protobuf:"bytes,3,opt,name=subCategory" json:"subCategory,omitempty"`
	// Optional notification description.
	Description *string `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	// Notification severity.
	Severity         *NotificationDTO_Severity `protobuf:"varint,5,opt,name=severity,enum=common_dto.NotificationDTO_Severity,def=0" json:"severity,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *NotificationDTO) Reset()                    { *m = NotificationDTO{} }
func (m *NotificationDTO) String() string            { return proto.CompactTextString(m) }
func (*NotificationDTO) ProtoMessage()               {}
func (*NotificationDTO) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

const Default_NotificationDTO_Severity NotificationDTO_Severity = NotificationDTO_UNKNOWN

func (m *NotificationDTO) GetEvent() string {
	if m != nil && m.Event != nil {
		return *m.Event
	}
	return ""
}

func (m *NotificationDTO) GetCategory() string {
	if m != nil && m.Category != nil {
		return *m.Category
	}
	return ""
}

func (m *NotificationDTO) GetSubCategory() string {
	if m != nil && m.SubCategory != nil {
		return *m.SubCategory
	}
	return ""
}

func (m *NotificationDTO) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *NotificationDTO) GetSeverity() NotificationDTO_Severity {
	if m != nil && m.Severity != nil {
		return *m.Severity
	}
	return Default_NotificationDTO_Severity
}

// Metadata for creating custom data objects in the Operations Manager
type CustomTypeDef struct {
	// Unique namespace for the data
	Namespace        *CustomTypeDef_MetadataNamespace `protobuf:"varint,1,req,name=namespace,enum=common_dto.CustomTypeDef_MetadataNamespace,def=0" json:"namespace,omitempty"`
	XXX_unrecognized []byte                           `json:"-"`
}

func (m *CustomTypeDef) Reset()                    { *m = CustomTypeDef{} }
func (m *CustomTypeDef) String() string            { return proto.CompactTextString(m) }
func (*CustomTypeDef) ProtoMessage()               {}
func (*CustomTypeDef) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

const Default_CustomTypeDef_Namespace CustomTypeDef_MetadataNamespace = CustomTypeDef_UNKNOWN

func (m *CustomTypeDef) GetNamespace() CustomTypeDef_MetadataNamespace {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return Default_CustomTypeDef_Namespace
}

// This message is mainly used to identify an entity such as VM, via the fields ipAddress,
// port (we can add more identifiers later).
type EntityIdentityData struct {
	// The target entity's IP address.
	IpAddress *string `protobuf:"bytes,1,req,name=ipAddress" json:"ipAddress,omitempty"`
	// The target entity's port number.
	Port             *int32 `protobuf:"varint,2,req,name=port" json:"port,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityIdentityData) Reset()                    { *m = EntityIdentityData{} }
func (m *EntityIdentityData) String() string            { return proto.CompactTextString(m) }
func (*EntityIdentityData) ProtoMessage()               {}
func (*EntityIdentityData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *EntityIdentityData) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *EntityIdentityData) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

// The Flow DTO. This data is used for describing the communication between two entities
// (VMs in NCM). It includes the source, destination entity identity data and flow data
// (protocol, flow amount, latency).
type FlowDTO struct {
	// Source entity identity data
	SourceEntityIdentityData *EntityIdentityData `protobuf:"bytes,1,req,name=sourceEntityIdentityData" json:"sourceEntityIdentityData,omitempty"`
	// Destination entity identity data
	DestEntityIdentityData *EntityIdentityData `protobuf:"bytes,2,req,name=destEntityIdentityData" json:"destEntityIdentityData,omitempty"`
	// The protocol.
	Protocol *FlowDTO_Protocol `protobuf:"varint,3,req,name=protocol,enum=common_dto.FlowDTO_Protocol" json:"protocol,omitempty"`
	// Flow Amount
	FlowAmount *int64 `protobuf:"varint,4,req,name=flowAmount" json:"flowAmount,omitempty"`
	// Flow latency
	Latency *int64 `protobuf:"varint,5,req,name=latency" json:"latency,omitempty"`
	// Transmitted amount
	TransmittedAmount *int64 `protobuf:"varint,6,req,name=transmittedAmount" json:"transmittedAmount,omitempty"`
	// Received amount
	ReceivedAmount   *int64 `protobuf:"varint,7,req,name=receivedAmount" json:"receivedAmount,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *FlowDTO) Reset()                    { *m = FlowDTO{} }
func (m *FlowDTO) String() string            { return proto.CompactTextString(m) }
func (*FlowDTO) ProtoMessage()               {}
func (*FlowDTO) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

func (m *FlowDTO) GetSourceEntityIdentityData() *EntityIdentityData {
	if m != nil {
		return m.SourceEntityIdentityData
	}
	return nil
}

func (m *FlowDTO) GetDestEntityIdentityData() *EntityIdentityData {
	if m != nil {
		return m.DestEntityIdentityData
	}
	return nil
}

func (m *FlowDTO) GetProtocol() FlowDTO_Protocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return FlowDTO_TCP
}

func (m *FlowDTO) GetFlowAmount() int64 {
	if m != nil && m.FlowAmount != nil {
		return *m.FlowAmount
	}
	return 0
}

func (m *FlowDTO) GetLatency() int64 {
	if m != nil && m.Latency != nil {
		return *m.Latency
	}
	return 0
}

func (m *FlowDTO) GetTransmittedAmount() int64 {
	if m != nil && m.TransmittedAmount != nil {
		return *m.TransmittedAmount
	}
	return 0
}

func (m *FlowDTO) GetReceivedAmount() int64 {
	if m != nil && m.ReceivedAmount != nil {
		return *m.ReceivedAmount
	}
	return 0
}

func init() {
	proto.RegisterType((*EntityDTO)(nil), "common_dto.EntityDTO")
	proto.RegisterType((*EntityDTO_CommodityBought)(nil), "common_dto.EntityDTO.CommodityBought")
	proto.RegisterType((*EntityDTO_SubDivisionData)(nil), "common_dto.EntityDTO.SubDivisionData")
	proto.RegisterType((*EntityDTO_StorageData)(nil), "common_dto.EntityDTO.StorageData")
	proto.RegisterType((*EntityDTO_StorageData_StorageFileDescriptor)(nil), "common_dto.EntityDTO.StorageData.StorageFileDescriptor")
	proto.RegisterType((*EntityDTO_DiskArrayData)(nil), "common_dto.EntityDTO.DiskArrayData")
	proto.RegisterType((*EntityDTO_LogicalPoolData)(nil), "common_dto.EntityDTO.LogicalPoolData")
	proto.RegisterType((*EntityDTO_ApplicationData)(nil), "common_dto.EntityDTO.ApplicationData")
	proto.RegisterType((*EntityDTO_VirtualApplicationData)(nil), "common_dto.EntityDTO.VirtualApplicationData")
	proto.RegisterType((*EntityDTO_VirtualMachineData)(nil), "common_dto.EntityDTO.VirtualMachineData")
	proto.RegisterType((*EntityDTO_VirtualMachineData_AnnotationNote)(nil), "common_dto.EntityDTO.VirtualMachineData.AnnotationNote")
	proto.RegisterType((*EntityDTO_VirtualMachineData_VirtualMachineFileDescriptor)(nil), "common_dto.EntityDTO.VirtualMachineData.VirtualMachineFileDescriptor")
	proto.RegisterType((*EntityDTO_StorageControllerData)(nil), "common_dto.EntityDTO.StorageControllerData")
	proto.RegisterType((*EntityDTO_VMState)(nil), "common_dto.EntityDTO.VMState")
	proto.RegisterType((*EntityDTO_PhysicalMachineData)(nil), "common_dto.EntityDTO.PhysicalMachineData")
	proto.RegisterType((*EntityDTO_PMState)(nil), "common_dto.EntityDTO.PMState")
	proto.RegisterType((*EntityDTO_VirtualDatacenterTypeProps)(nil), "common_dto.EntityDTO.VirtualDatacenterTypeProps")
	proto.RegisterType((*EntityDTO_VirtualDatacenterData)(nil), "common_dto.EntityDTO.VirtualDatacenterData")
	proto.RegisterType((*EntityDTO_EntityProperty)(nil), "common_dto.EntityDTO.EntityProperty")
	proto.RegisterType((*EntityDTO_VirtualMachineRelatedData)(nil), "common_dto.EntityDTO.VirtualMachineRelatedData")
	proto.RegisterType((*EntityDTO_PhysicalMachineRelatedData)(nil), "common_dto.EntityDTO.PhysicalMachineRelatedData")
	proto.RegisterType((*EntityDTO_StorageControllerRelatedData)(nil), "common_dto.EntityDTO.StorageControllerRelatedData")
	proto.RegisterType((*EntityDTO_MemoryData)(nil), "common_dto.EntityDTO.MemoryData")
	proto.RegisterType((*EntityDTO_ProcessorData)(nil), "common_dto.EntityDTO.ProcessorData")
	proto.RegisterType((*EntityDTO_IoData)(nil), "common_dto.EntityDTO.IoData")
	proto.RegisterType((*EntityDTO_DiskCountData)(nil), "common_dto.EntityDTO.DiskCountData")
	proto.RegisterType((*EntityDTO_DiskCount)(nil), "common_dto.EntityDTO.DiskCount")
	proto.RegisterType((*EntityDTO_ReplacementEntityMetaData)(nil), "common_dto.EntityDTO.ReplacementEntityMetaData")
	proto.RegisterType((*EntityDTO_ReplacementCommodityPropertyData)(nil), "common_dto.EntityDTO.ReplacementCommodityPropertyData")
	proto.RegisterType((*EntityDTO_ConsumerPolicy)(nil), "common_dto.EntityDTO.ConsumerPolicy")
	proto.RegisterType((*EntityDTO_ProviderPolicy)(nil), "common_dto.EntityDTO.ProviderPolicy")
	proto.RegisterType((*EntityDTO_ProcessorPoolData)(nil), "common_dto.EntityDTO.ProcessorPoolData")
	proto.RegisterType((*CommodityDTO)(nil), "common_dto.CommodityDTO")
	proto.RegisterType((*CommodityDTO_PropertiesList)(nil), "common_dto.CommodityDTO.PropertiesList")
	proto.RegisterType((*CommodityDTO_StorageLatencyData)(nil), "common_dto.CommodityDTO.StorageLatencyData")
	proto.RegisterType((*CommodityDTO_StorageAccessData)(nil), "common_dto.CommodityDTO.StorageAccessData")
	proto.RegisterType((*CommodityDTO_StorageProvisionedData)(nil), "common_dto.CommodityDTO.StorageProvisionedData")
	proto.RegisterType((*CommodityDTO_VMemData)(nil), "common_dto.CommodityDTO.VMemData")
	proto.RegisterType((*CommodityDTO_VCpuData)(nil), "common_dto.CommodityDTO.VCpuData")
	proto.RegisterType((*CommodityDTO_PricingMetadata)(nil), "common_dto.CommodityDTO.PricingMetadata")
	proto.RegisterType((*VStoragePartitionData)(nil), "common_dto.VStoragePartitionData")
	proto.RegisterType((*GroupDTO)(nil), "common_dto.GroupDTO")
	proto.RegisterType((*GroupDTO_ConstraintInfo)(nil), "common_dto.GroupDTO.ConstraintInfo")
	proto.RegisterType((*GroupDTO_SelectionSpecList)(nil), "common_dto.GroupDTO.SelectionSpecList")
	proto.RegisterType((*GroupDTO_MembersList)(nil), "common_dto.GroupDTO.MembersList")
	proto.RegisterType((*GroupDTO_AddedAndRemovedMembersList)(nil), "common_dto.GroupDTO.AddedAndRemovedMembersList")
	proto.RegisterType((*GroupDTO_BuyerMetaData)(nil), "common_dto.GroupDTO.BuyerMetaData")
	proto.RegisterType((*GroupDTO_SelectionSpec)(nil), "common_dto.GroupDTO.SelectionSpec")
	proto.RegisterType((*GroupDTO_SelectionSpec_PropertyStringList)(nil), "common_dto.GroupDTO.SelectionSpec.PropertyStringList")
	proto.RegisterType((*GroupDTO_SelectionSpec_PropertyDoubleList)(nil), "common_dto.GroupDTO.SelectionSpec.PropertyDoubleList")
	proto.RegisterType((*ContextData)(nil), "common_dto.ContextData")
	proto.RegisterType((*NotificationDTO)(nil), "common_dto.NotificationDTO")
	proto.RegisterType((*CustomTypeDef)(nil), "common_dto.CustomTypeDef")
	proto.RegisterType((*EntityIdentityData)(nil), "common_dto.EntityIdentityData")
	proto.RegisterType((*FlowDTO)(nil), "common_dto.FlowDTO")
	proto.RegisterEnum("common_dto.UpdateType", UpdateType_name, UpdateType_value)
	proto.RegisterEnum("common_dto.EntityDTO_EntityType", EntityDTO_EntityType_name, EntityDTO_EntityType_value)
	proto.RegisterEnum("common_dto.EntityDTO_PowerState", EntityDTO_PowerState_name, EntityDTO_PowerState_value)
	proto.RegisterEnum("common_dto.EntityDTO_StorageType", EntityDTO_StorageType_name, EntityDTO_StorageType_value)
	proto.RegisterEnum("common_dto.EntityDTO_VirtualMachineFileType", EntityDTO_VirtualMachineFileType_name, EntityDTO_VirtualMachineFileType_value)
	proto.RegisterEnum("common_dto.EntityDTO_VirtualDatacenterRole", EntityDTO_VirtualDatacenterRole_name, EntityDTO_VirtualDatacenterRole_value)
	proto.RegisterEnum("common_dto.EntityDTO_VirtualDatacenterAllocationModel", EntityDTO_VirtualDatacenterAllocationModel_name, EntityDTO_VirtualDatacenterAllocationModel_value)
	proto.RegisterEnum("common_dto.EntityDTO_NumDiskNames", EntityDTO_NumDiskNames_name, EntityDTO_NumDiskNames_value)
	proto.RegisterEnum("common_dto.EntityDTO_EntityOrigin", EntityDTO_EntityOrigin_name, EntityDTO_EntityOrigin_value)
	proto.RegisterEnum("common_dto.EntityDTO_VirtualMachineData_VMBillingType", EntityDTO_VirtualMachineData_VMBillingType_name, EntityDTO_VirtualMachineData_VMBillingType_value)
	proto.RegisterEnum("common_dto.CommodityDTO_CommodityType", CommodityDTO_CommodityType_name, CommodityDTO_CommodityType_value)
	proto.RegisterEnum("common_dto.GroupDTO_ConstraintType", GroupDTO_ConstraintType_name, GroupDTO_ConstraintType_value)
	proto.RegisterEnum("common_dto.GroupDTO_SelectionSpec_ExpressionType", GroupDTO_SelectionSpec_ExpressionType_name, GroupDTO_SelectionSpec_ExpressionType_value)
	proto.RegisterEnum("common_dto.NotificationDTO_Severity", NotificationDTO_Severity_name, NotificationDTO_Severity_value)
	proto.RegisterEnum("common_dto.CustomTypeDef_MetadataNamespace", CustomTypeDef_MetadataNamespace_name, CustomTypeDef_MetadataNamespace_value)
	proto.RegisterEnum("common_dto.FlowDTO_Protocol", FlowDTO_Protocol_name, FlowDTO_Protocol_value)
}

func init() { proto.RegisterFile("CommonDTO.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 6195 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x7c, 0x49, 0x8f, 0xe4, 0x46,
	0x76, 0x70, 0x67, 0xd6, 0xfe, 0x6a, 0x8b, 0x8a, 0xde, 0xb2, 0x53, 0x2d, 0xa9, 0x94, 0xda, 0x5a,
	0x52, 0xab, 0xd5, 0x6a, 0xad, 0xd3, 0x33, 0xdf, 0x8c, 0x98, 0x4c, 0x56, 0x15, 0xd5, 0x99, 0x64,
	0x2a, 0xc8, 0xac, 0x56, 0x0b, 0xdf, 0x7c, 0x14, 0x2b, 0x19, 0x5d, 0xc5, 0x51, 0x66, 0x32, 0x41,
	0x32, 0x4b, 0x5d, 0x9a, 0xef, 0x60, 0xc0, 0x80, 0x7d, 0xf0, 0xc9, 0x80, 0x0d, 0x18, 0x1e, 0xd8,
	0x27, 0x9f, 0xe6, 0xe6, 0x83, 0x61, 0x0c, 0x60, 0x1f, 0x7c, 0xf1, 0x72, 0xf0, 0x3f, 0xb0, 0x61,
	0xc0, 0xa7, 0xb1, 0x01, 0x5f, 0x0c, 0xef, 0x0b, 0x6c, 0xbc, 0x08, 0x92, 0x49, 0xe6, 0x52, 0xd5,
	0x1a, 0x0d, 0x60, 0xf8, 0x52, 0xc8, 0x78, 0x5b, 0x44, 0xbc, 0x78, 0xf1, 0xe2, 0xbd, 0x17, 0xc1,
	0x82, 0x6d, 0x35, 0xe8, 0xf7, 0x83, 0x41, 0xc3, 0x36, 0xef, 0x0c, 0xc3, 0x20, 0x0e, 0x28, 0x74,
	0x05, 0xc0, 0xf1, 0xe2, 0xa0, 0xf6, 0x07, 0x06, 0xac, 0x69, 0x83, 0xd8, 0x8f, 0xcf, 0x1a, 0xb6,
	0x49, 0x3f, 0x02, 0xe0, 0xa2, 0x61, 0x9f, 0x0d, 0x79, 0xa5, 0xb4, 0x5b, 0xbe, 0xb5, 0x75, 0x6f,
	0xf7, 0xce, 0x98, 0xfc, 0x4e, 0x46, 0x9a, 0xfc, 0x42, 0x3a, 0x96, 0xe3, 0xa1, 0x5b, 0x50, 0xf6,
	0xbd, 0x4a, 0x79, 0xb7, 0x7c, 0x6b, 0x8d, 0x95, 0x7d, 0x8f, 0xee, 0xc2, 0xba, 0xe7, 0x47, 0xc3,
	0x9e, 0x7b, 0x66, 0xb8, 0x7d, 0x5e, 0x59, 0xd8, 0x2d, 0xdd, 0x5a, 0x63, 0x79, 0x10, 0xad, 0xc3,
	0xb6, 0xe8, 0xc0, 0xf3, 0x63, 0x9f, 0x47, 0x56, 0xd0, 0xf3, 0x2a, 0x8b, 0xbb, 0x0b, 0xb7, 0xd6,
	0xef, 0x55, 0xf2, 0x1d, 0xab, 0x09, 0x09, 0xf6, 0xcd, 0x26, 0x19, 0xa8, 0x05, 0x3b, 0x39, 0x50,
	0x3d, 0x18, 0x1d, 0x9f, 0xc4, 0x95, 0x25, 0x21, 0xe5, 0xe5, 0xd9, 0xc3, 0xcf, 0xe4, 0x49, 0x62,
	0x36, 0xcd, 0x4f, 0x6b, 0x00, 0xa3, 0x81, 0xc7, 0xc3, 0xde, 0x99, 0x3f, 0x38, 0xae, 0x2c, 0xef,
	0x2e, 0xdc, 0x5a, 0xab, 0x97, 0x2b, 0x25, 0x96, 0x83, 0xd2, 0x36, 0x10, 0x39, 0xf9, 0x76, 0x18,
	0x0c, 0x79, 0x88, 0xdc, 0x95, 0x15, 0xd1, 0xef, 0x4b, 0xe7, 0xa9, 0x2d, 0xa1, 0x3e, 0x63, 0x53,
	0xdc, 0x74, 0x0f, 0x96, 0x83, 0xd0, 0x3f, 0xf6, 0x07, 0x95, 0xd5, 0xdd, 0xd2, 0xad, 0xad, 0x7b,
	0xb5, 0xf3, 0xe4, 0x98, 0x82, 0xf2, 0x3e, 0x34, 0x74, 0x4b, 0x35, 0x0f, 0x35, 0xa6, 0x35, 0x58,
	0xc2, 0x4d, 0x39, 0x5c, 0x0d, 0xf9, 0xb0, 0xe7, 0x76, 0x79, 0x9f, 0x0f, 0xe2, 0x84, 0xd1, 0x8d,
	0xdd, 0xca, 0xda, 0x6e, 0xe9, 0xd6, 0xfa, 0xbd, 0xb7, 0x66, 0x8b, 0x65, 0x93, 0x2c, 0x2d, 0x1e,
	0xbb, 0xc8, 0xc6, 0x66, 0x4b, 0xa3, 0x35, 0x58, 0xeb, 0x07, 0x03, 0x3f, 0x0e, 0x42, 0xee, 0x55,
	0x60, 0xb7, 0x74, 0x6b, 0xf5, 0xfe, 0x62, 0x1c, 0x8e, 0x38, 0x1b, 0x83, 0x69, 0x13, 0x60, 0x18,
	0x7c, 0xc9, 0x43, 0x2b, 0x76, 0x63, 0x5e, 0x59, 0x17, 0xd3, 0x9a, 0x63, 0x55, 0xed, 0x8c, 0xee,
	0x3e, 0xb4, 0xcd, 0x87, 0x38, 0x23, 0xc7, 0x34, 0x58, 0x8e, 0x9f, 0x36, 0x61, 0xab, 0x1b, 0x0c,
	0xa2, 0x51, 0x9f, 0x87, 0xed, 0xa0, 0xe7, 0x77, 0xcf, 0x2a, 0x1b, 0x62, 0x46, 0x2f, 0xcd, 0x5b,
	0xe8, 0x3c, 0x2d, 0x9b, 0xe0, 0x45, 0x69, 0xc3, 0x30, 0x38, 0xf5, 0xbd, 0x4c, 0xda, 0xe6, 0x79,
	0xd2, 0xda, 0x05, 0x5a, 0x36, 0xc1, 0x4b, 0x2b, 0xb0, 0x12, 0x7c, 0x39, 0xe0, 0x5e, 0xfd, 0xac,
	0xb2, 0x25, 0x2c, 0x3d, 0x6d, 0xd2, 0xef, 0xc1, 0xc6, 0x20, 0x88, 0xfd, 0xc7, 0x7e, 0xd7, 0x8d,
	0xfd, 0x60, 0x50, 0xd9, 0x16, 0x46, 0xf2, 0x4c, 0xbe, 0x17, 0x23, 0x87, 0x47, 0x2b, 0x2f, 0x30,
	0xd0, 0xdb, 0xb0, 0xf5, 0x05, 0xe7, 0x43, 0x2b, 0x76, 0x07, 0x9e, 0xdb, 0x0b, 0x06, 0xbc, 0x42,
	0x72, 0xda, 0x9e, 0xc0, 0xd1, 0x9b, 0xb0, 0x36, 0x0c, 0x83, 0xc7, 0x7e, 0x8f, 0xeb, 0x5e, 0x65,
	0x47, 0x0c, 0x65, 0x0c, 0xa0, 0xdf, 0x03, 0x18, 0x0d, 0x3d, 0x37, 0xe6, 0x62, 0x9b, 0x53, 0xb1,
	0x20, 0xd7, 0xf2, 0x43, 0xe9, 0x64, 0xd8, 0xfb, 0x2b, 0x9d, 0x76, 0x43, 0xb1, 0xb5, 0x06, 0xcb,
	0xb1, 0xe0, 0xae, 0xee, 0xb9, 0x67, 0x3c, 0xe4, 0x9e, 0x79, 0xca, 0xc3, 0xca, 0x65, 0xdc, 0x1b,
	0x2c, 0x0f, 0xa2, 0xaf, 0x03, 0x49, 0x0c, 0x26, 0x92, 0xda, 0xd3, 0xbd, 0xca, 0x15, 0x41, 0x36,
	0x05, 0xa7, 0xaf, 0xc2, 0x7a, 0xdf, 0xf5, 0x07, 0x31, 0x1f, 0xb8, 0x83, 0x2e, 0xaf, 0x5c, 0x15,
	0xf3, 0x5a, 0x7a, 0xec, 0xf6, 0x22, 0xce, 0xf2, 0x18, 0xba, 0x0f, 0x1b, 0x51, 0x1c, 0x84, 0xee,
	0x31, 0x77, 0x3c, 0x34, 0xe5, 0x7f, 0x58, 0x10, 0x6b, 0xf5, 0xc2, 0xec, 0xb5, 0xb2, 0x24, 0x29,
	0x9a, 0xe9, 0xc1, 0x25, 0xb6, 0x1e, 0x8d, 0x9b, 0xd4, 0x80, 0x6d, 0xcf, 0x8f, 0xbe, 0x70, 0xdc,
	0x30, 0x74, 0xcf, 0xa4, 0xac, 0x7f, 0x94, 0xb2, 0x5e, 0x9c, 0x2d, 0xab, 0xe1, 0x47, 0x5f, 0x28,
	0x48, 0x9c, 0x48, 0xdb, 0xf4, 0xf2, 0x00, 0x6a, 0x01, 0x71, 0x87, 0xc3, 0x5e, 0xb2, 0x56, 0x52,
	0xe0, 0x3f, 0x49, 0x81, 0x73, 0xfc, 0x8f, 0x32, 0x26, 0x4f, 0x44, 0x6e, 0xbb, 0x45, 0x10, 0xfd,
	0x3e, 0x5c, 0x39, 0xf5, 0xc3, 0x78, 0xe4, 0xf6, 0x9c, 0xbe, 0xdb, 0x3d, 0xf1, 0x07, 0xc9, 0xac,
	0xff, 0x59, 0x0a, 0xbe, 0x35, 0x5b, 0xf0, 0xa1, 0x64, 0x69, 0x49, 0x8e, 0x44, 0x36, 0x3d, 0x9d,
	0x82, 0xd2, 0xcf, 0xe1, 0xea, 0xf0, 0xe4, 0x2c, 0xf2, 0xbb, 0x93, 0xf2, 0xff, 0x45, 0xca, 0x7f,
	0x6d, 0xce, 0x0e, 0x48, 0x78, 0x8a, 0x1d, 0x5c, 0x1e, 0x4e, 0x83, 0xe9, 0x63, 0xb8, 0x9e, 0x4e,
	0x00, 0x05, 0x77, 0xf9, 0x20, 0xe6, 0xa1, 0xec, 0xe3, 0x5f, 0x65, 0x1f, 0x6f, 0x9c, 0x3b, 0x87,
	0x46, 0xc6, 0x94, 0xf4, 0x72, 0xf5, 0x74, 0x16, 0x02, 0xfb, 0x49, 0xcd, 0xa2, 0x1b, 0x0c, 0xe2,
	0x30, 0xe8, 0xf5, 0xd2, 0x7e, 0xfe, 0xed, 0xdc, 0x7e, 0x12, 0x0b, 0x51, 0x33, 0xa6, 0xb4, 0x9f,
	0x68, 0x16, 0x82, 0xda, 0xb0, 0xd3, 0x0b, 0x8e, 0x85, 0xc2, 0x86, 0x41, 0x20, 0x27, 0x55, 0xf9,
	0xf7, 0x73, 0x97, 0xb9, 0x29, 0xe9, 0xdb, 0x41, 0xd0, 0x4b, 0x97, 0xb9, 0x57, 0x04, 0x51, 0x1f,
	0x2a, 0xa9, 0x96, 0xa6, 0x6c, 0xe8, 0x3f, 0xa4, 0xf0, 0xdb, 0xe7, 0xaa, 0x69, 0xda, 0x94, 0xae,
	0x9d, 0xce, 0xc4, 0xd0, 0xcf, 0xe0, 0xf2, 0x30, 0x0c, 0xba, 0x3c, 0x8a, 0x82, 0x30, 0x37, 0x85,
	0xff, 0x94, 0xbd, 0xbc, 0x3a, 0xd7, 0xe5, 0x49, 0x8e, 0xdc, 0x24, 0x76, 0x86, 0x93, 0x40, 0x1a,
	0xc1, 0xcd, 0x49, 0x6b, 0x0d, 0x79, 0xcf, 0x8d, 0xb9, 0x27, 0x3b, 0xf9, 0xe9, 0xca, 0x79, 0xe7,
	0x4e, 0xd1, 0x6a, 0x99, 0x64, 0x14, 0x9d, 0x95, 0xd8, 0x8d, 0xd3, 0x79, 0x48, 0x7a, 0x0a, 0xcf,
	0x4e, 0xd9, 0x70, 0xa1, 0xd7, 0xbf, 0x91, 0xbd, 0xde, 0x7d, 0x2a, 0x5b, 0x2e, 0x76, 0x5b, 0x1d,
	0xce, 0xc5, 0xd2, 0xff, 0x0f, 0xcf, 0xcf, 0xb0, 0xb8, 0x42, 0xcf, 0x7f, 0x2b, 0x7b, 0xbe, 0xf7,
	0x94, 0x96, 0x57, 0xec, 0xfb, 0x66, 0x74, 0x0e, 0xbe, 0xfa, 0xf7, 0xa5, 0x24, 0xa6, 0x1b, 0xc7,
	0x2f, 0xf4, 0x39, 0x80, 0xf4, 0x2c, 0xd2, 0x3d, 0x11, 0xb9, 0xad, 0xb1, 0x1c, 0x84, 0xde, 0x85,
	0xe5, 0x23, 0x19, 0x16, 0x95, 0x2f, 0x08, 0xae, 0x12, 0x3a, 0xda, 0x80, 0x8d, 0x94, 0x5f, 0x1c,
	0x13, 0x0b, 0xe7, 0x9d, 0xdb, 0xb9, 0x68, 0xb0, 0xc0, 0x45, 0xf7, 0x61, 0x3d, 0x1a, 0x1d, 0x35,
	0xfc, 0x53, 0x3f, 0xc2, 0x63, 0x6f, 0xf1, 0xbc, 0xcd, 0x62, 0x8d, 0x09, 0x45, 0xc8, 0x91, 0xe7,
	0xac, 0xfe, 0x5d, 0x09, 0xb6, 0x27, 0x08, 0xe8, 0x4b, 0xb0, 0x99, 0x23, 0xc9, 0xe6, 0x5d, 0x04,
	0xd2, 0x57, 0x60, 0x2b, 0xe4, 0xde, 0x68, 0xe0, 0xb9, 0x83, 0xae, 0x0c, 0x6c, 0xcb, 0xe2, 0x40,
	0x9c, 0x80, 0xd2, 0x77, 0x21, 0xdd, 0xf7, 0x4a, 0x17, 0x8d, 0x5b, 0x75, 0x87, 0x6e, 0xd7, 0x8f,
	0xcf, 0xc4, 0xcc, 0xcb, 0x6c, 0x36, 0x32, 0xcf, 0xd5, 0x0f, 0x46, 0x83, 0x38, 0xe3, 0x5a, 0x2c,
	0x72, 0x15, 0x90, 0x93, 0x61, 0xf1, 0xd2, 0x54, 0x58, 0x5c, 0xfd, 0xcd, 0x25, 0x58, 0xcf, 0x9d,
	0x60, 0x54, 0x85, 0xf4, 0x04, 0x4b, 0x62, 0x73, 0x5c, 0x8d, 0xf3, 0x4f, 0x3e, 0xb1, 0x1c, 0x79,
	0x2e, 0x0c, 0x0b, 0xfc, 0xa1, 0xe2, 0x79, 0x21, 0x8f, 0xa2, 0x44, 0x0b, 0x63, 0x00, 0xda, 0x10,
	0x7f, 0x32, 0x0c, 0xc2, 0xb8, 0xed, 0xc6, 0x27, 0x49, 0xa8, 0x9e, 0x83, 0x20, 0x77, 0x22, 0x4c,
	0xf7, 0xc4, 0xf4, 0xd6, 0xd8, 0x18, 0x80, 0xb1, 0x4f, 0x6f, 0x34, 0xe8, 0x8c, 0x7c, 0x2f, 0x99,
	0x4e, 0xda, 0xa4, 0x57, 0x60, 0xa9, 0x37, 0xc2, 0xe5, 0x59, 0xde, 0x2d, 0xdd, 0x5a, 0x62, 0xb2,
	0x41, 0x09, 0x2c, 0x7c, 0xf9, 0xe5, 0xa0, 0xb2, 0x22, 0x68, 0xf1, 0x27, 0x7d, 0x13, 0xb6, 0x06,
	0x41, 0xac, 0xf6, 0x46, 0x51, 0xcc, 0x43, 0xf7, 0xa8, 0xc7, 0x45, 0x08, 0x9c, 0x85, 0x02, 0x13,
	0x48, 0x5a, 0x83, 0x0d, 0xfe, 0x24, 0xe6, 0xe1, 0xc0, 0xed, 0x09, 0x25, 0xae, 0x89, 0xf0, 0xa2,
	0x00, 0xa3, 0x0f, 0x60, 0x11, 0x63, 0x9e, 0x0a, 0x08, 0xa3, 0xff, 0xe0, 0xc2, 0x40, 0x21, 0xfd,
	0xbd, 0xe7, 0xf7, 0x78, 0x83, 0x47, 0xdd, 0xd0, 0x1f, 0xc6, 0x41, 0xc8, 0x84, 0x90, 0xea, 0x2f,
	0x97, 0xe1, 0xea, 0x4c, 0x3c, 0xa5, 0xb0, 0x38, 0x44, 0x9d, 0x49, 0xfb, 0x13, 0xbf, 0xe9, 0x35,
	0x58, 0x8e, 0xfc, 0xaf, 0xf8, 0x83, 0x23, 0x91, 0x0d, 0x2d, 0xb0, 0xa4, 0x45, 0xef, 0x00, 0xc5,
	0xcd, 0x96, 0x06, 0x76, 0xb6, 0xdf, 0xe7, 0xad, 0xa8, 0xb2, 0x20, 0x68, 0x66, 0x60, 0xe8, 0x47,
	0xb0, 0x18, 0xe3, 0x8a, 0x2f, 0x8a, 0x15, 0xbf, 0xfd, 0x34, 0xfe, 0x13, 0x47, 0x27, 0x16, 0x5f,
	0x70, 0xd2, 0x5b, 0xb0, 0xed, 0x07, 0xc3, 0x48, 0xc4, 0xae, 0xb8, 0x27, 0xb8, 0x5c, 0xa1, 0x25,
	0x36, 0x09, 0x9e, 0xb1, 0x55, 0x96, 0x67, 0x6d, 0x95, 0xea, 0x5f, 0x97, 0x60, 0xb3, 0x10, 0x12,
	0x15, 0x6d, 0xa3, 0x24, 0x56, 0x22, 0x67, 0x1b, 0x2f, 0xc1, 0x06, 0x76, 0x95, 0xed, 0x0d, 0x34,
	0xbd, 0x85, 0x83, 0x4b, 0xac, 0x00, 0xa5, 0x1a, 0x00, 0x86, 0x55, 0x2a, 0xee, 0x94, 0xa8, 0x72,
	0x61, 0x3c, 0x26, 0xe8, 0x92, 0x03, 0x29, 0xc7, 0x48, 0xbf, 0x05, 0x57, 0xa2, 0xd1, 0x10, 0xad,
	0x36, 0x3a, 0x0c, 0x7a, 0xa3, 0x3e, 0x67, 0x1c, 0x55, 0x2f, 0x14, 0x98, 0x19, 0xd3, 0x4c, 0x92,
	0xfa, 0x3a, 0xac, 0xe1, 0x88, 0x84, 0x07, 0xaf, 0xfe, 0x55, 0x09, 0xb6, 0x27, 0xce, 0xef, 0x0b,
	0xa6, 0x89, 0xbe, 0x80, 0x87, 0xa7, 0x7e, 0x97, 0x37, 0xf9, 0x29, 0xef, 0x99, 0x47, 0x3f, 0xe0,
	0xdd, 0xd8, 0x3f, 0x4d, 0x1d, 0xce, 0x6c, 0xe4, 0x94, 0x72, 0x16, 0x9e, 0x42, 0x39, 0x8b, 0x3f,
	0xa3, 0x72, 0x8a, 0x33, 0xfc, 0xc5, 0x12, 0x6c, 0x4f, 0xc6, 0x08, 0x34, 0x31, 0xb7, 0x92, 0x18,
	0xb2, 0x34, 0xa0, 0xf3, 0xdd, 0x06, 0x1a, 0x7f, 0x10, 0xc6, 0x89, 0xc3, 0x10, 0xbf, 0x65, 0xf8,
	0x2f, 0x4e, 0x2c, 0x3d, 0x63, 0x94, 0x1e, 0x63, 0x0a, 0x5e, 0xfd, 0x85, 0x12, 0x5c, 0x9b, 0x1d,
	0xca, 0x7c, 0xc3, 0xc1, 0x2c, 0x25, 0x83, 0xd9, 0x85, 0xf5, 0x44, 0xf3, 0x76, 0xba, 0x91, 0xd6,
	0x58, 0x1e, 0x54, 0xfd, 0xf3, 0x65, 0xa0, 0xd3, 0x81, 0x73, 0xb1, 0xab, 0x64, 0xb5, 0xc7, 0x5d,
	0x7d, 0x00, 0x2b, 0xa7, 0x7d, 0x99, 0xd3, 0x96, 0xc5, 0x72, 0x3c, 0x3b, 0x67, 0x6f, 0xb6, 0x04,
	0x11, 0x4b, 0xa9, 0x51, 0xec, 0xf1, 0x88, 0x47, 0x71, 0xae, 0x22, 0x32, 0x06, 0x50, 0x07, 0xb6,
	0xdc, 0xc1, 0x20, 0x88, 0x85, 0x16, 0x8c, 0x20, 0xe6, 0x49, 0x39, 0xe4, 0x83, 0xa7, 0x8d, 0xf7,
	0xef, 0x28, 0x05, 0x76, 0x36, 0x21, 0x8e, 0x3e, 0x4a, 0x7c, 0xa2, 0xac, 0x8f, 0x68, 0x4f, 0x2d,
	0x76, 0xda, 0xc7, 0x4c, 0x7a, 0x48, 0x3c, 0x03, 0x06, 0xa3, 0xbe, 0x3a, 0x1c, 0x45, 0x89, 0xaf,
	0x4f, 0x9b, 0xf4, 0x53, 0x58, 0x3f, 0xf2, 0x7b, 0x3d, 0x7f, 0x70, 0x2c, 0xd6, 0x60, 0x45, 0x38,
	0xb3, 0xf7, 0x9f, 0xbe, 0xef, 0x56, 0x7d, 0xcc, 0xcd, 0xf2, 0xa2, 0xe8, 0x77, 0xe0, 0xc6, 0x91,
	0xef, 0x79, 0xfe, 0xe0, 0xb8, 0x1d, 0x06, 0xde, 0xa8, 0x1b, 0xa7, 0xa3, 0xc2, 0x78, 0x63, 0x55,
	0x68, 0x77, 0x3e, 0x01, 0x86, 0x10, 0x83, 0x51, 0x5f, 0xeb, 0xb9, 0x51, 0xec, 0x77, 0xf5, 0x61,
	0x24, 0xca, 0x23, 0x4b, 0xac, 0x08, 0xac, 0x7e, 0x08, 0x5b, 0x45, 0xa5, 0xe2, 0xe9, 0xf5, 0x05,
	0x3f, 0x4b, 0x1c, 0x3e, 0xfe, 0xc4, 0x53, 0xee, 0xd4, 0xed, 0x8d, 0x78, 0x52, 0xfc, 0x92, 0x8d,
	0xea, 0x8f, 0x4b, 0x70, 0xf3, 0x3c, 0xc5, 0x4d, 0x7a, 0x94, 0x72, 0xd1, 0xa3, 0xa4, 0x07, 0x4b,
	0x79, 0xe6, 0xc1, 0x22, 0x3c, 0x45, 0x76, 0xb0, 0x7c, 0xe3, 0x83, 0xa2, 0xb6, 0x0f, 0x9b, 0x05,
	0x45, 0xd3, 0x0d, 0x58, 0x35, 0x8d, 0x86, 0xd6, 0x52, 0x8c, 0x06, 0xb9, 0x44, 0xd7, 0x61, 0xa5,
	0xae, 0x37, 0x1a, 0xba, 0xb1, 0x4f, 0x4a, 0x74, 0x13, 0xd6, 0x1a, 0x5a, 0x43, 0x57, 0x15, 0x5b,
	0x6b, 0x90, 0x32, 0x52, 0x32, 0xcd, 0xd2, 0xd8, 0xa1, 0xd6, 0x20, 0x0b, 0xd5, 0x5f, 0x2d, 0x65,
	0x27, 0xe5, 0x44, 0x0e, 0x35, 0xe9, 0xec, 0x4a, 0x4f, 0xe1, 0xec, 0xca, 0x3f, 0x17, 0x67, 0xf7,
	0x26, 0xac, 0x24, 0x3b, 0x91, 0xd6, 0x60, 0xad, 0x1b, 0x0c, 0x06, 0xbc, 0x1b, 0x73, 0x4f, 0x8c,
	0x20, 0x2b, 0x5a, 0x65, 0xe0, 0xea, 0x5f, 0x94, 0xe0, 0xf2, 0x8c, 0x5c, 0x17, 0x77, 0xfd, 0x30,
	0xd9, 0xf5, 0xa5, 0xf3, 0x76, 0x7d, 0x3b, 0xdd, 0xf5, 0x09, 0x75, 0x62, 0x69, 0xea, 0x70, 0x64,
	0x05, 0xdd, 0x2f, 0x78, 0x32, 0x2d, 0x69, 0x69, 0x63, 0x20, 0xfa, 0x2a, 0x09, 0x50, 0x83, 0x90,
	0x47, 0x89, 0x1b, 0xcb, 0x83, 0xc6, 0x72, 0xec, 0x93, 0x90, 0xbb, 0x9e, 0xf4, 0xab, 0x99, 0x9c,
	0x04, 0x88, 0xb1, 0x5c, 0x57, 0x72, 0xb4, 0x4e, 0xbe, 0x4a, 0x8e, 0xfb, 0x1c, 0xa4, 0xfa, 0x08,
	0x56, 0x92, 0x11, 0xd2, 0x37, 0x8a, 0xe5, 0x97, 0x52, 0xee, 0x98, 0x14, 0xf5, 0xce, 0x42, 0x09,
	0xe6, 0x05, 0x58, 0x7d, 0xec, 0xfa, 0xbd, 0xe0, 0x94, 0x87, 0x62, 0x02, 0xd9, 0x81, 0x9a, 0x81,
	0xab, 0x7f, 0x52, 0x82, 0xea, 0x54, 0x06, 0x8f, 0xe6, 0xd4, 0x0e, 0x83, 0x61, 0x44, 0x75, 0x58,
	0x0c, 0x83, 0x5e, 0x1a, 0xc1, 0x3e, 0x6d, 0x05, 0x80, 0x05, 0x3d, 0x7e, 0x7f, 0x55, 0x35, 0x0d,
	0xab, 0xd3, 0xd2, 0x18, 0x13, 0x22, 0xe8, 0x5b, 0xb0, 0x9d, 0x1e, 0xe3, 0x06, 0x8f, 0x62, 0x7f,
	0x70, 0x5c, 0x1c, 0xd3, 0x24, 0x56, 0x44, 0x98, 0x3c, 0x8a, 0xb9, 0x97, 0x56, 0x05, 0x85, 0x82,
	0x73, 0x11, 0x66, 0x01, 0x59, 0xfd, 0x49, 0x19, 0xae, 0xce, 0xac, 0x45, 0xe0, 0x1e, 0x1c, 0xf6,
	0x45, 0xac, 0x2b, 0x8f, 0x85, 0xa4, 0x85, 0xf0, 0x53, 0x09, 0x2f, 0x4b, 0xb8, 0x6c, 0xd1, 0x3b,
	0xe3, 0x91, 0x26, 0xfb, 0x22, 0xe9, 0x59, 0xda, 0xdd, 0x24, 0x92, 0x1e, 0xc2, 0xd6, 0xa9, 0xd7,
	0x75, 0x70, 0x57, 0x3a, 0x43, 0x54, 0x5b, 0x72, 0xe2, 0xdf, 0x7d, 0x4a, 0x75, 0x65, 0xea, 0x66,
	0x1b, 0xa7, 0x5e, 0x77, 0xac, 0xfc, 0x13, 0xb8, 0x82, 0x72, 0xdd, 0x5e, 0x2f, 0x48, 0xea, 0x0c,
	0xfd, 0xc0, 0xe3, 0x3d, 0x61, 0x20, 0x17, 0xf9, 0xe3, 0xb1, 0x74, 0x25, 0x63, 0x6f, 0x21, 0x37,
	0xa3, 0xa7, 0x5e, 0x77, 0x02, 0x56, 0xfd, 0x14, 0xb6, 0x8a, 0xb5, 0x6e, 0xf4, 0x74, 0x03, 0xb7,
	0xcf, 0xa3, 0xa1, 0xdb, 0xe5, 0xa9, 0xa7, 0xcb, 0x00, 0xe8, 0xe9, 0xb0, 0x91, 0x7a, 0x3a, 0xfc,
	0x3d, 0x76, 0xa9, 0x0b, 0x79, 0x97, 0xfa, 0xc7, 0x25, 0xb8, 0x31, 0xb7, 0x5e, 0x40, 0x3f, 0x84,
	0xe5, 0x3e, 0xef, 0x07, 0xe1, 0x59, 0xb2, 0x3d, 0xe7, 0x24, 0xac, 0x2d, 0x41, 0x23, 0xd2, 0xcc,
	0x84, 0x9e, 0x2a, 0xa2, 0x66, 0x2a, 0xcb, 0x1a, 0x49, 0x96, 0xfc, 0xe2, 0x05, 0x25, 0x11, 0xc1,
	0x3f, 0xe6, 0xa2, 0xb7, 0xa1, 0xec, 0x07, 0x95, 0x05, 0xc1, 0x7b, 0x73, 0x36, 0xaf, 0x1e, 0x08,
	0xa6, 0xb2, 0x1f, 0x88, 0x8d, 0x32, 0xbf, 0x04, 0xf1, 0xbf, 0x69, 0x26, 0x3f, 0x2a, 0xc1, 0xcd,
	0xf3, 0x4a, 0x1a, 0xff, 0xa3, 0x73, 0xa9, 0x7e, 0x06, 0x30, 0x16, 0x9c, 0xdc, 0x50, 0x95, 0xe6,
	0xdd, 0x50, 0x95, 0xa7, 0x6f, 0xa8, 0xaa, 0xb0, 0xda, 0xcd, 0x07, 0xe7, 0x25, 0x96, 0xb5, 0xab,
	0xdf, 0x87, 0xcd, 0x42, 0xbf, 0x3f, 0x67, 0xf1, 0x43, 0x58, 0x96, 0x6a, 0xfe, 0x19, 0xe4, 0x5e,
	0x81, 0xa5, 0x68, 0xc8, 0xb9, 0x97, 0x08, 0x95, 0x0d, 0x3c, 0x18, 0xfa, 0x6e, 0xb7, 0x18, 0x93,
	0xe7, 0x20, 0xd5, 0xbf, 0x4c, 0x52, 0xbb, 0xec, 0x4c, 0xa5, 0xcf, 0xc2, 0xf2, 0xc9, 0xd9, 0x51,
	0xe8, 0x7b, 0x85, 0xa3, 0x81, 0x25, 0x40, 0xf4, 0xa9, 0x8f, 0x7b, 0x6e, 0x74, 0xa2, 0x9c, 0xba,
	0x7e, 0x4f, 0x64, 0xed, 0x05, 0x1f, 0x3c, 0x81, 0xa4, 0xef, 0xc1, 0x12, 0x9e, 0xd0, 0x51, 0x62,
	0x5b, 0xcf, 0x5f, 0x70, 0xaa, 0x33, 0x49, 0x4d, 0xf7, 0xe1, 0x99, 0xae, 0xdb, 0xeb, 0x8e, 0xd0,
	0xa4, 0xf6, 0xc2, 0xa0, 0x7f, 0x10, 0xa0, 0xa7, 0x16, 0x0c, 0x3e, 0x8f, 0x8a, 0xb9, 0xdd, 0x79,
	0x94, 0x55, 0x1d, 0xd6, 0x32, 0xe1, 0xc9, 0x69, 0x8b, 0x6d, 0xa1, 0x44, 0xa9, 0xdd, 0x3c, 0x08,
	0x17, 0x27, 0x69, 0x46, 0x49, 0x1e, 0x9f, 0xb5, 0xab, 0xbf, 0x5b, 0x86, 0x1b, 0x73, 0x2f, 0xcc,
	0x44, 0xd6, 0xed, 0xf1, 0x41, 0xec, 0x3f, 0x3e, 0x93, 0xa1, 0xe7, 0x30, 0x39, 0x2b, 0x26, 0xc1,
	0xf4, 0x73, 0xd8, 0x3e, 0x1a, 0x61, 0x4b, 0x0d, 0xfa, 0x7d, 0xf4, 0xd5, 0x51, 0x62, 0xe8, 0xef,
	0x5f, 0x78, 0x49, 0x97, 0x55, 0xee, 0x52, 0x2f, 0x2b, 0x6c, 0x7f, 0x52, 0x1c, 0x3d, 0x02, 0x12,
	0x71, 0x11, 0xd6, 0x8d, 0xbb, 0x58, 0xf8, 0x46, 0x5d, 0x4c, 0xc9, 0xc3, 0xb8, 0x84, 0x3f, 0x89,
	0xc7, 0x3e, 0x5f, 0xa4, 0x2d, 0x6b, 0xac, 0x08, 0xac, 0xfe, 0x5a, 0x09, 0x76, 0x2f, 0x12, 0x4e,
	0x9b, 0xb0, 0x99, 0x5e, 0xc7, 0xe6, 0x6f, 0xa2, 0x5f, 0x99, 0x57, 0xb3, 0x1c, 0x37, 0x44, 0x30,
	0x5b, 0x64, 0xa6, 0x35, 0x51, 0xc8, 0x14, 0xd2, 0x93, 0xad, 0x22, 0xea, 0x44, 0x79, 0x58, 0xf5,
	0x18, 0xb6, 0x8a, 0x17, 0x85, 0xf4, 0x0d, 0xd8, 0x8c, 0x4e, 0x82, 0x61, 0x64, 0x07, 0xc7, 0x3c,
	0x3e, 0xe1, 0x61, 0xd1, 0xf8, 0x8b, 0x38, 0x7a, 0x0b, 0x36, 0xd2, 0x3a, 0x70, 0x6e, 0x07, 0xc8,
	0xb3, 0xbd, 0x80, 0xa9, 0xfe, 0x10, 0xb6, 0x8a, 0x77, 0x88, 0xf4, 0x3e, 0x5c, 0x75, 0xd3, 0xdd,
	0xb1, 0x17, 0x84, 0xed, 0x54, 0x35, 0x85, 0xc0, 0x74, 0x36, 0x09, 0xee, 0x3d, 0x3c, 0x75, 0x7b,
	0x96, 0x0c, 0x1f, 0xb8, 0x37, 0xb1, 0xf7, 0x8a, 0xc8, 0xea, 0x1f, 0x95, 0x60, 0x67, 0xaa, 0x9c,
	0x4f, 0xdf, 0x87, 0x6b, 0x7d, 0xf7, 0x89, 0xdf, 0x1f, 0xf5, 0x13, 0x9c, 0x3f, 0x38, 0xee, 0x0c,
	0xfc, 0x38, 0x12, 0x6a, 0x2f, 0xb3, 0x39, 0x58, 0x7a, 0x1f, 0x2a, 0xd9, 0xa8, 0x26, 0x39, 0xcb,
	0x82, 0x73, 0x2e, 0x9e, 0x7e, 0x08, 0xd7, 0x43, 0x8e, 0x19, 0x38, 0xf7, 0x26, 0x59, 0x65, 0xb5,
	0x75, 0x1e, 0xba, 0xf6, 0xe3, 0x15, 0x80, 0x71, 0xb5, 0x99, 0x02, 0x2c, 0x5b, 0x0f, 0x75, 0x5b,
	0x3d, 0x20, 0x97, 0xe8, 0x35, 0xa0, 0x87, 0x3a, 0xb3, 0x3b, 0x4a, 0xd3, 0x69, 0x28, 0xb6, 0xa2,
	0x6a, 0x86, 0xad, 0x31, 0x52, 0xc2, 0xbc, 0xc5, 0xb2, 0x4d, 0xa6, 0xec, 0x6b, 0xa4, 0x2c, 0x1a,
	0x1a, 0x3b, 0xd4, 0x55, 0x8d, 0x2c, 0xd0, 0xcb, 0xb0, 0x8d, 0x94, 0x75, 0xc5, 0xd2, 0x1c, 0x91,
	0xbc, 0x30, 0xb2, 0x28, 0x28, 0x94, 0x43, 0xdd, 0xd8, 0xb7, 0xc8, 0x92, 0xc8, 0x80, 0xda, 0x1a,
	0x53, 0x6c, 0x93, 0x91, 0x65, 0xba, 0x05, 0xf0, 0x50, 0xab, 0xa7, 0xa4, 0x2b, 0x74, 0x1b, 0xd6,
	0x99, 0xbe, 0x7f, 0x60, 0x3b, 0x96, 0xfe, 0x99, 0xc6, 0xc8, 0x2a, 0xad, 0xc2, 0x35, 0xfb, 0x80,
	0x69, 0x9a, 0x63, 0xeb, 0x1a, 0x73, 0x94, 0x76, 0xbb, 0x89, 0x19, 0x92, 0x6e, 0x1a, 0x64, 0x0d,
	0x3b, 0x4b, 0x87, 0xd7, 0x52, 0xd4, 0x03, 0xdd, 0xd0, 0x08, 0xa0, 0xc4, 0x86, 0x6e, 0x3d, 0x70,
	0x14, 0xc6, 0x94, 0x47, 0x64, 0x5d, 0xb4, 0xc7, 0x63, 0xdf, 0xa0, 0x14, 0xb6, 0x74, 0x63, 0x8f,
	0x29, 0x96, 0xcd, 0x3a, 0xaa, 0xdd, 0x61, 0x1a, 0xd9, 0xa4, 0x57, 0x80, 0xb4, 0x0f, 0x1e, 0x59,
	0xba, 0x9a, 0x93, 0xb4, 0x85, 0xc3, 0x56, 0x0f, 0x14, 0xcb, 0xd2, 0x2d, 0xb2, 0x4d, 0xaf, 0xc2,
	0x4e, 0x53, 0x57, 0x35, 0xc3, 0xd2, 0x8d, 0x7d, 0x27, 0x9d, 0x2f, 0xa1, 0x3b, 0xb0, 0x59, 0xef,
	0x58, 0xba, 0xa1, 0x59, 0x96, 0xd3, 0xb1, 0x34, 0x46, 0x76, 0x50, 0x69, 0x89, 0x72, 0x1c, 0xd5,
	0x34, 0x6c, 0x66, 0x36, 0x9b, 0x1a, 0x23, 0x14, 0x07, 0x72, 0xf0, 0xa8, 0x8d, 0x9c, 0x96, 0xc9,
	0xc8, 0x65, 0x1c, 0x7d, 0xc6, 0xaa, 0x19, 0xb6, 0x6e, 0x3f, 0x22, 0x57, 0x30, 0x09, 0xd4, 0x4d,
	0xa7, 0x65, 0x36, 0x3a, 0x4d, 0x8d, 0x5c, 0xc5, 0xc1, 0x2a, 0x2a, 0xce, 0xd6, 0x69, 0x29, 0x86,
	0xb2, 0xaf, 0x31, 0x72, 0x8d, 0xae, 0xc2, 0xe2, 0x61, 0x53, 0x31, 0xc8, 0x75, 0xec, 0x29, 0xa7,
	0x90, 0x54, 0x89, 0x15, 0x54, 0x71, 0x2a, 0x99, 0xdc, 0xa0, 0xd7, 0xe1, 0x72, 0xaa, 0xa5, 0xbc,
	0xfa, 0xaa, 0x88, 0x30, 0x34, 0xfb, 0xa1, 0xc9, 0x1e, 0xe0, 0x9c, 0x34, 0xa3, 0xd1, 0x36, 0x75,
	0xc3, 0x26, 0xcf, 0xa0, 0x3a, 0xb2, 0x91, 0x29, 0xaa, 0x6a, 0x76, 0x0c, 0x9b, 0xdc, 0xa4, 0xcb,
	0x50, 0xd6, 0xdb, 0xe4, 0x59, 0xfa, 0x0c, 0x5c, 0x4f, 0xe6, 0x9f, 0x0c, 0xdb, 0xb1, 0xb5, 0x56,
	0xbb, 0xa9, 0xd8, 0x1a, 0x79, 0x0e, 0x07, 0xd7, 0x36, 0x99, 0x4d, 0x9e, 0x47, 0xed, 0x25, 0xd2,
	0xc9, 0x2e, 0x2e, 0x6b, 0xbe, 0xef, 0x17, 0x10, 0x60, 0x1f, 0xe8, 0xd9, 0xc4, 0x6b, 0xd8, 0xa7,
	0x6a, 0xb6, 0xda, 0x1d, 0x5b, 0x73, 0x98, 0x66, 0x99, 0x1d, 0xa6, 0x6a, 0xe4, 0x45, 0xba, 0x02,
	0x0b, 0x2d, 0x45, 0x25, 0x2f, 0xe1, 0x94, 0x74, 0x5c, 0x40, 0x43, 0xb3, 0xc9, 0xcb, 0x74, 0x0d,
	0x96, 0x5a, 0x26, 0xce, 0xf5, 0x15, 0xfa, 0x02, 0x3c, 0xdb, 0xd0, 0x2d, 0x9b, 0xe9, 0xf5, 0x8e,
	0xad, 0x35, 0x9c, 0x74, 0xa6, 0x38, 0x88, 0x7d, 0x66, 0x76, 0xda, 0xe4, 0x55, 0xd4, 0x29, 0x2e,
	0x84, 0xa2, 0x1b, 0x1a, 0x23, 0xb7, 0x70, 0xc9, 0xb2, 0xa6, 0xd3, 0x36, 0x1b, 0xe4, 0x35, 0x4a,
	0x60, 0xa3, 0x69, 0xee, 0x8b, 0xe5, 0x6f, 0x9b, 0x66, 0x93, 0xbc, 0x2e, 0x88, 0x9a, 0x66, 0xa7,
	0x91, 0x2d, 0xf5, 0x1b, 0x38, 0xb5, 0x06, 0x92, 0xdf, 0x16, 0x2b, 0x80, 0xbf, 0xde, 0xc4, 0x61,
	0xa5, 0xe6, 0x4e, 0xee, 0x20, 0x53, 0xd3, 0x54, 0x1a, 0x4e, 0x5d, 0x69, 0x2a, 0x86, 0xaa, 0x31,
	0xf2, 0x16, 0xad, 0xc0, 0x95, 0xb1, 0x2a, 0x73, 0x1a, 0xb8, 0x8b, 0x4b, 0xdb, 0x66, 0xa6, 0xaa,
	0x59, 0x96, 0xc9, 0x64, 0xaf, 0x6f, 0x23, 0x2c, 0x35, 0x9d, 0x43, 0xb3, 0xd9, 0x69, 0x69, 0xe4,
	0x1e, 0xdd, 0x80, 0x95, 0x8e, 0xf1, 0xc0, 0x30, 0x1f, 0x1a, 0xe4, 0xbf, 0xb6, 0x6b, 0x36, 0xc0,
	0xf8, 0x45, 0x07, 0x9a, 0xd4, 0xf8, 0x4d, 0x07, 0x29, 0xa1, 0x56, 0xb3, 0xf6, 0xde, 0x1e, 0x29,
	0xe3, 0xd4, 0xad, 0x8e, 0xd5, 0xd6, 0x8c, 0x86, 0xd6, 0x20, 0x0b, 0x68, 0x30, 0x02, 0x6f, 0xd9,
	0x8a, 0xad, 0x39, 0xa9, 0xd8, 0xc5, 0xda, 0xef, 0x94, 0xb2, 0xab, 0x11, 0xe1, 0x03, 0x76, 0x60,
	0x73, 0x5f, 0x33, 0x34, 0xa6, 0xab, 0x4e, 0xbd, 0x69, 0xaa, 0x0f, 0x48, 0x09, 0x55, 0xae, 0x5b,
	0xaa, 0xa5, 0x93, 0x32, 0x62, 0xf7, 0xf4, 0xba, 0xc6, 0x1c, 0xf5, 0x40, 0x31, 0x0c, 0xad, 0x49,
	0x16, 0x50, 0x23, 0x7b, 0xaa, 0xa9, 0x91, 0x45, 0x74, 0x1f, 0x66, 0xfd, 0x63, 0x4d, 0xb5, 0xc9,
	0x12, 0x1a, 0x58, 0x2a, 0x66, 0x4f, 0x6f, 0x6a, 0x8e, 0xf5, 0xc8, 0xb2, 0xb5, 0x16, 0x59, 0xc6,
	0x65, 0x35, 0xf6, 0x2c, 0xb2, 0x82, 0xfa, 0x53, 0xf5, 0x3d, 0xcb, 0xb1, 0x5a, 0x75, 0xb2, 0x8a,
	0x7d, 0x34, 0x4d, 0x55, 0x69, 0x92, 0x35, 0xfc, 0x69, 0xda, 0x07, 0x1a, 0x23, 0x20, 0xb4, 0xdd,
	0xda, 0xb3, 0xc8, 0x7a, 0xed, 0x87, 0x59, 0x59, 0x73, 0xa2, 0xda, 0x92, 0xac, 0xe9, 0x9e, 0xbe,
	0xdf, 0x61, 0x52, 0xbf, 0x25, 0xb1, 0x5c, 0xba, 0xf5, 0x40, 0x56, 0x52, 0x2c, 0x43, 0x69, 0x5b,
	0x07, 0xa6, 0x4d, 0x16, 0x70, 0x80, 0x2d, 0xad, 0x65, 0xb2, 0x47, 0x64, 0x11, 0x69, 0xac, 0x87,
	0x4a, 0x9b, 0x2c, 0xe1, 0x88, 0x9a, 0xe6, 0xbe, 0x1c, 0x9a, 0x6e, 0x99, 0x64, 0x05, 0x75, 0xab,
	0x59, 0x9f, 0x62, 0x7e, 0x6c, 0x36, 0x35, 0xb2, 0x5a, 0x7b, 0x67, 0x46, 0xe6, 0x8a, 0x39, 0xb4,
	0x98, 0x43, 0x92, 0x45, 0x93, 0x12, 0xb6, 0xda, 0xcc, 0x6c, 0x74, 0x70, 0xf9, 0xcb, 0xb5, 0xcf,
	0x61, 0xf7, 0xa2, 0x5c, 0x0f, 0xfd, 0x80, 0xd2, 0xc4, 0x79, 0x8b, 0x4d, 0x2c, 0x2c, 0xa1, 0x84,
	0x13, 0x6a, 0x2b, 0x8f, 0x1c, 0xc5, 0x72, 0x1e, 0x99, 0x1d, 0x67, 0xdf, 0x24, 0x65, 0xdc, 0x21,
	0xb2, 0x20, 0x94, 0x23, 0x5c, 0xa8, 0xf5, 0x60, 0xc3, 0x18, 0x47, 0x57, 0x91, 0xd8, 0x76, 0x9d,
	0x96, 0x63, 0x59, 0x0d, 0x52, 0x42, 0x7b, 0xc2, 0xc6, 0x07, 0xf7, 0xee, 0xde, 0x75, 0x50, 0x19,
	0x96, 0x5c, 0x3d, 0x84, 0xbd, 0x7d, 0xf7, 0x41, 0x02, 0x5a, 0xc8, 0x40, 0xef, 0xa5, 0xa0, 0x45,
	0x74, 0x77, 0x08, 0x3a, 0xb4, 0x34, 0xa6, 0x6b, 0x56, 0x02, 0x5e, 0xaa, 0xdd, 0x87, 0x8d, 0xfc,
	0x3b, 0xa9, 0xc4, 0xd9, 0x26, 0x2f, 0xa5, 0xa4, 0x95, 0xb4, 0x99, 0xf9, 0xe9, 0x23, 0x52, 0x16,
	0x9e, 0x5c, 0x6b, 0x37, 0x15, 0x55, 0x53, 0xea, 0x4d, 0x8d, 0x2c, 0xd4, 0x37, 0x61, 0x5d, 0xbe,
	0xcd, 0x12, 0xd5, 0xa3, 0xfa, 0x55, 0xb8, 0x9c, 0x5e, 0xef, 0xe6, 0xc0, 0xb5, 0x5f, 0xba, 0x09,
	0x1b, 0xf9, 0x48, 0xe4, 0xe7, 0x1c, 0xba, 0x24, 0x55, 0x46, 0x19, 0xdc, 0x8b, 0x2a, 0x23, 0x85,
	0xc5, 0x51, 0x94, 0xc5, 0xf4, 0xe2, 0x37, 0x46, 0xb1, 0xf2, 0xb4, 0x94, 0x4f, 0x8b, 0x16, 0x05,
	0x2a, 0x0f, 0x2a, 0xa4, 0x18, 0x4b, 0xc5, 0x14, 0x43, 0xdc, 0xce, 0xf9, 0x7d, 0x3f, 0x16, 0x15,
	0xdb, 0x12, 0x93, 0x0d, 0x51, 0x78, 0xe4, 0xee, 0x17, 0xa2, 0x50, 0x5b, 0x62, 0xe2, 0x37, 0xbd,
	0x09, 0xcb, 0xae, 0xbc, 0xcf, 0x58, 0xcd, 0x85, 0x26, 0x09, 0x8c, 0xbe, 0x08, 0x6b, 0x21, 0x8f,
	0xfc, 0xaf, 0x44, 0x00, 0xb4, 0x96, 0x0f, 0x43, 0xc6, 0xf0, 0xc9, 0xac, 0x05, 0xa6, 0xb3, 0x96,
	0x0a, 0x2c, 0xc6, 0x27, 0xfe, 0x40, 0x3c, 0x13, 0x4b, 0xbb, 0x10, 0x10, 0xfa, 0x1a, 0x06, 0x59,
	0xfd, 0xe1, 0x28, 0xe6, 0x5e, 0x07, 0x55, 0xb0, 0x91, 0xef, 0xa3, 0x80, 0xc2, 0x58, 0x14, 0x35,
	0xa3, 0x0f, 0xba, 0xa1, 0x8c, 0xa5, 0x36, 0xc5, 0x34, 0x8a, 0x40, 0xaa, 0xc0, 0x0a, 0x06, 0x81,
	0x2d, 0x77, 0x58, 0xd9, 0x12, 0xc1, 0xf0, 0xab, 0x73, 0x57, 0x69, 0xfc, 0x40, 0xaf, 0xe9, 0x47,
	0x31, 0x4b, 0xf9, 0x70, 0xd2, 0x7e, 0x84, 0x5d, 0xb6, 0xbb, 0x71, 0x65, 0xbb, 0x30, 0xe9, 0x0c,
	0x8e, 0xc1, 0xce, 0x28, 0xf6, 0x7b, 0xfe, 0x57, 0xf2, 0x5a, 0xef, 0x24, 0xe4, 0xd1, 0x49, 0xd0,
	0x13, 0x2c, 0x44, 0x8c, 0x6b, 0x1e, 0x9a, 0x32, 0xd8, 0x1e, 0x86, 0x7e, 0xd7, 0x1f, 0x1c, 0x63,
	0x5a, 0x21, 0xde, 0x15, 0xec, 0x4c, 0x3f, 0xfe, 0x99, 0x18, 0x69, 0x81, 0x9e, 0x4d, 0x0a, 0xa0,
	0x9f, 0xc3, 0x95, 0xf4, 0xed, 0x02, 0xda, 0xf3, 0xa0, 0x7b, 0x56, 0x78, 0x4c, 0xf5, 0xc6, 0x5c,
	0xc9, 0x89, 0xcb, 0x6d, 0x4a, 0xa6, 0xf4, 0x65, 0x51, 0x34, 0x05, 0xa5, 0xdf, 0x87, 0xcb, 0x69,
	0x0f, 0xae, 0xb8, 0x2c, 0x2f, 0xbc, 0xb0, 0x7a, 0xfd, 0xa2, 0x0e, 0xe4, 0x05, 0x7b, 0xfa, 0xd2,
	0x24, 0x9a, 0x04, 0xd2, 0xff, 0x0b, 0xd7, 0x4f, 0x53, 0xf9, 0x43, 0x37, 0xc4, 0xbc, 0x6e, 0xe2,
	0xcd, 0x55, 0xe1, 0x5a, 0xfc, 0x30, 0x11, 0xdb, 0x4e, 0x49, 0xb3, 0xc7, 0x44, 0xd1, 0x0c, 0x04,
	0xed, 0x41, 0x25, 0x13, 0x3e, 0xbe, 0x19, 0x2d, 0xbc, 0xbc, 0x7a, 0xeb, 0xa2, 0x19, 0xe4, 0xae,
	0x54, 0xd3, 0x17, 0x39, 0xd1, 0x4c, 0x0c, 0x55, 0x60, 0xed, 0xb4, 0xcf, 0xfb, 0x52, 0xfc, 0x9f,
	0x96, 0xa6, 0x47, 0x5f, 0x10, 0x7f, 0xd8, 0xe2, 0xfd, 0xe4, 0x85, 0xc8, 0x2a, 0xb2, 0x65, 0x22,
	0xba, 0xc3, 0x91, 0x14, 0xf1, 0x67, 0x17, 0x8a, 0x50, 0x87, 0xa3, 0x4c, 0x44, 0x57, 0xfe, 0xae,
	0x7e, 0x47, 0x24, 0x25, 0x39, 0x03, 0xcf, 0xaa, 0x71, 0xa5, 0x5c, 0x35, 0xee, 0x1a, 0x2c, 0x8b,
	0x02, 0x5c, 0x94, 0xd5, 0x36, 0x45, 0xab, 0xfa, 0x1b, 0x65, 0xa0, 0xd3, 0xb6, 0x81, 0xe9, 0x41,
	0x5a, 0xd5, 0xcc, 0xae, 0x8a, 0x13, 0xbc, 0x4c, 0x6d, 0xd8, 0x5c, 0x3c, 0xa6, 0x24, 0x13, 0x15,
	0xd1, 0x94, 0x53, 0xe4, 0x37, 0x6c, 0x0e, 0x96, 0x7e, 0x17, 0xaa, 0x29, 0x26, 0x77, 0x73, 0x9b,
	0xf2, 0x8a, 0x8a, 0x2b, 0x3b, 0x87, 0x82, 0x1a, 0x50, 0x9b, 0x8f, 0x2d, 0xbc, 0xec, 0x58, 0x65,
	0x4f, 0x41, 0x59, 0xfd, 0xbd, 0x12, 0xec, 0x4c, 0x59, 0xb5, 0xb8, 0x26, 0x9e, 0x9c, 0xb9, 0x6e,
	0xb6, 0xad, 0x44, 0x2d, 0xb3, 0x91, 0xf4, 0x2e, 0x5c, 0x9e, 0x98, 0xb5, 0xe0, 0x91, 0x0a, 0x99,
	0x85, 0x42, 0xbf, 0x33, 0x63, 0x8c, 0x82, 0x4b, 0xaa, 0x62, 0x1e, 0xba, 0xfa, 0x11, 0x5c, 0x9b,
	0x6d, 0xca, 0xf4, 0x15, 0xd8, 0x42, 0x27, 0xaa, 0x78, 0x3f, 0x18, 0x45, 0x71, 0x96, 0xa6, 0x96,
	0xd8, 0x04, 0xb4, 0xfa, 0x6d, 0x58, 0x4d, 0xad, 0x95, 0xbe, 0x05, 0xdb, 0x27, 0x41, 0xac, 0x78,
	0xde, 0x38, 0x4d, 0x2d, 0x24, 0xd3, 0x93, 0xd8, 0x6a, 0x08, 0xab, 0xa9, 0x9d, 0x7e, 0x6d, 0x66,
	0xfa, 0x1e, 0xd0, 0x93, 0x20, 0x66, 0xbc, 0x1f, 0x9c, 0xf2, 0x39, 0x79, 0xf1, 0x0c, 0x82, 0xea,
	0x13, 0xd8, 0x9e, 0x70, 0x9d, 0x94, 0xc3, 0xf5, 0xc4, 0x79, 0x1e, 0xb8, 0x03, 0xaf, 0xc7, 0x43,
	0xa3, 0x50, 0xbe, 0x9e, 0xb8, 0xbc, 0x50, 0x47, 0x51, 0x1c, 0x88, 0x5a, 0x48, 0x83, 0x3f, 0xbe,
	0x93, 0x0a, 0xc9, 0x58, 0xd8, 0x3c, 0x59, 0xb5, 0xdf, 0x5e, 0x87, 0xcd, 0x42, 0x14, 0x20, 0x52,
	0xb9, 0x66, 0xc7, 0xc2, 0x0c, 0x50, 0xdc, 0xba, 0x61, 0x4a, 0xa9, 0x34, 0x2c, 0x19, 0x22, 0xa9,
	0xed, 0x8e, 0x33, 0x8e, 0xc0, 0x64, 0xa4, 0x65, 0x74, 0x5a, 0x22, 0xc2, 0x4d, 0x02, 0x3b, 0x4b,
	0xa6, 0xb6, 0x7b, 0x4d, 0xf3, 0x61, 0x9e, 0x54, 0xa4, 0xb6, 0x9f, 0xbc, 0xed, 0x1c, 0xaa, 0xed,
	0x8e, 0x8c, 0x77, 0xd3, 0xf0, 0xbd, 0xcd, 0xcc, 0x43, 0xdd, 0xd2, 0x4d, 0x43, 0x6b, 0x90, 0xe5,
	0x71, 0xf2, 0x88, 0x29, 0x61, 0xab, 0x65, 0x36, 0x30, 0xe7, 0x59, 0xc9, 0x87, 0xfb, 0x4a, 0x4b,
	0x64, 0x59, 0xab, 0x18, 0x3f, 0x7e, 0xf2, 0xf6, 0xfb, 0x52, 0xe2, 0x9a, 0x68, 0xbd, 0x73, 0x4f,
	0xb6, 0x80, 0xde, 0x80, 0xab, 0x96, 0xd2, 0xd2, 0x9c, 0x64, 0x2a, 0x0e, 0xe6, 0x40, 0x8e, 0x75,
	0xa8, 0x92, 0x75, 0x31, 0x8e, 0x77, 0x24, 0xdd, 0x06, 0xc6, 0x73, 0x56, 0x53, 0xc9, 0x75, 0xb5,
	0x89, 0x69, 0xb4, 0xca, 0x4c, 0xcb, 0x9a, 0xe6, 0xdd, 0x12, 0x79, 0xe0, 0xc4, 0x74, 0x9d, 0x76,
	0x8b, 0x6c, 0xe7, 0x33, 0xd9, 0xdc, 0xa4, 0x89, 0xe8, 0xec, 0x43, 0xd9, 0xd9, 0x0e, 0x86, 0x7c,
	0x56, 0x5b, 0x51, 0x35, 0x42, 0x05, 0x3c, 0x19, 0xfa, 0x65, 0x11, 0x0a, 0x62, 0xae, 0x41, 0xae,
	0x88, 0x2c, 0x4e, 0x6b, 0x91, 0xab, 0xa8, 0xc2, 0x54, 0x20, 0xe6, 0x8b, 0x86, 0xfa, 0x88, 0x5c,
	0x13, 0x5c, 0x1f, 0x48, 0xae, 0xeb, 0x62, 0xa1, 0x4c, 0xb3, 0xa9, 0x1b, 0xfb, 0xa4, 0x22, 0xd3,
	0x19, 0x66, 0x8b, 0x3c, 0x43, 0x6b, 0x92, 0x1b, 0x22, 0x15, 0x40, 0xba, 0xaa, 0x60, 0x32, 0x24,
	0xd3, 0x33, 0x28, 0x16, 0xd7, 0x30, 0xaf, 0xf3, 0x9b, 0xa8, 0xdc, 0x71, 0x25, 0x41, 0xcc, 0xf4,
	0x59, 0xe4, 0xc7, 0x79, 0x93, 0xe7, 0x04, 0x7f, 0xa2, 0x57, 0x91, 0xaa, 0x7e, 0xf2, 0x9e, 0x6c,
	0xec, 0x8a, 0x6c, 0xe1, 0xa1, 0xd2, 0x6e, 0xe3, 0x10, 0x5e, 0xc0, 0xcc, 0xd0, 0xd2, 0xf6, 0x5b,
	0x9a, 0x61, 0xcb, 0xc9, 0xd7, 0x44, 0xaa, 0xd3, 0x34, 0x1f, 0x92, 0x17, 0xc5, 0x85, 0xad, 0x62,
	0x2b, 0x38, 0x23, 0x8d, 0xbc, 0x84, 0xa9, 0x5e, 0xaa, 0x62, 0x4c, 0x1c, 0x33, 0x05, 0xbf, 0x8c,
	0xe3, 0xcb, 0x0d, 0xa5, 0x81, 0x39, 0xd7, 0x2b, 0xb8, 0x48, 0xba, 0xe9, 0xd8, 0x07, 0xcc, 0xec,
	0xec, 0x1f, 0xb4, 0x3b, 0x36, 0x79, 0x15, 0xf5, 0x84, 0x63, 0xb8, 0x85, 0x61, 0x75, 0x1d, 0x35,
	0x6e, 0x1a, 0x38, 0x8a, 0xd7, 0x10, 0x71, 0xd8, 0x50, 0xc9, 0xeb, 0xc2, 0x1e, 0xde, 0x7f, 0x57,
	0x0e, 0xf5, 0x0d, 0x24, 0x53, 0x4d, 0xc3, 0xd0, 0x44, 0x85, 0x80, 0xdc, 0xc6, 0x7e, 0x5a, 0x5a,
	0xab, 0xa0, 0x87, 0x37, 0xf3, 0xb5, 0x9a, 0x3b, 0x22, 0x21, 0xd0, 0xec, 0x7c, 0xaf, 0x6f, 0xd1,
	0x9b, 0x50, 0x99, 0x5a, 0xfe, 0x94, 0xe3, 0xae, 0x48, 0xd4, 0x99, 0x62, 0x58, 0xb2, 0x0c, 0x21,
	0x73, 0x54, 0xec, 0x24, 0x67, 0x10, 0xf7, 0x90, 0xa8, 0x61, 0xb5, 0x5b, 0x8e, 0xa2, 0x62, 0x3e,
	0x4b, 0xde, 0xc1, 0xc9, 0x31, 0xcd, 0x6a, 0x9b, 0x68, 0xf1, 0xb6, 0xde, 0xd2, 0xc8, 0xbb, 0x32,
	0x8d, 0xd3, 0x5a, 0xe4, 0x3d, 0x44, 0x26, 0x45, 0x8d, 0xb6, 0xc6, 0x5a, 0xba, 0x4d, 0xde, 0x9f,
	0x28, 0xd2, 0x7c, 0x30, 0x59, 0x2f, 0xf8, 0x30, 0x5f, 0x4d, 0xf8, 0x96, 0x58, 0xaf, 0x44, 0x09,
	0xf7, 0xf3, 0x36, 0x95, 0x6e, 0xf1, 0x6f, 0x63, 0x92, 0xa7, 0x7d, 0x6a, 0x6b, 0x86, 0x4d, 0xbe,
	0x83, 0xbf, 0x93, 0x71, 0xfd, 0x1f, 0x31, 0xae, 0xf1, 0x4a, 0x74, 0xda, 0xe4, 0xbb, 0xd8, 0xd5,
	0xa1, 0xd2, 0x6e, 0xa7, 0x63, 0xff, 0x5e, 0x61, 0x57, 0x4a, 0xd8, 0x47, 0xa8, 0xf7, 0xc3, 0x54,
	0x27, 0x0a, 0xfa, 0x87, 0x06, 0x2a, 0x29, 0x6f, 0x18, 0x75, 0xec, 0xa7, 0x51, 0x77, 0x70, 0x8a,
	0x2a, 0x0e, 0x2a, 0xa7, 0x35, 0x07, 0x53, 0xcb, 0x06, 0x7a, 0x81, 0x46, 0xdd, 0x51, 0x15, 0xf5,
	0x40, 0x73, 0x0e, 0x74, 0xdb, 0x61, 0x8a, 0xad, 0x11, 0x0d, 0x07, 0x70, 0x60, 0xda, 0x99, 0xca,
	0xf7, 0x84, 0x39, 0x9b, 0xcd, 0xa6, 0x5c, 0x56, 0xa9, 0xbe, 0x7d, 0x59, 0x93, 0xd9, 0xdb, 0x13,
	0xab, 0x94, 0x6e, 0xeb, 0x03, 0xfa, 0x1c, 0x54, 0x2d, 0x73, 0xcf, 0x7e, 0xa8, 0x30, 0xcd, 0x99,
	0xf6, 0x30, 0xba, 0x98, 0x5c, 0x6b, 0xbc, 0x30, 0x1f, 0xa3, 0x3d, 0x1f, 0xe4, 0x3d, 0xc3, 0x83,
	0xc4, 0x24, 0x50, 0xb3, 0x4e, 0xdb, 0x6c, 0xea, 0xea, 0x23, 0xd2, 0xc4, 0xb5, 0x3a, 0xd0, 0x94,
	0x36, 0x69, 0x89, 0x31, 0x67, 0xd5, 0xb4, 0x54, 0x8c, 0x21, 0x3c, 0x51, 0x52, 0x03, 0x6a, 0x6a,
	0x87, 0x5a, 0x33, 0x53, 0xbd, 0x29, 0x6a, 0x69, 0xb2, 0xae, 0xa1, 0x1b, 0xfb, 0x4e, 0xc7, 0xd0,
	0x6d, 0x8b, 0xb4, 0x8b, 0x55, 0x8c, 0x3a, 0x81, 0xad, 0x2c, 0x2d, 0x93, 0xd9, 0x20, 0x81, 0xad,
	0x93, 0x20, 0x16, 0x69, 0x8d, 0x7c, 0x34, 0x5f, 0x7b, 0x0f, 0xae, 0xce, 0x0c, 0x34, 0xc5, 0x97,
	0x18, 0x29, 0x20, 0x79, 0xc7, 0x34, 0x06, 0xd4, 0x7e, 0xfd, 0x0a, 0xac, 0xee, 0x87, 0xc1, 0x68,
	0x88, 0xb9, 0xa3, 0x92, 0xa5, 0x9c, 0xf1, 0xf8, 0x89, 0xe7, 0xd7, 0xfb, 0xfc, 0xea, 0x05, 0xd8,
	0x48, 0x92, 0x29, 0x67, 0x30, 0xe7, 0x5a, 0xe8, 0x79, 0x80, 0x63, 0xec, 0x51, 0x12, 0x88, 0xe7,
	0x47, 0x07, 0x97, 0xd8, 0x9a, 0x80, 0x09, 0x02, 0x03, 0xb6, 0xbb, 0xc1, 0x20, 0x8a, 0x43, 0xd7,
	0x1f, 0xc4, 0x8e, 0x3f, 0x78, 0x1c, 0xcc, 0x7a, 0x6e, 0x96, 0x8e, 0x5a, 0x7c, 0x60, 0x23, 0x69,
	0xf5, 0xc1, 0xe3, 0xe0, 0xe0, 0x92, 0xfc, 0xc4, 0x66, 0x0c, 0xa1, 0x9f, 0xc2, 0xe5, 0x88, 0xf7,
	0x78, 0x57, 0x84, 0xe9, 0xd1, 0x90, 0x77, 0x9d, 0x9e, 0x1f, 0xc5, 0x22, 0x0f, 0x5d, 0x2f, 0x26,
	0xc6, 0x99, 0x4c, 0x2b, 0xa5, 0xb7, 0x86, 0xbc, 0x8b, 0x01, 0xe9, 0x41, 0x89, 0xed, 0x44, 0x93,
	0x40, 0xaa, 0xc2, 0x7a, 0x9f, 0xf7, 0x8f, 0x78, 0x28, 0x25, 0x2e, 0x4f, 0x5f, 0x2d, 0x66, 0x12,
	0x5b, 0x82, 0x2e, 0x4a, 0x64, 0x81, 0x64, 0x13, 0x42, 0x7a, 0x70, 0xc3, 0xf5, 0x3c, 0xee, 0x39,
	0xee, 0xc0, 0x73, 0x42, 0x11, 0x15, 0x78, 0x8e, 0xc4, 0x47, 0x95, 0x19, 0x8f, 0xd6, 0x33, 0x91,
	0x0a, 0x72, 0x29, 0x03, 0x4f, 0x46, 0x12, 0x5e, 0xb1, 0x87, 0x6b, 0xee, 0x4c, 0x2c, 0xbd, 0x05,
	0xdb, 0x51, 0x30, 0x0a, 0xbb, 0xdc, 0x91, 0x8b, 0xe0, 0x7b, 0xf2, 0x8d, 0xd2, 0x41, 0x89, 0x6d,
	0x4a, 0x84, 0x90, 0xaf, 0x7b, 0x33, 0x3f, 0x2d, 0x5b, 0xfb, 0x46, 0x9f, 0x96, 0x15, 0x3f, 0xfb,
	0x81, 0xaf, 0xfd, 0xd9, 0x4f, 0xf5, 0x57, 0x16, 0xe4, 0x35, 0x49, 0x6e, 0x71, 0x9b, 0x05, 0x63,
	0x89, 0xc7, 0x15, 0x8f, 0x8b, 0x8c, 0x45, 0x98, 0x6e, 0xce, 0x54, 0x84, 0xf9, 0xbe, 0x08, 0x9b,
	0x79, 0xd3, 0x4b, 0x3f, 0x24, 0xdc, 0xc8, 0x59, 0x94, 0x47, 0x77, 0x61, 0xd5, 0x8f, 0x9c, 0xa3,
	0xd1, 0xd9, 0xe4, 0xf3, 0x8d, 0x15, 0x3f, 0xaa, 0x23, 0x94, 0x7e, 0x2c, 0x2e, 0xd4, 0x78, 0xe8,
	0xf4, 0x79, 0xec, 0xca, 0xc4, 0x48, 0x5a, 0x70, 0x6d, 0xe6, 0xa0, 0x04, 0x53, 0xf6, 0xa1, 0xdb,
	0xe6, 0x51, 0xbe, 0x49, 0xdf, 0x05, 0x3a, 0xe0, 0xdc, 0x73, 0xba, 0x41, 0x7f, 0xd8, 0x13, 0x75,
	0x03, 0x37, 0x94, 0x45, 0x94, 0xac, 0xdf, 0x1d, 0x24, 0x50, 0xf3, 0x78, 0xfa, 0x6a, 0x41, 0x2d,
	0x62, 0xa7, 0x2d, 0x8b, 0xa9, 0xe4, 0x66, 0x2c, 0x36, 0xdb, 0xb7, 0xe0, 0xca, 0xe3, 0x20, 0xd4,
	0x9e, 0x74, 0x7b, 0x23, 0x6f, 0xfc, 0xf2, 0x44, 0x1a, 0xde, 0xf8, 0xb1, 0xea, 0x2c, 0x92, 0xea,
	0xff, 0x83, 0x9d, 0xa9, 0x7d, 0x42, 0x75, 0xd8, 0x2a, 0x6e, 0x36, 0x71, 0xe9, 0x38, 0x6f, 0xe6,
	0x05, 0x7e, 0xb6, 0x59, 0xd8, 0x61, 0xd5, 0x97, 0x61, 0x3d, 0x67, 0xd3, 0x98, 0xfe, 0xc9, 0x5d,
	0x91, 0x3e, 0x79, 0x91, 0xad, 0xea, 0x09, 0x54, 0xe7, 0xef, 0x04, 0x5a, 0x83, 0x0d, 0xb1, 0x13,
	0x12, 0x58, 0xc2, 0x5b, 0x80, 0xc9, 0x57, 0xc7, 0x79, 0xce, 0x24, 0xc1, 0x9c, 0x80, 0x56, 0x03,
	0xd8, 0x2c, 0x2c, 0x15, 0x3a, 0xcc, 0x88, 0x8b, 0x4f, 0x2f, 0xbe, 0x9e, 0xc3, 0x94, 0x4c, 0xc2,
	0xe2, 0x9e, 0x81, 0x15, 0x37, 0x76, 0xfa, 0x41, 0x14, 0x0b, 0x5f, 0xb9, 0x73, 0xbf, 0xfc, 0xe6,
	0xdb, 0x6c, 0xd9, 0x8d, 0x5b, 0x41, 0x14, 0x57, 0x7f, 0xbc, 0x02, 0x9b, 0x05, 0x15, 0xd1, 0x2a,
	0xac, 0xa6, 0xf7, 0x86, 0x49, 0x6e, 0x9c, 0xb5, 0xe9, 0x67, 0xb0, 0xcd, 0x9f, 0x0c, 0x43, 0x1e,
	0x61, 0xba, 0x24, 0x47, 0x54, 0x16, 0x5b, 0xe1, 0xed, 0x8b, 0x75, 0x7f, 0x47, 0xcb, 0x38, 0xe5,
	0xc6, 0xe0, 0x85, 0x36, 0xa6, 0x8c, 0x69, 0x3f, 0x8e, 0x48, 0xbb, 0x1d, 0x2f, 0x18, 0x1d, 0xf5,
	0xa4, 0xff, 0x2e, 0x89, 0x0f, 0xb0, 0x12, 0xf4, 0x21, 0x62, 0x1b, 0x02, 0x39, 0x83, 0x2b, 0x8a,
	0x43, 0x7f, 0x70, 0x2c, 0xaf, 0xfd, 0xa7, 0xb8, 0x2c, 0x81, 0xa4, 0x31, 0x54, 0x67, 0x72, 0xe5,
	0xdd, 0xf6, 0x7b, 0x4f, 0x31, 0xa5, 0xd4, 0x13, 0x49, 0xb1, 0xc2, 0x2f, 0x5e, 0xc2, 0x2c, 0x68,
	0xaa, 0x47, 0x61, 0x28, 0xd3, 0xbd, 0xca, 0x19, 0xe6, 0x5d, 0xfb, 0xd7, 0xe9, 0x55, 0xaa, 0x60,
	0x66, 0xaf, 0x63, 0x54, 0xf5, 0xdb, 0x40, 0xa7, 0x87, 0x49, 0x5f, 0x16, 0x1f, 0x85, 0xe6, 0xc6,
	0x92, 0x98, 0xed, 0x66, 0x41, 0x4c, 0x9e, 0x79, 0x2c, 0x72, 0x0e, 0x73, 0x69, 0x82, 0xb9, 0xf6,
	0x87, 0x65, 0xd8, 0x2a, 0x2e, 0x3a, 0x86, 0x6d, 0xda, 0x27, 0x1d, 0xa5, 0xe9, 0xd8, 0x26, 0xb9,
	0x84, 0xb1, 0x8f, 0x61, 0xda, 0x4e, 0x06, 0x11, 0xf7, 0x25, 0x4d, 0x85, 0xed, 0x6b, 0xcc, 0xb1,
	0x0f, 0x14, 0xcc, 0xfc, 0x9e, 0x81, 0xeb, 0x39, 0x80, 0x63, 0xb2, 0x31, 0xf5, 0x82, 0xc8, 0x05,
	0x5a, 0x4a, 0xb3, 0x99, 0x92, 0x2f, 0x62, 0xe8, 0x9c, 0x87, 0x14, 0xe8, 0x97, 0x92, 0x8b, 0x01,
	0x5b, 0xd1, 0x0d, 0x8b, 0x2c, 0xa7, 0xbd, 0x67, 0x90, 0x15, 0x84, 0xa4, 0x17, 0x51, 0x0d, 0xa7,
	0xfe, 0x88, 0xac, 0x8a, 0xc4, 0x73, 0x4c, 0x23, 0xa1, 0xe2, 0x2e, 0x84, 0x69, 0xfb, 0xda, 0xa7,
	0x04, 0xc4, 0x45, 0x95, 0x6e, 0xd9, 0x8e, 0x79, 0xa8, 0xb1, 0xa6, 0xd2, 0x26, 0xeb, 0xc8, 0x22,
	0x20, 0xc8, 0x97, 0x42, 0x37, 0x30, 0x73, 0x13, 0xd0, 0xbd, 0x4e, 0xb3, 0x39, 0xee, 0x52, 0xa4,
	0x81, 0x53, 0x70, 0xd9, 0xcd, 0x56, 0x7d, 0x1b, 0x26, 0x14, 0xfa, 0xfb, 0xa5, 0xfc, 0xe1, 0x24,
	0x14, 0x7a, 0x03, 0xae, 0xd6, 0x3b, 0x8f, 0x34, 0xe6, 0x58, 0x9a, 0x98, 0xb5, 0xb2, 0xb7, 0xa7,
	0x1b, 0x18, 0x47, 0x5e, 0xc2, 0x50, 0xb4, 0x88, 0x32, 0x6c, 0x7d, 0x8c, 0x2f, 0xc9, 0x9b, 0x30,
	0xc4, 0xcb, 0xbf, 0x19, 0xa6, 0x4c, 0x9f, 0x85, 0x1b, 0x05, 0x4c, 0x81, 0x71, 0x21, 0x9f, 0xbb,
	0x2f, 0x8a, 0x9b, 0x3f, 0x8d, 0xed, 0x6b, 0x64, 0x69, 0x7e, 0x0c, 0xba, 0x5c, 0x5f, 0x86, 0x45,
	0x8c, 0xb2, 0xea, 0x6b, 0xb0, 0x92, 0xc4, 0x1d, 0xb5, 0x4f, 0x60, 0x5d, 0x0d, 0x06, 0x31, 0x7f,
	0x22, 0x9f, 0xe0, 0x3c, 0x07, 0xd0, 0x95, 0xcd, 0x07, 0xd9, 0xa3, 0xe3, 0x1c, 0x04, 0xbd, 0x6c,
	0xd2, 0x3a, 0xcc, 0x3d, 0x41, 0x2e, 0xc0, 0x6a, 0x3f, 0x2a, 0xc3, 0xf6, 0xc4, 0x27, 0xc6, 0xf4,
	0x0a, 0x2c, 0xf1, 0x53, 0x59, 0xc4, 0x11, 0x0f, 0xec, 0x44, 0x43, 0xde, 0x16, 0xc4, 0xfc, 0x38,
	0x08, 0xcf, 0x12, 0x49, 0x59, 0x5b, 0xbc, 0xa5, 0x1f, 0x1d, 0xa9, 0x29, 0x3a, 0xf9, 0x9e, 0x3f,
	0x07, 0x12, 0x25, 0xfe, 0xdc, 0x0b, 0xec, 0xe4, 0xb5, 0x7d, 0x0e, 0x44, 0x75, 0x58, 0x8d, 0xf8,
	0x29, 0x0f, 0xd3, 0xdb, 0x88, 0xad, 0x62, 0x44, 0x33, 0x31, 0xc8, 0x3b, 0x56, 0x42, 0x7b, 0x3f,
	0x8d, 0xc9, 0x59, 0xc6, 0x5e, 0xdb, 0x87, 0xd5, 0x14, 0x8d, 0x9a, 0x4f, 0x83, 0xf6, 0x4b, 0x98,
	0xde, 0x18, 0x26, 0x6b, 0x29, 0x4d, 0x79, 0xcd, 0xd3, 0xd2, 0x0d, 0x93, 0x91, 0xb2, 0xf8, 0xa9,
	0x7c, 0x6c, 0x32, 0xb2, 0x20, 0xec, 0x9d, 0xe9, 0xb6, 0xae, 0x2a, 0x4d, 0xb2, 0x58, 0xfb, 0xad,
	0x12, 0x6c, 0x16, 0x2a, 0x38, 0x94, 0x4d, 0x3e, 0x57, 0xfc, 0x7a, 0xf5, 0x9e, 0xf1, 0x68, 0xc7,
	0x62, 0x6a, 0x1f, 0xc2, 0xce, 0x14, 0x61, 0x71, 0xdc, 0xd7, 0x80, 0x16, 0xf3, 0x1b, 0x47, 0x6b,
	0xef, 0x93, 0x52, 0x6d, 0x0f, 0x68, 0xfa, 0xbd, 0x34, 0x1f, 0x7f, 0x7d, 0x3f, 0xf1, 0x81, 0x42,
	0x79, 0xf6, 0xb7, 0x10, 0xb8, 0x86, 0xc9, 0xb7, 0x10, 0xb5, 0x9f, 0x2c, 0xc0, 0xca, 0x5e, 0x2f,
	0xf8, 0x12, 0x57, 0xff, 0x33, 0xa8, 0xc8, 0x90, 0x73, 0x5a, 0xb2, 0x10, 0xb6, 0x7e, 0xef, 0xb9,
	0xe9, 0xb3, 0x34, 0x4f, 0xc5, 0xe6, 0xf2, 0xd3, 0x43, 0xb8, 0xe6, 0xf1, 0x28, 0x9e, 0x21, 0xb9,
	0xfc, 0x54, 0x92, 0xe7, 0x70, 0xd3, 0x0f, 0xc5, 0x01, 0x1c, 0x07, 0xdd, 0xa0, 0x27, 0x5e, 0x85,
	0x6e, 0x15, 0x5f, 0x27, 0x26, 0x53, 0xc3, 0x53, 0x40, 0xd0, 0xb0, 0x8c, 0x1a, 0xf7, 0xd0, 0xe3,
	0x5e, 0xf0, 0xa5, 0xfc, 0x10, 0xaf, 0xb2, 0x28, 0xde, 0x72, 0xe5, 0x20, 0xe2, 0xfb, 0xb5, 0xa4,
	0x50, 0xbc, 0x24, 0x90, 0x69, 0x93, 0xde, 0x86, 0x9d, 0x38, 0x74, 0x07, 0x51, 0xdf, 0x8f, 0x63,
	0xee, 0x25, 0x02, 0x96, 0x05, 0xcd, 0x34, 0x42, 0x46, 0x33, 0x5d, 0xee, 0x9f, 0x66, 0xa4, 0x2b,
	0x82, 0x74, 0x02, 0x5a, 0xbb, 0x0b, 0xab, 0xe9, 0x28, 0xe9, 0x0a, 0x2c, 0xd8, 0x6a, 0x9b, 0x94,
	0xf0, 0x47, 0xa7, 0xd1, 0x26, 0x65, 0x4a, 0x61, 0x33, 0x31, 0x0a, 0xa7, 0xcd, 0x4c, 0xdb, 0x24,
	0x3f, 0x5d, 0x79, 0xfd, 0x15, 0x80, 0x71, 0x84, 0x2e, 0xcc, 0x46, 0xc6, 0xe8, 0xb2, 0x48, 0xd8,
	0xd0, 0x9a, 0x1a, 0x36, 0x4a, 0xf5, 0xdb, 0xf0, 0x7c, 0x37, 0xe8, 0xdf, 0x39, 0xed, 0xc7, 0xa3,
	0xf0, 0x28, 0xb8, 0x33, 0xec, 0xb9, 0xf1, 0xe3, 0x20, 0xec, 0x27, 0x7a, 0xba, 0xe3, 0xc5, 0x41,
	0x7d, 0x2d, 0xfb, 0x9f, 0x20, 0xff, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x03, 0x9c, 0xae, 0xfc, 0x1f,
	0x44, 0x00, 0x00,
}
