// Code generated by protoc-gen-go. DO NOT EDIT.
// source: PricingDTO.proto

package proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The unit for the price.
// The unit affects how to use the price to calculate the cost for an entity,
// and is also useful when displaying information for UI purposes.
//
// TODO (roman, Jul 31 2018): Not all units are relevant for all types of cloud entities.
// In the future it may be worth it to have each type of cloud entity have its own unit,
// to avoid confusion.
type Price_Unit int32

const (
	// The price is calculated on an hourly basis.
	// One unit = one hour.
	Price_HOURS Price_Unit = 1
	// The price is calculated on a daily basis.
	// One unit = one day.
	Price_DAYS Price_Unit = 2
	// The price is calculated on a monthly basis.
	// One unit = one month.
	Price_MONTH Price_Unit = 3
	// The price is a total one-time cost.
	Price_TOTAL Price_Unit = 10
	// The price is calculated on a per-IOPS rate.
	// One unit = one million iops.
	Price_MILLION_IOPS Price_Unit = 20
	// The price is calculated on a GB-month.
	// One unit = one GB-month.
	// A GB-month is gigabytes averaged over the month. For example, if you store 30 GB
	// for 15 days of a 30-day month, that would add up to 15 GB-month.
	Price_GB_MONTH Price_Unit = 21
	// The price is calculated on a per-MiB/s of throughput basis per month.
	// One unit = one month of 1 MiB/s throughput.
	Price_MBPS_MONTH Price_Unit = 22
)

var Price_Unit_name = map[int32]string{
	1:  "HOURS",
	2:  "DAYS",
	3:  "MONTH",
	10: "TOTAL",
	20: "MILLION_IOPS",
	21: "GB_MONTH",
	22: "MBPS_MONTH",
}

var Price_Unit_value = map[string]int32{
	"HOURS":        1,
	"DAYS":         2,
	"MONTH":        3,
	"TOTAL":        10,
	"MILLION_IOPS": 20,
	"GB_MONTH":     21,
	"MBPS_MONTH":   22,
}

func (x Price_Unit) Enum() *Price_Unit {
	p := new(Price_Unit)
	*p = x
	return p
}

func (x Price_Unit) String() string {
	return proto.EnumName(Price_Unit_name, int32(x))
}

func (x *Price_Unit) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Price_Unit_value, data, "Price_Unit")
	if err != nil {
		return err
	}
	*x = Price_Unit(value)
	return nil
}

func (Price_Unit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{5, 0}
}

// The list of prices for a particular compute tier. In the cloud, a compute tier is
// the seller of CPU/memory (but not storage) to a VM. It is commonly referred to as an
// "instance" (e.g. Compute Instance in AWS). We use the tier terminology to be consistent
// across compute and storage, and because you can think of the compute instances as
// different available "tiers" of the Compute service.
//
// A single compute tier may have different available prices depending on other
// configuration option (for example, whether it's shared or a dedicated).
type ComputeTierPriceList struct {
	// The base price is the price of the default - and usually cheapest - configuration.
	// For example, in AWS this would be a shared Linux machine (which has no extra license
	// or tenancy costs).
	BasePrice *ComputeTierPriceList_ComputeTierConfigPrice `protobuf:"bytes,1,opt,name=base_price,json=basePrice" json:"base_price,omitempty"`
	// There are the other configurations available for the tier, and the
	// prices for those configurations ON TOP of the base price. We track it this way
	// so that we can easily separate the compute cost from the license/tenancy cost.
	//
	// For example, if the base price is for a Linux machine that costs $1/hr, and a Windows OS
	// machine costs $1.50/hr, there would be a price adjustment for a Windows OS with price
	// "0.50/hr". To get the full price for a Windows insance you would need to find the
	// appropriate price adjustment, and add it to the base price.
	//
	// The configuration from the base price should not appear in this list.
	PerConfigurationPriceAdjustments []*ComputeTierPriceList_ComputeTierConfigPrice `protobuf:"bytes,2,rep,name=per_configuration_price_adjustments,json=perConfigurationPriceAdjustments" json:"per_configuration_price_adjustments,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}                                       `json:"-"`
	XXX_unrecognized                 []byte                                         `json:"-"`
	XXX_sizecache                    int32                                          `json:"-"`
}

func (m *ComputeTierPriceList) Reset()         { *m = ComputeTierPriceList{} }
func (m *ComputeTierPriceList) String() string { return proto.CompactTextString(m) }
func (*ComputeTierPriceList) ProtoMessage()    {}
func (*ComputeTierPriceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{0}
}

func (m *ComputeTierPriceList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ComputeTierPriceList.Unmarshal(m, b)
}
func (m *ComputeTierPriceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ComputeTierPriceList.Marshal(b, m, deterministic)
}
func (m *ComputeTierPriceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComputeTierPriceList.Merge(m, src)
}
func (m *ComputeTierPriceList) XXX_Size() int {
	return xxx_messageInfo_ComputeTierPriceList.Size(m)
}
func (m *ComputeTierPriceList) XXX_DiscardUnknown() {
	xxx_messageInfo_ComputeTierPriceList.DiscardUnknown(m)
}

var xxx_messageInfo_ComputeTierPriceList proto.InternalMessageInfo

func (m *ComputeTierPriceList) GetBasePrice() *ComputeTierPriceList_ComputeTierConfigPrice {
	if m != nil {
		return m.BasePrice
	}
	return nil
}

func (m *ComputeTierPriceList) GetPerConfigurationPriceAdjustments() []*ComputeTierPriceList_ComputeTierConfigPrice {
	if m != nil {
		return m.PerConfigurationPriceAdjustments
	}
	return nil
}

// The price for a particular configuration of a compute tier.
type ComputeTierPriceList_ComputeTierConfigPrice struct {
	// The guest operating system.
	GuestOsType *OSType `protobuf:"varint,1,opt,name=guest_os_type,json=guestOsType,enum=common_dto.OSType" json:"guest_os_type,omitempty"`
	// The tenancy for this configuration of the tier.
	// A single tier may have different tenancy options that will be priced differently
	// (e.g. dedicated tenancy is more expensive than shared).
	Tenancy *Tenancy `protobuf:"varint,2,opt,name=tenancy,enum=common_dto.Tenancy" json:"tenancy,omitempty"`
	// The available prices for this configuration of the tier. There may be multiple
	// prices (e.g. an hourly price and a monthly price).
	Prices               []*Price `protobuf:"bytes,10,rep,name=prices" json:"prices,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ComputeTierPriceList_ComputeTierConfigPrice) Reset() {
	*m = ComputeTierPriceList_ComputeTierConfigPrice{}
}
func (m *ComputeTierPriceList_ComputeTierConfigPrice) String() string {
	return proto.CompactTextString(m)
}
func (*ComputeTierPriceList_ComputeTierConfigPrice) ProtoMessage() {}
func (*ComputeTierPriceList_ComputeTierConfigPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{0, 0}
}

func (m *ComputeTierPriceList_ComputeTierConfigPrice) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ComputeTierPriceList_ComputeTierConfigPrice.Unmarshal(m, b)
}
func (m *ComputeTierPriceList_ComputeTierConfigPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ComputeTierPriceList_ComputeTierConfigPrice.Marshal(b, m, deterministic)
}
func (m *ComputeTierPriceList_ComputeTierConfigPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComputeTierPriceList_ComputeTierConfigPrice.Merge(m, src)
}
func (m *ComputeTierPriceList_ComputeTierConfigPrice) XXX_Size() int {
	return xxx_messageInfo_ComputeTierPriceList_ComputeTierConfigPrice.Size(m)
}
func (m *ComputeTierPriceList_ComputeTierConfigPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_ComputeTierPriceList_ComputeTierConfigPrice.DiscardUnknown(m)
}

var xxx_messageInfo_ComputeTierPriceList_ComputeTierConfigPrice proto.InternalMessageInfo

func (m *ComputeTierPriceList_ComputeTierConfigPrice) GetGuestOsType() OSType {
	if m != nil && m.GuestOsType != nil {
		return *m.GuestOsType
	}
	return OSType_UNKNOWN_OS
}

func (m *ComputeTierPriceList_ComputeTierConfigPrice) GetTenancy() Tenancy {
	if m != nil && m.Tenancy != nil {
		return *m.Tenancy
	}
	return Tenancy_DEFAULT
}

func (m *ComputeTierPriceList_ComputeTierConfigPrice) GetPrices() []*Price {
	if m != nil {
		return m.Prices
	}
	return nil
}

// The list of prices for a particular database tier. In the cloud, a database tier is
// a managed database solution (e.g. RDS in AWS). It is commonly referred to as an
// "instance" (e.g. Database Instance in AWS). We use the tier terminology to be consistent
// with compute and storage, and because you can think of the database instances as
// different available "tiers" of databases.
//
// A single database tier may have different available prices depending on other
// configuration options (for example, the database engine).
type DatabaseTierPriceList struct {
	// The base price is the price of the default - and usually cheapest - configuration.
	// For example, in AWS this would be a shared Linux machine (which has no extra license
	// or tenancy costs).
	BasePrice *DatabaseTierPriceList_DatabaseTierConfigPrice `protobuf:"bytes,1,opt,name=base_price,json=basePrice" json:"base_price,omitempty"`
	// There are the other configurations available for the database instance, and the
	// prices for those configurations ON TOP of the base price. We track it this way
	// so that we can easily separate the compute cost from the license/tenancy cost.
	//
	// For example, if the base price is for a PostgreSQL machine that costs $1/hr, and an Oracle
	// machine costs $1.50/hr, there would be a price adjustment for Oracle with price
	// "0.50/hr". To get the full price for an Oracle insance you would need to find the
	// appropriate price adjustment, and add it to the base price.
	//
	// The configuration from the base price should not appear in this list.
	ConfigurationPriceAdjustments []*DatabaseTierPriceList_DatabaseTierConfigPrice `protobuf:"bytes,2,rep,name=configuration_price_adjustments,json=configurationPriceAdjustments" json:"configuration_price_adjustments,omitempty"`
	// different deployment types has different costs
	DeploymentType *DeploymentType `protobuf:"varint,3,opt,name=deployment_type,json=deploymentType,enum=common_dto.DeploymentType" json:"deployment_type,omitempty"`
	// List of DB storage prices.
	DependentPrices      []*Price `protobuf:"bytes,4,rep,name=dependent_prices,json=dependentPrices" json:"dependent_prices,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseTierPriceList) Reset()         { *m = DatabaseTierPriceList{} }
func (m *DatabaseTierPriceList) String() string { return proto.CompactTextString(m) }
func (*DatabaseTierPriceList) ProtoMessage()    {}
func (*DatabaseTierPriceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{1}
}

func (m *DatabaseTierPriceList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DatabaseTierPriceList.Unmarshal(m, b)
}
func (m *DatabaseTierPriceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DatabaseTierPriceList.Marshal(b, m, deterministic)
}
func (m *DatabaseTierPriceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseTierPriceList.Merge(m, src)
}
func (m *DatabaseTierPriceList) XXX_Size() int {
	return xxx_messageInfo_DatabaseTierPriceList.Size(m)
}
func (m *DatabaseTierPriceList) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseTierPriceList.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseTierPriceList proto.InternalMessageInfo

func (m *DatabaseTierPriceList) GetBasePrice() *DatabaseTierPriceList_DatabaseTierConfigPrice {
	if m != nil {
		return m.BasePrice
	}
	return nil
}

func (m *DatabaseTierPriceList) GetConfigurationPriceAdjustments() []*DatabaseTierPriceList_DatabaseTierConfigPrice {
	if m != nil {
		return m.ConfigurationPriceAdjustments
	}
	return nil
}

func (m *DatabaseTierPriceList) GetDeploymentType() DeploymentType {
	if m != nil && m.DeploymentType != nil {
		return *m.DeploymentType
	}
	return DeploymentType_SINGLE_AZ
}

func (m *DatabaseTierPriceList) GetDependentPrices() []*Price {
	if m != nil {
		return m.DependentPrices
	}
	return nil
}

// The price for a particular configuration of a database tier.
type DatabaseTierPriceList_DatabaseTierConfigPrice struct {
	// The database engine to use for this configuration of the tier.
	// Should be set.
	DbEngine *DatabaseEngine `protobuf:"varint,1,opt,name=db_engine,json=dbEngine,enum=common_dto.DatabaseEngine" json:"db_engine,omitempty"`
	// The edition of the engine to use for this configuration of the tier. Not to be confused
	// with "version", which doesn't affect the price.
	//
	// May be unset, because open-source database engines often don't have editions.
	DbEdition *DatabaseEdition `protobuf:"varint,2,opt,name=db_edition,json=dbEdition,enum=common_dto.DatabaseEdition" json:"db_edition,omitempty"`
	// LicenseModel describes all supported license models in cloud projects.
	DbLicenseModel *LicenseModel `protobuf:"varint,3,opt,name=db_license_model,json=dbLicenseModel,enum=common_dto.LicenseModel" json:"db_license_model,omitempty"`
	// // DeploymentType describes all supported deployment types by cloud probes.
	DbDeploymentType *DeploymentType `protobuf:"varint,4,opt,name=db_deployment_type,json=dbDeploymentType,enum=common_dto.DeploymentType" json:"db_deployment_type,omitempty"`
	// The available prices for this configuration of the database tier.
	// There may be different prices (e.g. an hourly price and a monthly price).
	Prices               []*Price `protobuf:"bytes,20,rep,name=prices" json:"prices,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) Reset() {
	*m = DatabaseTierPriceList_DatabaseTierConfigPrice{}
}
func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) String() string {
	return proto.CompactTextString(m)
}
func (*DatabaseTierPriceList_DatabaseTierConfigPrice) ProtoMessage() {}
func (*DatabaseTierPriceList_DatabaseTierConfigPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{1, 0}
}

func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DatabaseTierPriceList_DatabaseTierConfigPrice.Unmarshal(m, b)
}
func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DatabaseTierPriceList_DatabaseTierConfigPrice.Marshal(b, m, deterministic)
}
func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseTierPriceList_DatabaseTierConfigPrice.Merge(m, src)
}
func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) XXX_Size() int {
	return xxx_messageInfo_DatabaseTierPriceList_DatabaseTierConfigPrice.Size(m)
}
func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseTierPriceList_DatabaseTierConfigPrice.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseTierPriceList_DatabaseTierConfigPrice proto.InternalMessageInfo

func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) GetDbEngine() DatabaseEngine {
	if m != nil && m.DbEngine != nil {
		return *m.DbEngine
	}
	return DatabaseEngine_UNKNOWN
}

func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) GetDbEdition() DatabaseEdition {
	if m != nil && m.DbEdition != nil {
		return *m.DbEdition
	}
	return DatabaseEdition_NONE
}

func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) GetDbLicenseModel() LicenseModel {
	if m != nil && m.DbLicenseModel != nil {
		return *m.DbLicenseModel
	}
	return LicenseModel_BRING_YOUR_OWN_LICENSE
}

func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) GetDbDeploymentType() DeploymentType {
	if m != nil && m.DbDeploymentType != nil {
		return *m.DbDeploymentType
	}
	return DeploymentType_SINGLE_AZ
}

func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) GetPrices() []*Price {
	if m != nil {
		return m.Prices
	}
	return nil
}

// The list of prices for a particular IP.
//
// TODO (roman, July 31 2018): It's unclear at the time of this writing what different kinds
// of IPs are available within a region, and whether this model is the best way to represent
// them.
//
// Also, the cost probes currently (July 31 2018) use the same name for all IP Addresses,
// meaning there will only be one IpPriceList per region if we dedupe based on name alone.
//
// However, in AWS there are different IP Address entries within a region. These have different
// group types - charges for IP remaps, charges for IPs attached to a running instance,
// charges for IPs NOT attached to a running instance - represented by different product SKU's.
// Right now the IP Price List is not flexible enough to express all of those options.
type IpPriceList struct {
	// The list of IP prices.
	IpPrice              []*IpPriceList_IpConfigPrice `protobuf:"bytes,1,rep,name=ip_price,json=ipPrice" json:"ip_price,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *IpPriceList) Reset()         { *m = IpPriceList{} }
func (m *IpPriceList) String() string { return proto.CompactTextString(m) }
func (*IpPriceList) ProtoMessage()    {}
func (*IpPriceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{2}
}

func (m *IpPriceList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IpPriceList.Unmarshal(m, b)
}
func (m *IpPriceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IpPriceList.Marshal(b, m, deterministic)
}
func (m *IpPriceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpPriceList.Merge(m, src)
}
func (m *IpPriceList) XXX_Size() int {
	return xxx_messageInfo_IpPriceList.Size(m)
}
func (m *IpPriceList) XXX_DiscardUnknown() {
	xxx_messageInfo_IpPriceList.DiscardUnknown(m)
}

var xxx_messageInfo_IpPriceList proto.InternalMessageInfo

func (m *IpPriceList) GetIpPrice() []*IpPriceList_IpConfigPrice {
	if m != nil {
		return m.IpPrice
	}
	return nil
}

// The price for a particular IP configuration.
type IpPriceList_IpConfigPrice struct {
	// The number of IPs you get for free for an instance.
	// This seems to only be relevant in AWS.
	FreeIpCount *int32 `protobuf:"varint,2,opt,name=free_ip_count,json=freeIpCount" json:"free_ip_count,omitempty"`
	// The prices available for this IP Price. There may be different prices (e.g. an hourly
	// price and a monthly price).
	Prices []*Price `protobuf:"bytes,10,rep,name=prices" json:"prices,omitempty"`
	// Type is used to know if it's a static/ non static.
	Type                 *string  `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IpPriceList_IpConfigPrice) Reset()         { *m = IpPriceList_IpConfigPrice{} }
func (m *IpPriceList_IpConfigPrice) String() string { return proto.CompactTextString(m) }
func (*IpPriceList_IpConfigPrice) ProtoMessage()    {}
func (*IpPriceList_IpConfigPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{2, 0}
}

func (m *IpPriceList_IpConfigPrice) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IpPriceList_IpConfigPrice.Unmarshal(m, b)
}
func (m *IpPriceList_IpConfigPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IpPriceList_IpConfigPrice.Marshal(b, m, deterministic)
}
func (m *IpPriceList_IpConfigPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpPriceList_IpConfigPrice.Merge(m, src)
}
func (m *IpPriceList_IpConfigPrice) XXX_Size() int {
	return xxx_messageInfo_IpPriceList_IpConfigPrice.Size(m)
}
func (m *IpPriceList_IpConfigPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_IpPriceList_IpConfigPrice.DiscardUnknown(m)
}

var xxx_messageInfo_IpPriceList_IpConfigPrice proto.InternalMessageInfo

func (m *IpPriceList_IpConfigPrice) GetFreeIpCount() int32 {
	if m != nil && m.FreeIpCount != nil {
		return *m.FreeIpCount
	}
	return 0
}

func (m *IpPriceList_IpConfigPrice) GetPrices() []*Price {
	if m != nil {
		return m.Prices
	}
	return nil
}

func (m *IpPriceList_IpConfigPrice) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

// The list of storage prices for a particular cloud storage tier.
type StorageTierPriceList struct {
	// The list of prices.
	//
	// Note: Right now this could be replaced by "repeated Price", but using an extra
	// wrapper is more consistent with the other price lists, and more easily extensible
	// later down the road.
	CloudStoragePrice    []*StorageTierPriceList_StorageTierPrice `protobuf:"bytes,1,rep,name=cloud_storage_price,json=cloudStoragePrice" json:"cloud_storage_price,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *StorageTierPriceList) Reset()         { *m = StorageTierPriceList{} }
func (m *StorageTierPriceList) String() string { return proto.CompactTextString(m) }
func (*StorageTierPriceList) ProtoMessage()    {}
func (*StorageTierPriceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{3}
}

func (m *StorageTierPriceList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageTierPriceList.Unmarshal(m, b)
}
func (m *StorageTierPriceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageTierPriceList.Marshal(b, m, deterministic)
}
func (m *StorageTierPriceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageTierPriceList.Merge(m, src)
}
func (m *StorageTierPriceList) XXX_Size() int {
	return xxx_messageInfo_StorageTierPriceList.Size(m)
}
func (m *StorageTierPriceList) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageTierPriceList.DiscardUnknown(m)
}

var xxx_messageInfo_StorageTierPriceList proto.InternalMessageInfo

func (m *StorageTierPriceList) GetCloudStoragePrice() []*StorageTierPriceList_StorageTierPrice {
	if m != nil {
		return m.CloudStoragePrice
	}
	return nil
}

type StorageTierPriceList_StorageTierPrice struct {
	Prices []*Price `protobuf:"bytes,10,rep,name=prices" json:"prices,omitempty"`
	// The redundancy type for which the prices are being represented.
	RedundancyType       *EntityDTO_VirtualVolumeData_RedundancyType `protobuf:"varint,11,opt,name=redundancy_type,json=redundancyType,enum=common_dto.EntityDTO_VirtualVolumeData_RedundancyType" json:"redundancy_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                    `json:"-"`
	XXX_unrecognized     []byte                                      `json:"-"`
	XXX_sizecache        int32                                       `json:"-"`
}

func (m *StorageTierPriceList_StorageTierPrice) Reset()         { *m = StorageTierPriceList_StorageTierPrice{} }
func (m *StorageTierPriceList_StorageTierPrice) String() string { return proto.CompactTextString(m) }
func (*StorageTierPriceList_StorageTierPrice) ProtoMessage()    {}
func (*StorageTierPriceList_StorageTierPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{3, 0}
}

func (m *StorageTierPriceList_StorageTierPrice) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageTierPriceList_StorageTierPrice.Unmarshal(m, b)
}
func (m *StorageTierPriceList_StorageTierPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageTierPriceList_StorageTierPrice.Marshal(b, m, deterministic)
}
func (m *StorageTierPriceList_StorageTierPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageTierPriceList_StorageTierPrice.Merge(m, src)
}
func (m *StorageTierPriceList_StorageTierPrice) XXX_Size() int {
	return xxx_messageInfo_StorageTierPriceList_StorageTierPrice.Size(m)
}
func (m *StorageTierPriceList_StorageTierPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageTierPriceList_StorageTierPrice.DiscardUnknown(m)
}

var xxx_messageInfo_StorageTierPriceList_StorageTierPrice proto.InternalMessageInfo

func (m *StorageTierPriceList_StorageTierPrice) GetPrices() []*Price {
	if m != nil {
		return m.Prices
	}
	return nil
}

func (m *StorageTierPriceList_StorageTierPrice) GetRedundancyType() EntityDTO_VirtualVolumeData_RedundancyType {
	if m != nil && m.RedundancyType != nil {
		return *m.RedundancyType
	}
	return EntityDTO_VirtualVolumeData_LRS
}

// The pricing for reserved instances.
//
// Reserved instances are basically discounted on-demand instances with
// an upfront cost and a term. So instead of paying on-demand, you buy
// "in bulk".
//
// Note: AWS and Azure have reserved instance, and Google has a similar
// concept called "Committed Use Discounts".
type ReservedInstancePrice struct {
	// The total upfront price. May not be set if the payment option for the reserved
	// instance is NO_UPFRONT.
	//
	// TODO (roman, July 31 2019): This may need to be a list, to allow
	// different pricing options. For example, a different hourly vs monthly price.
	UpfrontPrice *Price `protobuf:"bytes,10,opt,name=upfront_price,json=upfrontPrice" json:"upfront_price,omitempty"`
	// The recurring price. This is the amount you have to pay regularly for the instance.
	//
	// TODO (roman, July 31 2019): This may need to be a list, to allow
	// different pricing options. For example, a different hourly vs monthly price.
	RecurringPrice *Price `protobuf:"bytes,11,opt,name=recurring_price,json=recurringPrice" json:"recurring_price,omitempty"`
	// This captures other costs for using the instance - for example, license costs.
	// May not be set, depending on the instance configuration (e.g. a Linux instance
	// will have no license costs).
	//
	// TODO (roman, July 31 2019): This may need to be a list, to allow
	// different pricing options. For example, a different hourly vs monthly price.
	UsagePrice           *Price   `protobuf:"bytes,12,opt,name=usage_price,json=usagePrice" json:"usage_price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReservedInstancePrice) Reset()         { *m = ReservedInstancePrice{} }
func (m *ReservedInstancePrice) String() string { return proto.CompactTextString(m) }
func (*ReservedInstancePrice) ProtoMessage()    {}
func (*ReservedInstancePrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{4}
}

func (m *ReservedInstancePrice) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReservedInstancePrice.Unmarshal(m, b)
}
func (m *ReservedInstancePrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReservedInstancePrice.Marshal(b, m, deterministic)
}
func (m *ReservedInstancePrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReservedInstancePrice.Merge(m, src)
}
func (m *ReservedInstancePrice) XXX_Size() int {
	return xxx_messageInfo_ReservedInstancePrice.Size(m)
}
func (m *ReservedInstancePrice) XXX_DiscardUnknown() {
	xxx_messageInfo_ReservedInstancePrice.DiscardUnknown(m)
}

var xxx_messageInfo_ReservedInstancePrice proto.InternalMessageInfo

func (m *ReservedInstancePrice) GetUpfrontPrice() *Price {
	if m != nil {
		return m.UpfrontPrice
	}
	return nil
}

func (m *ReservedInstancePrice) GetRecurringPrice() *Price {
	if m != nil {
		return m.RecurringPrice
	}
	return nil
}

func (m *ReservedInstancePrice) GetUsagePrice() *Price {
	if m != nil {
		return m.UsagePrice
	}
	return nil
}

// The price of a particular instance or cloud entity.
type Price struct {
	// The unit in which the price is measured.
	// Not all units are valid for all types of cloud entities.
	Unit *Price_Unit `protobuf:"varint,1,opt,name=unit,enum=common_dto.Price_Unit" json:"unit,omitempty"`
	// The end range - in units. If not set, assume "infinite".
	// For example, if the price is $0 for the first 10 X, and $10 for the next 10 X, then
	// there should be two Prices, with an end_range of 10 for the first one, and
	// an end_range of 20 for the second. The end is inclusive.
	EndRangeInUnits *int64 `protobuf:"varint,6,opt,name=end_range_in_units,json=endRangeInUnits" json:"end_range_in_units,omitempty"`
	// This field defines increments allowed till the end_range_in_units is reached.
	// eg: if end_range_in_units = 500 and incrementInterval = 100, the allowed sizes are 100, 200, 300, 400, 500;
	IncrementInterval    *int64          `protobuf:"varint,7,opt,name=increment_interval,json=incrementInterval" json:"increment_interval,omitempty"`
	PriceAmount          *CurrencyAmount `protobuf:"bytes,22,opt,name=price_amount,json=priceAmount" json:"price_amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Price) Reset()         { *m = Price{} }
func (m *Price) String() string { return proto.CompactTextString(m) }
func (*Price) ProtoMessage()    {}
func (*Price) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{5}
}

func (m *Price) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Price.Unmarshal(m, b)
}
func (m *Price) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Price.Marshal(b, m, deterministic)
}
func (m *Price) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Price.Merge(m, src)
}
func (m *Price) XXX_Size() int {
	return xxx_messageInfo_Price.Size(m)
}
func (m *Price) XXX_DiscardUnknown() {
	xxx_messageInfo_Price.DiscardUnknown(m)
}

var xxx_messageInfo_Price proto.InternalMessageInfo

func (m *Price) GetUnit() Price_Unit {
	if m != nil && m.Unit != nil {
		return *m.Unit
	}
	return Price_HOURS
}

func (m *Price) GetEndRangeInUnits() int64 {
	if m != nil && m.EndRangeInUnits != nil {
		return *m.EndRangeInUnits
	}
	return 0
}

func (m *Price) GetIncrementInterval() int64 {
	if m != nil && m.IncrementInterval != nil {
		return *m.IncrementInterval
	}
	return 0
}

func (m *Price) GetPriceAmount() *CurrencyAmount {
	if m != nil {
		return m.PriceAmount
	}
	return nil
}

// The prices for license related to a specific operating system
type LicensePriceEntry struct {
	// / The operating system which the license is associated with
	OsType *OSType `protobuf:"varint,1,opt,name=os_type,json=osType,enum=common_dto.OSType" json:"os_type,omitempty"`
	// The list of prices associated with licensing a particular Operating System.
	// Not all cloud providers have license price lists. In particular, Azure does and AWS doesn't.
	// In Azure, license is priced by the number of cores the vm it applies to is using.
	LicensePrices []*LicensePriceEntry_LicensePrice `protobuf:"bytes,2,rep,name=license_prices,json=licensePrices" json:"license_prices,omitempty"`
	// To distinguish burstable and non-burstable license rates.
	BurstableCPU         *bool    `protobuf:"varint,3,opt,name=burstableCPU" json:"burstableCPU,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LicensePriceEntry) Reset()         { *m = LicensePriceEntry{} }
func (m *LicensePriceEntry) String() string { return proto.CompactTextString(m) }
func (*LicensePriceEntry) ProtoMessage()    {}
func (*LicensePriceEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{6}
}

func (m *LicensePriceEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LicensePriceEntry.Unmarshal(m, b)
}
func (m *LicensePriceEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LicensePriceEntry.Marshal(b, m, deterministic)
}
func (m *LicensePriceEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LicensePriceEntry.Merge(m, src)
}
func (m *LicensePriceEntry) XXX_Size() int {
	return xxx_messageInfo_LicensePriceEntry.Size(m)
}
func (m *LicensePriceEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LicensePriceEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LicensePriceEntry proto.InternalMessageInfo

func (m *LicensePriceEntry) GetOsType() OSType {
	if m != nil && m.OsType != nil {
		return *m.OsType
	}
	return OSType_UNKNOWN_OS
}

func (m *LicensePriceEntry) GetLicensePrices() []*LicensePriceEntry_LicensePrice {
	if m != nil {
		return m.LicensePrices
	}
	return nil
}

func (m *LicensePriceEntry) GetBurstableCPU() bool {
	if m != nil && m.BurstableCPU != nil {
		return *m.BurstableCPU
	}
	return false
}

type LicensePriceEntry_LicensePrice struct {
	// This is the upper bound of the number of cores this price applies to. E.g. if there are
	// three license prices with pricing for 1-2 cores, 3-4 cores, and 5+ cores, there
	// will be entries with number_of_cores = 2, 4, and MAX_INTEGER.
	NumberOfCores *int32 `protobuf:"varint,1,opt,name=number_of_cores,json=numberOfCores" json:"number_of_cores,omitempty"`
	// The price associated with the number of core and the OS
	Price                *Price   `protobuf:"bytes,10,opt,name=price" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LicensePriceEntry_LicensePrice) Reset()         { *m = LicensePriceEntry_LicensePrice{} }
func (m *LicensePriceEntry_LicensePrice) String() string { return proto.CompactTextString(m) }
func (*LicensePriceEntry_LicensePrice) ProtoMessage()    {}
func (*LicensePriceEntry_LicensePrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{6, 0}
}

func (m *LicensePriceEntry_LicensePrice) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LicensePriceEntry_LicensePrice.Unmarshal(m, b)
}
func (m *LicensePriceEntry_LicensePrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LicensePriceEntry_LicensePrice.Marshal(b, m, deterministic)
}
func (m *LicensePriceEntry_LicensePrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LicensePriceEntry_LicensePrice.Merge(m, src)
}
func (m *LicensePriceEntry_LicensePrice) XXX_Size() int {
	return xxx_messageInfo_LicensePriceEntry_LicensePrice.Size(m)
}
func (m *LicensePriceEntry_LicensePrice) XXX_DiscardUnknown() {
	xxx_messageInfo_LicensePriceEntry_LicensePrice.DiscardUnknown(m)
}

var xxx_messageInfo_LicensePriceEntry_LicensePrice proto.InternalMessageInfo

func (m *LicensePriceEntry_LicensePrice) GetNumberOfCores() int32 {
	if m != nil && m.NumberOfCores != nil {
		return *m.NumberOfCores
	}
	return 0
}

func (m *LicensePriceEntry_LicensePrice) GetPrice() *Price {
	if m != nil {
		return m.Price
	}
	return nil
}

// The price table object contains the pricing information related to a specific cloud provider.
// The cloud provider has pricing for different products and offerings. This means that price for
// different services on the same cloud provider will be all merged together in this object (EC2,
// RDS, ..)
type PriceTable struct {
	// The version of the price table retrieved from the cloud provider.
	// The version can come directly from the cloud provider itself (AWS has a version in its own
	// pricing, like: "version" : "20180809215656")
	// If the cloud provider is not providing a version directly, then the probe needs to generate one
	// on its own.
	// This field will be used by the server side to understand if the price table sent from probe
	// to server is the same one that the server already has. If the version that the server is
	// receiving is the same one that he already processed before, he is free to discard the data.
	Version *string `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	// Information used to uniquely associate this price table with a business account.
	PriceTableKeys []*PricingIdentifier `protobuf:"bytes,8,rep,name=price_table_keys,json=priceTableKeys" json:"price_table_keys,omitempty"`
	// Price table for on-demand instances. this is the "default" pay-per-use option for all cloud
	// providers.
	OnDemandPriceTable []*PriceTable_OnDemandPriceTableByRegionEntry `protobuf:"bytes,2,rep,name=on_demand_price_table,json=onDemandPriceTable" json:"on_demand_price_table,omitempty"`
	SpotPriceTable     []*PriceTable_SpotPriceByRegionEntry          `protobuf:"bytes,4,rep,name=spot_price_table,json=spotPriceTable" json:"spot_price_table,omitempty"`
	// RI price table
	ReservedInstancePriceTable []*PriceTable_ReservedInstancePriceTableByRegionEntry `protobuf:"bytes,5,rep,name=reserved_instance_price_table,json=reservedInstancePriceTable" json:"reserved_instance_price_table,omitempty"`
	// On-Demand License price table by Os type. A table entry represents the list of prices associated
	// with licensing a particular Operating System.
	OnDemandLicensePriceTable []*LicensePriceEntry `protobuf:"bytes,6,rep,name=on_demand_license_price_table,json=onDemandLicensePriceTable" json:"on_demand_license_price_table,omitempty"`
	// Reserved License price table by OS type
	ReservedLicensePriceTable []*LicensePriceEntry `protobuf:"bytes,7,rep,name=reserved_license_price_table,json=reservedLicensePriceTable" json:"reserved_license_price_table,omitempty"`
	// The service provider id of the pricing info.
	ServiceProviderId    *string  `protobuf:"bytes,9,opt,name=serviceProviderId" json:"serviceProviderId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PriceTable) Reset()         { *m = PriceTable{} }
func (m *PriceTable) String() string { return proto.CompactTextString(m) }
func (*PriceTable) ProtoMessage()    {}
func (*PriceTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{7}
}

func (m *PriceTable) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PriceTable.Unmarshal(m, b)
}
func (m *PriceTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PriceTable.Marshal(b, m, deterministic)
}
func (m *PriceTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceTable.Merge(m, src)
}
func (m *PriceTable) XXX_Size() int {
	return xxx_messageInfo_PriceTable.Size(m)
}
func (m *PriceTable) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceTable.DiscardUnknown(m)
}

var xxx_messageInfo_PriceTable proto.InternalMessageInfo

func (m *PriceTable) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *PriceTable) GetPriceTableKeys() []*PricingIdentifier {
	if m != nil {
		return m.PriceTableKeys
	}
	return nil
}

func (m *PriceTable) GetOnDemandPriceTable() []*PriceTable_OnDemandPriceTableByRegionEntry {
	if m != nil {
		return m.OnDemandPriceTable
	}
	return nil
}

func (m *PriceTable) GetSpotPriceTable() []*PriceTable_SpotPriceByRegionEntry {
	if m != nil {
		return m.SpotPriceTable
	}
	return nil
}

func (m *PriceTable) GetReservedInstancePriceTable() []*PriceTable_ReservedInstancePriceTableByRegionEntry {
	if m != nil {
		return m.ReservedInstancePriceTable
	}
	return nil
}

func (m *PriceTable) GetOnDemandLicensePriceTable() []*LicensePriceEntry {
	if m != nil {
		return m.OnDemandLicensePriceTable
	}
	return nil
}

func (m *PriceTable) GetReservedLicensePriceTable() []*LicensePriceEntry {
	if m != nil {
		return m.ReservedLicensePriceTable
	}
	return nil
}

func (m *PriceTable) GetServiceProviderId() string {
	if m != nil && m.ServiceProviderId != nil {
		return *m.ServiceProviderId
	}
	return ""
}

// Spot prices for availability zones in this region
type PriceTable_SpotPriceByRegionEntry struct {
	// Region
	RelatedRegion *EntityDTO `protobuf:"bytes,1,opt,name=related_region,json=relatedRegion" json:"related_region,omitempty"`
	// Availability Zone
	RelatedZone *EntityDTO `protobuf:"bytes,2,opt,name=related_zone,json=relatedZone" json:"related_zone,omitempty"`
	// What Compute Tier
	RelatedComputeTier *EntityDTO `protobuf:"bytes,3,opt,name=related_compute_tier,json=relatedComputeTier" json:"related_compute_tier,omitempty"`
	GuestOsType        *OSType    `protobuf:"varint,4,opt,name=guest_os_type,json=guestOsType,enum=common_dto.OSType" json:"guest_os_type,omitempty"`
	// Spot Price For most recent period
	Price                *Price   `protobuf:"bytes,10,opt,name=price" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PriceTable_SpotPriceByRegionEntry) Reset()         { *m = PriceTable_SpotPriceByRegionEntry{} }
func (m *PriceTable_SpotPriceByRegionEntry) String() string { return proto.CompactTextString(m) }
func (*PriceTable_SpotPriceByRegionEntry) ProtoMessage()    {}
func (*PriceTable_SpotPriceByRegionEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{7, 0}
}

func (m *PriceTable_SpotPriceByRegionEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PriceTable_SpotPriceByRegionEntry.Unmarshal(m, b)
}
func (m *PriceTable_SpotPriceByRegionEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PriceTable_SpotPriceByRegionEntry.Marshal(b, m, deterministic)
}
func (m *PriceTable_SpotPriceByRegionEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceTable_SpotPriceByRegionEntry.Merge(m, src)
}
func (m *PriceTable_SpotPriceByRegionEntry) XXX_Size() int {
	return xxx_messageInfo_PriceTable_SpotPriceByRegionEntry.Size(m)
}
func (m *PriceTable_SpotPriceByRegionEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceTable_SpotPriceByRegionEntry.DiscardUnknown(m)
}

var xxx_messageInfo_PriceTable_SpotPriceByRegionEntry proto.InternalMessageInfo

func (m *PriceTable_SpotPriceByRegionEntry) GetRelatedRegion() *EntityDTO {
	if m != nil {
		return m.RelatedRegion
	}
	return nil
}

func (m *PriceTable_SpotPriceByRegionEntry) GetRelatedZone() *EntityDTO {
	if m != nil {
		return m.RelatedZone
	}
	return nil
}

func (m *PriceTable_SpotPriceByRegionEntry) GetRelatedComputeTier() *EntityDTO {
	if m != nil {
		return m.RelatedComputeTier
	}
	return nil
}

func (m *PriceTable_SpotPriceByRegionEntry) GetGuestOsType() OSType {
	if m != nil && m.GuestOsType != nil {
		return *m.GuestOsType
	}
	return OSType_UNKNOWN_OS
}

func (m *PriceTable_SpotPriceByRegionEntry) GetPrice() *Price {
	if m != nil {
		return m.Price
	}
	return nil
}

// The on-demand prices in a specific region.
type PriceTable_OnDemandPriceTableByRegionEntry struct {
	// Cloud Region for which those prices are relevant.
	RelatedRegion *EntityDTO `protobuf:"bytes,1,opt,name=related_region,json=relatedRegion" json:"related_region,omitempty"`
	// The prices for compute tiers in this region
	ComputePriceTable []*PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry `protobuf:"bytes,2,rep,name=compute_price_table,json=computePriceTable" json:"compute_price_table,omitempty"`
	// The prices for database tiers in this region
	DatabasePriceTable []*PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry `protobuf:"bytes,3,rep,name=database_price_table,json=databasePriceTable" json:"database_price_table,omitempty"`
	// The prices for cloud storage tiers in this region
	StoragePriceTable []*PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry `protobuf:"bytes,4,rep,name=storage_price_table,json=storagePriceTable" json:"storage_price_table,omitempty"`
	// The prices for IP addresses in this region
	IpPrices             *IpPriceList `protobuf:"bytes,5,opt,name=ip_prices,json=ipPrices" json:"ip_prices,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry) Reset() {
	*m = PriceTable_OnDemandPriceTableByRegionEntry{}
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry) String() string {
	return proto.CompactTextString(m)
}
func (*PriceTable_OnDemandPriceTableByRegionEntry) ProtoMessage() {}
func (*PriceTable_OnDemandPriceTableByRegionEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{7, 1}
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry.Unmarshal(m, b)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry.Marshal(b, m, deterministic)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry.Merge(m, src)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry) XXX_Size() int {
	return xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry.Size(m)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry.DiscardUnknown(m)
}

var xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry proto.InternalMessageInfo

func (m *PriceTable_OnDemandPriceTableByRegionEntry) GetRelatedRegion() *EntityDTO {
	if m != nil {
		return m.RelatedRegion
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry) GetComputePriceTable() []*PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry {
	if m != nil {
		return m.ComputePriceTable
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry) GetDatabasePriceTable() []*PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry {
	if m != nil {
		return m.DatabasePriceTable
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry) GetStoragePriceTable() []*PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry {
	if m != nil {
		return m.StoragePriceTable
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry) GetIpPrices() *IpPriceList {
	if m != nil {
		return m.IpPrices
	}
	return nil
}

// The prices for compute related to a specific compute tier
type PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry struct {
	// Compute tier for which those prices are relevant.
	RelatedComputeTier   *EntityDTO            `protobuf:"bytes,1,opt,name=related_compute_tier,json=relatedComputeTier" json:"related_compute_tier,omitempty"`
	ComputeTierPriceList *ComputeTierPriceList `protobuf:"bytes,2,opt,name=compute_tier_price_list,json=computeTierPriceList" json:"compute_tier_price_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) Reset() {
	*m = PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry{}
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) String() string {
	return proto.CompactTextString(m)
}
func (*PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) ProtoMessage() {}
func (*PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{7, 1, 0}
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry.Unmarshal(m, b)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry.Marshal(b, m, deterministic)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry.Merge(m, src)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) XXX_Size() int {
	return xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry.Size(m)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry.DiscardUnknown(m)
}

var xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry proto.InternalMessageInfo

func (m *PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) GetRelatedComputeTier() *EntityDTO {
	if m != nil {
		return m.RelatedComputeTier
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) GetComputeTierPriceList() *ComputeTierPriceList {
	if m != nil {
		return m.ComputeTierPriceList
	}
	return nil
}

// The prices for database related to a specific database tier
type PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry struct {
	// Database tier for which those prices are relevant.
	RelatedDatabaseTier   *EntityDTO               `protobuf:"bytes,1,opt,name=related_database_tier,json=relatedDatabaseTier" json:"related_database_tier,omitempty"`
	DatabaseTierPriceList []*DatabaseTierPriceList `protobuf:"bytes,2,rep,name=database_tier_price_list,json=databaseTierPriceList" json:"database_tier_price_list,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                 `json:"-"`
	XXX_unrecognized      []byte                   `json:"-"`
	XXX_sizecache         int32                    `json:"-"`
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) Reset() {
	*m = PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry{}
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) String() string {
	return proto.CompactTextString(m)
}
func (*PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) ProtoMessage() {}
func (*PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{7, 1, 1}
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry.Unmarshal(m, b)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry.Marshal(b, m, deterministic)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry.Merge(m, src)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) XXX_Size() int {
	return xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry.Size(m)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry.DiscardUnknown(m)
}

var xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry proto.InternalMessageInfo

func (m *PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) GetRelatedDatabaseTier() *EntityDTO {
	if m != nil {
		return m.RelatedDatabaseTier
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) GetDatabaseTierPriceList() []*DatabaseTierPriceList {
	if m != nil {
		return m.DatabaseTierPriceList
	}
	return nil
}

// The prices for storage related to a specific storage tier
type PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry struct {
	// Storage tier for which those prices are relevant.
	RelatedStorageTier   *EntityDTO            `protobuf:"bytes,1,opt,name=related_storage_tier,json=relatedStorageTier" json:"related_storage_tier,omitempty"`
	StorageTierPriceList *StorageTierPriceList `protobuf:"bytes,2,opt,name=storage_tier_price_list,json=storageTierPriceList" json:"storage_tier_price_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) Reset() {
	*m = PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry{}
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) String() string {
	return proto.CompactTextString(m)
}
func (*PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) ProtoMessage() {}
func (*PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{7, 1, 2}
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry.Unmarshal(m, b)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry.Marshal(b, m, deterministic)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry.Merge(m, src)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) XXX_Size() int {
	return xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry.Size(m)
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry.DiscardUnknown(m)
}

var xxx_messageInfo_PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry proto.InternalMessageInfo

func (m *PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) GetRelatedStorageTier() *EntityDTO {
	if m != nil {
		return m.RelatedStorageTier
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) GetStorageTierPriceList() *StorageTierPriceList {
	if m != nil {
		return m.StorageTierPriceList
	}
	return nil
}

// The reserved instance prices in a specific region.
type PriceTable_ReservedInstancePriceTableByRegionEntry struct {
	// Cloud Region for which those prices are relevant.
	RelatedRegion *EntityDTO `protobuf:"bytes,1,opt,name=related_region,json=relatedRegion" json:"related_region,omitempty"`
	// This map contains the RI specs in this region, with its price associated.
	// The RI spec should be considered as a key in a map, so each spec should only be present once
	// in this whole map.
	ReservedInstancePriceMap []*PriceTable_ReservedInstancePriceEntry `protobuf:"bytes,2,rep,name=reserved_instance_price_map,json=reservedInstancePriceMap" json:"reserved_instance_price_map,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}                                 `json:"-"`
	XXX_unrecognized         []byte                                   `json:"-"`
	XXX_sizecache            int32                                    `json:"-"`
}

func (m *PriceTable_ReservedInstancePriceTableByRegionEntry) Reset() {
	*m = PriceTable_ReservedInstancePriceTableByRegionEntry{}
}
func (m *PriceTable_ReservedInstancePriceTableByRegionEntry) String() string {
	return proto.CompactTextString(m)
}
func (*PriceTable_ReservedInstancePriceTableByRegionEntry) ProtoMessage() {}
func (*PriceTable_ReservedInstancePriceTableByRegionEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{7, 2}
}

func (m *PriceTable_ReservedInstancePriceTableByRegionEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PriceTable_ReservedInstancePriceTableByRegionEntry.Unmarshal(m, b)
}
func (m *PriceTable_ReservedInstancePriceTableByRegionEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PriceTable_ReservedInstancePriceTableByRegionEntry.Marshal(b, m, deterministic)
}
func (m *PriceTable_ReservedInstancePriceTableByRegionEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceTable_ReservedInstancePriceTableByRegionEntry.Merge(m, src)
}
func (m *PriceTable_ReservedInstancePriceTableByRegionEntry) XXX_Size() int {
	return xxx_messageInfo_PriceTable_ReservedInstancePriceTableByRegionEntry.Size(m)
}
func (m *PriceTable_ReservedInstancePriceTableByRegionEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceTable_ReservedInstancePriceTableByRegionEntry.DiscardUnknown(m)
}

var xxx_messageInfo_PriceTable_ReservedInstancePriceTableByRegionEntry proto.InternalMessageInfo

func (m *PriceTable_ReservedInstancePriceTableByRegionEntry) GetRelatedRegion() *EntityDTO {
	if m != nil {
		return m.RelatedRegion
	}
	return nil
}

func (m *PriceTable_ReservedInstancePriceTableByRegionEntry) GetReservedInstancePriceMap() []*PriceTable_ReservedInstancePriceEntry {
	if m != nil {
		return m.ReservedInstancePriceMap
	}
	return nil
}

// This entry contains an RISpec with the associated price.
type PriceTable_ReservedInstancePriceEntry struct {
	// the RI spec associated with the price
	ReservedInstanceSpec *ReservedInstanceSpec `protobuf:"bytes,1,opt,name=reserved_instance_spec,json=reservedInstanceSpec" json:"reserved_instance_spec,omitempty"`
	// the price of the RI spec
	ReservedInstancePrice *ReservedInstancePrice `protobuf:"bytes,2,opt,name=reserved_instance_price,json=reservedInstancePrice" json:"reserved_instance_price,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}               `json:"-"`
	XXX_unrecognized      []byte                 `json:"-"`
	XXX_sizecache         int32                  `json:"-"`
}

func (m *PriceTable_ReservedInstancePriceEntry) Reset()         { *m = PriceTable_ReservedInstancePriceEntry{} }
func (m *PriceTable_ReservedInstancePriceEntry) String() string { return proto.CompactTextString(m) }
func (*PriceTable_ReservedInstancePriceEntry) ProtoMessage()    {}
func (*PriceTable_ReservedInstancePriceEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8ca90a31766eb8f, []int{7, 3}
}

func (m *PriceTable_ReservedInstancePriceEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PriceTable_ReservedInstancePriceEntry.Unmarshal(m, b)
}
func (m *PriceTable_ReservedInstancePriceEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PriceTable_ReservedInstancePriceEntry.Marshal(b, m, deterministic)
}
func (m *PriceTable_ReservedInstancePriceEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceTable_ReservedInstancePriceEntry.Merge(m, src)
}
func (m *PriceTable_ReservedInstancePriceEntry) XXX_Size() int {
	return xxx_messageInfo_PriceTable_ReservedInstancePriceEntry.Size(m)
}
func (m *PriceTable_ReservedInstancePriceEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceTable_ReservedInstancePriceEntry.DiscardUnknown(m)
}

var xxx_messageInfo_PriceTable_ReservedInstancePriceEntry proto.InternalMessageInfo

func (m *PriceTable_ReservedInstancePriceEntry) GetReservedInstanceSpec() *ReservedInstanceSpec {
	if m != nil {
		return m.ReservedInstanceSpec
	}
	return nil
}

func (m *PriceTable_ReservedInstancePriceEntry) GetReservedInstancePrice() *ReservedInstancePrice {
	if m != nil {
		return m.ReservedInstancePrice
	}
	return nil
}

func init() {
	proto.RegisterEnum("common_dto.Price_Unit", Price_Unit_name, Price_Unit_value)
	proto.RegisterType((*ComputeTierPriceList)(nil), "common_dto.ComputeTierPriceList")
	proto.RegisterType((*ComputeTierPriceList_ComputeTierConfigPrice)(nil), "common_dto.ComputeTierPriceList.ComputeTierConfigPrice")
	proto.RegisterType((*DatabaseTierPriceList)(nil), "common_dto.DatabaseTierPriceList")
	proto.RegisterType((*DatabaseTierPriceList_DatabaseTierConfigPrice)(nil), "common_dto.DatabaseTierPriceList.DatabaseTierConfigPrice")
	proto.RegisterType((*IpPriceList)(nil), "common_dto.IpPriceList")
	proto.RegisterType((*IpPriceList_IpConfigPrice)(nil), "common_dto.IpPriceList.IpConfigPrice")
	proto.RegisterType((*StorageTierPriceList)(nil), "common_dto.StorageTierPriceList")
	proto.RegisterType((*StorageTierPriceList_StorageTierPrice)(nil), "common_dto.StorageTierPriceList.StorageTierPrice")
	proto.RegisterType((*ReservedInstancePrice)(nil), "common_dto.ReservedInstancePrice")
	proto.RegisterType((*Price)(nil), "common_dto.Price")
	proto.RegisterType((*LicensePriceEntry)(nil), "common_dto.LicensePriceEntry")
	proto.RegisterType((*LicensePriceEntry_LicensePrice)(nil), "common_dto.LicensePriceEntry.LicensePrice")
	proto.RegisterType((*PriceTable)(nil), "common_dto.PriceTable")
	proto.RegisterType((*PriceTable_SpotPriceByRegionEntry)(nil), "common_dto.PriceTable.SpotPriceByRegionEntry")
	proto.RegisterType((*PriceTable_OnDemandPriceTableByRegionEntry)(nil), "common_dto.PriceTable.OnDemandPriceTableByRegionEntry")
	proto.RegisterType((*PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry)(nil), "common_dto.PriceTable.OnDemandPriceTableByRegionEntry.ComputePriceTableByTierEntry")
	proto.RegisterType((*PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry)(nil), "common_dto.PriceTable.OnDemandPriceTableByRegionEntry.DatabasePriceTableByTierEntry")
	proto.RegisterType((*PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry)(nil), "common_dto.PriceTable.OnDemandPriceTableByRegionEntry.StoragePriceTableByTierEntry")
	proto.RegisterType((*PriceTable_ReservedInstancePriceTableByRegionEntry)(nil), "common_dto.PriceTable.ReservedInstancePriceTableByRegionEntry")
	proto.RegisterType((*PriceTable_ReservedInstancePriceEntry)(nil), "common_dto.PriceTable.ReservedInstancePriceEntry")
}

func init() { proto.RegisterFile("PricingDTO.proto", fileDescriptor_c8ca90a31766eb8f) }

var fileDescriptor_c8ca90a31766eb8f = []byte{
	// 1603 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xcd, 0x6f, 0x23, 0x49,
	0x15, 0x57, 0x3b, 0x71, 0xe2, 0x3c, 0x3b, 0x8e, 0x53, 0xb1, 0x13, 0xd3, 0xbb, 0xd1, 0x64, 0x8d,
	0x60, 0x97, 0xdd, 0x8d, 0x47, 0x3b, 0x42, 0xb3, 0xb0, 0x5a, 0x10, 0x89, 0x33, 0x9a, 0xb1, 0x48,
	0xd6, 0xa1, 0xed, 0xc9, 0xb2, 0x73, 0xa0, 0xd5, 0xee, 0xae, 0x98, 0x22, 0x76, 0x55, 0xab, 0xaa,
	0x3b, 0x92, 0xb9, 0x8d, 0x90, 0xb8, 0x71, 0x47, 0x1c, 0x38, 0x71, 0xe2, 0xc6, 0x95, 0x0b, 0x08,
	0x24, 0x38, 0x72, 0xe6, 0x4f, 0xe1, 0x86, 0xea, 0xa3, 0x9d, 0xee, 0xb8, 0x1d, 0x27, 0x93, 0x5b,
	0xd5, 0x7b, 0xef, 0xf7, 0x5e, 0xbd, 0xcf, 0xaa, 0x6e, 0xa8, 0x9d, 0x73, 0xe2, 0x13, 0x3a, 0x3a,
	0x19, 0xf4, 0xda, 0x21, 0x67, 0x11, 0x43, 0xe0, 0xb3, 0xc9, 0x84, 0x51, 0x37, 0x88, 0x98, 0x8d,
	0x3a, 0x63, 0x16, 0x07, 0x1d, 0x26, 0xa2, 0x19, 0xdf, 0xde, 0xea, 0x28, 0xfe, 0x8c, 0xd0, 0xfa,
	0xd3, 0x0a, 0xd4, 0x3b, 0x6c, 0x12, 0xc6, 0x11, 0x1e, 0x10, 0xcc, 0xa5, 0x42, 0x7c, 0x4a, 0x44,
	0x84, 0x2e, 0x00, 0x86, 0x9e, 0xc0, 0x6e, 0x28, 0x29, 0x4d, 0xeb, 0xc0, 0xfa, 0xa8, 0xfc, 0xec,
	0xf3, 0xf6, 0x8d, 0xfa, 0x76, 0x1e, 0x2a, 0x4d, 0xec, 0x30, 0x7a, 0x49, 0x46, 0x8a, 0xe5, 0x6c,
	0x48, 0x55, 0x6a, 0x89, 0x7e, 0x6b, 0xc1, 0xb7, 0x43, 0xcc, 0x5d, 0x5f, 0xb1, 0x63, 0xee, 0x45,
	0x84, 0x51, 0x6d, 0xc5, 0xf5, 0x82, 0x5f, 0xc5, 0x22, 0x9a, 0x60, 0x1a, 0x89, 0x66, 0xe1, 0x60,
	0xe5, 0x31, 0x16, 0x0f, 0xc2, 0x64, 0x6f, 0x4c, 0x28, 0xf2, 0xd1, 0x8d, 0x01, 0xfb, 0xcf, 0x16,
	0xec, 0xe6, 0x83, 0xd1, 0x73, 0xd8, 0x1c, 0xc5, 0x58, 0x44, 0x2e, 0x13, 0x6e, 0x34, 0x0d, 0xb5,
	0xfb, 0xd5, 0x67, 0x28, 0x7d, 0x98, 0x5e, 0x7f, 0x30, 0x0d, 0xb1, 0x53, 0x56, 0x82, 0x3d, 0x21,
	0x37, 0xe8, 0x10, 0xd6, 0x23, 0x4c, 0x3d, 0xea, 0x4f, 0x9b, 0x05, 0x85, 0xd8, 0x49, 0x23, 0x06,
	0x9a, 0xe5, 0x24, 0x32, 0xe8, 0x7b, 0xb0, 0xa6, 0xfc, 0x16, 0x4d, 0x50, 0xce, 0x6e, 0xa7, 0xa5,
	0xb5, 0x1b, 0x46, 0xa0, 0xf5, 0x8f, 0x22, 0x34, 0x4e, 0xbc, 0xc8, 0x93, 0x71, 0xcc, 0xe6, 0xe9,
	0xe7, 0x39, 0x79, 0xfa, 0x61, 0x5a, 0x51, 0x2e, 0x2c, 0x43, 0x5d, 0x90, 0xa9, 0xb7, 0x16, 0x3c,
	0xb9, 0x5f, 0x96, 0x1e, 0x61, 0x6f, 0xdf, 0xbf, 0x2b, 0x49, 0xa8, 0x03, 0x5b, 0x01, 0x0e, 0xc7,
	0x6c, 0x2a, 0xb7, 0x3a, 0x17, 0x2b, 0x2a, 0xb2, 0x76, 0xc6, 0xe4, 0x4c, 0x44, 0xe5, 0xa4, 0x1a,
	0x64, 0xf6, 0xe8, 0x4b, 0xa8, 0x05, 0x38, 0xc4, 0x34, 0x90, 0x3a, 0x4c, 0xc4, 0x57, 0x17, 0x45,
	0x7c, 0x6b, 0x26, 0xaa, 0xf6, 0xc2, 0xfe, 0x77, 0x01, 0xf6, 0x16, 0x9c, 0x1e, 0x7d, 0x0e, 0x1b,
	0xc1, 0xd0, 0xc5, 0x74, 0x44, 0x68, 0x52, 0x24, 0x76, 0x5e, 0x2c, 0x5e, 0x28, 0x09, 0xa7, 0x14,
	0x0c, 0xf5, 0x0a, 0x7d, 0x01, 0x20, 0x81, 0x01, 0x91, 0x5e, 0x9b, 0x62, 0x79, 0x2f, 0x17, 0xa9,
	0x45, 0x9c, 0x8d, 0x60, 0x68, 0x96, 0xe8, 0x18, 0x6a, 0xc1, 0xd0, 0x1d, 0x13, 0x1f, 0x53, 0x81,
	0xdd, 0x09, 0x0b, 0xf0, 0xd8, 0x04, 0xa5, 0x99, 0xd6, 0x70, 0xaa, 0x05, 0xce, 0x24, 0xdf, 0xa9,
	0x06, 0xc3, 0xf4, 0x1e, 0xbd, 0x02, 0x14, 0x0c, 0xdd, 0xdb, 0xa1, 0x5d, 0x5d, 0x1a, 0xda, 0x5a,
	0x30, 0xcc, 0x52, 0x52, 0x45, 0x5c, 0x5f, 0x56, 0xc4, 0xff, 0xb4, 0xa0, 0xdc, 0x0d, 0x6f, 0x4a,
	0xf7, 0x27, 0x50, 0x22, 0xe1, 0xac, 0x70, 0x25, 0xf8, 0x3b, 0x69, 0x70, 0x4a, 0xb4, 0xdd, 0x0d,
	0xd3, 0x45, 0xb3, 0x4e, 0x34, 0xcb, 0xe6, 0xb0, 0x99, 0xe1, 0xa0, 0x16, 0x6c, 0x5e, 0x72, 0x8c,
	0x5d, 0x12, 0xba, 0x3e, 0x8b, 0x69, 0xa4, 0x42, 0x5b, 0x74, 0xca, 0x92, 0x28, 0x25, 0x63, 0x1a,
	0x3d, 0xa0, 0xed, 0x10, 0x82, 0xd5, 0x59, 0xff, 0x6f, 0x38, 0x6a, 0xdd, 0xfa, 0x43, 0x01, 0xea,
	0xfd, 0x88, 0x71, 0x6f, 0x74, 0xab, 0x13, 0x3d, 0xd8, 0xf1, 0xe5, 0xc4, 0x75, 0x85, 0xe6, 0x66,
	0x3c, 0xfb, 0x2c, 0x6d, 0x24, 0x0f, 0x3e, 0x47, 0x74, 0xb6, 0x95, 0x36, 0x43, 0xd6, 0xfe, 0xfe,
	0xd1, 0x82, 0xda, 0x6d, 0xb9, 0x87, 0xf8, 0xe3, 0xc2, 0x16, 0xc7, 0x41, 0x4c, 0x03, 0x39, 0x7f,
	0x74, 0xce, 0xcb, 0x2a, 0xe7, 0xcf, 0xd3, 0x98, 0x17, 0x34, 0x22, 0xd1, 0x54, 0xde, 0x11, 0x17,
	0x84, 0x47, 0xb1, 0x37, 0xbe, 0x60, 0xe3, 0x78, 0x82, 0x65, 0x49, 0xb6, 0x9d, 0x19, 0x5c, 0xb7,
	0x1a, 0xcf, 0xec, 0x5b, 0x7f, 0xb3, 0xa0, 0xe1, 0x60, 0x81, 0xf9, 0x35, 0x0e, 0xba, 0x54, 0x44,
	0x1e, 0xf5, 0xf1, 0x6c, 0xa6, 0xc6, 0xe1, 0x25, 0x67, 0x49, 0x0b, 0x36, 0x41, 0x8d, 0xaa, 0x9c,
	0xc3, 0x56, 0x8c, 0x9c, 0xc6, 0x7d, 0x21, 0x8f, 0xec, 0xc7, 0x9c, 0x13, 0x3a, 0x32, 0xc8, 0xf2,
	0x22, 0x64, 0x75, 0x26, 0xa9, 0xb1, 0xcf, 0xa0, 0x1c, 0x8b, 0x9b, 0x4c, 0x54, 0x16, 0xe1, 0x40,
	0x49, 0xa9, 0x75, 0xeb, 0x2f, 0x05, 0x28, 0x6a, 0xf4, 0xc7, 0xb0, 0x1a, 0x53, 0x12, 0x99, 0xbe,
	0xde, 0x9d, 0x83, 0xb5, 0x5f, 0x53, 0x12, 0x39, 0x4a, 0x06, 0x7d, 0x02, 0x08, 0xd3, 0xc0, 0xe5,
	0x1e, 0x1d, 0x61, 0x97, 0x50, 0x57, 0x12, 0x45, 0x73, 0xed, 0xc0, 0xfa, 0x68, 0xc5, 0xd9, 0xc2,
	0x34, 0x70, 0x24, 0xa3, 0x4b, 0x25, 0x42, 0xa0, 0x43, 0x40, 0x84, 0xfa, 0x1c, 0xab, 0xc6, 0x23,
	0x34, 0xc2, 0xfc, 0xda, 0x1b, 0x37, 0xd7, 0x95, 0xf0, 0xf6, 0x8c, 0xd3, 0x35, 0x0c, 0xf4, 0x23,
	0xa8, 0x98, 0xc1, 0x3b, 0x51, 0x25, 0xbd, 0xab, 0xdc, 0xc8, 0x74, 0x69, 0x27, 0xe6, 0x1c, 0x53,
	0x7f, 0x7a, 0xa4, 0x24, 0x9c, 0xb2, 0x92, 0xd7, 0x9b, 0x96, 0x07, 0xab, 0xd2, 0x2c, 0xda, 0x80,
	0xe2, 0xab, 0xde, 0x6b, 0xa7, 0x5f, 0xb3, 0x50, 0x09, 0x56, 0x4f, 0x8e, 0xbe, 0xe9, 0xd7, 0x0a,
	0x92, 0x78, 0xd6, 0xfb, 0x6a, 0xf0, 0xaa, 0xb6, 0x22, 0x97, 0x83, 0xde, 0xe0, 0xe8, 0xb4, 0x06,
	0xa8, 0x06, 0x95, 0xb3, 0xee, 0xe9, 0x69, 0xb7, 0xf7, 0x95, 0xdb, 0xed, 0x9d, 0xf7, 0x6b, 0x75,
	0x54, 0x81, 0xd2, 0xcb, 0x63, 0x57, 0x8b, 0x36, 0x50, 0x15, 0xe0, 0xec, 0xf8, 0xbc, 0x6f, 0xf6,
	0xbb, 0xad, 0xdf, 0x17, 0x60, 0xdb, 0x8c, 0x17, 0x15, 0x99, 0x17, 0x34, 0xe2, 0x53, 0xf4, 0x09,
	0xac, 0x2f, 0xbf, 0x3f, 0xd7, 0x98, 0xbe, 0x3a, 0x7f, 0x06, 0xd5, 0x64, 0xa2, 0x99, 0x62, 0xd6,
	0x57, 0xcb, 0xc7, 0x39, 0x23, 0xed, 0xc6, 0x46, 0x86, 0xe2, 0x6c, 0x8e, 0x53, 0x3b, 0x81, 0x5a,
	0x50, 0x19, 0xc6, 0x5c, 0x44, 0xde, 0x70, 0x8c, 0x3b, 0xe7, 0xaf, 0xd5, 0x8c, 0x2c, 0x39, 0x19,
	0x9a, 0xed, 0x42, 0x25, 0xad, 0x02, 0x7d, 0x17, 0xb6, 0x68, 0x3c, 0x19, 0x62, 0xee, 0xb2, 0x4b,
	0xd7, 0x67, 0x1c, 0x0b, 0x75, 0xf6, 0xa2, 0xb3, 0xa9, 0xc9, 0xbd, 0xcb, 0x8e, 0x24, 0xa2, 0x0f,
	0xa1, 0xb8, 0xa4, 0x8a, 0x35, 0xbf, 0xf5, 0xbb, 0x3a, 0x80, 0x22, 0x0c, 0xa4, 0x49, 0xd4, 0x84,
	0xf5, 0x6b, 0xcc, 0x85, 0x1c, 0xfa, 0x7a, 0xa6, 0x24, 0x5b, 0xf4, 0x12, 0x6a, 0x3a, 0xcb, 0xea,
	0x6c, 0xee, 0x15, 0x9e, 0x8a, 0x66, 0x49, 0x85, 0x60, 0xff, 0xb6, 0x72, 0x42, 0x47, 0x5d, 0x79,
	0x41, 0x91, 0x4b, 0x82, 0xb9, 0x53, 0x0d, 0x67, 0xea, 0x7f, 0x8a, 0xa7, 0x02, 0x11, 0x68, 0x48,
	0x59, 0x3c, 0xf1, 0x68, 0xe0, 0xa6, 0x54, 0x9a, 0x80, 0x3e, 0x9f, 0x3b, 0xaa, 0x82, 0xb6, 0x7b,
	0xf4, 0x44, 0x41, 0x6e, 0x48, 0xc7, 0x53, 0x07, 0x8f, 0x08, 0xa3, 0x2a, 0xd2, 0x0e, 0x62, 0x73,
	0x02, 0xe8, 0x6b, 0xa8, 0x89, 0x90, 0x45, 0x19, 0x2b, 0xfa, 0x62, 0x3d, 0x5c, 0x60, 0xa5, 0x1f,
	0x32, 0xdd, 0xd7, 0x59, 0xe5, 0x55, 0x91, 0xd0, 0xb5, 0xe2, 0xb7, 0x16, 0xec, 0x73, 0x33, 0x46,
	0x5c, 0x62, 0xe6, 0x48, 0xc6, 0x4c, 0x51, 0x99, 0xf9, 0xf1, 0x02, 0x33, 0xb9, 0x23, 0x28, 0xc7,
	0x29, 0x9b, 0x2f, 0x14, 0x44, 0x2e, 0xec, 0xdf, 0xc4, 0x31, 0x53, 0x9b, 0xe6, 0x08, 0x6b, 0xf3,
	0xd9, 0x99, 0x2b, 0x50, 0xe7, 0x5b, 0x49, 0xd8, 0xd2, 0x2c, 0x6d, 0xe0, 0x17, 0xf0, 0xfe, 0xcc,
	0xc7, 0x3c, 0xfd, 0xeb, 0xf7, 0xd2, 0x9f, 0xa8, 0x98, 0xd7, 0xff, 0x29, 0x6c, 0x4b, 0x16, 0x91,
	0x5e, 0xb1, 0x6b, 0x12, 0x60, 0xde, 0x0d, 0x9a, 0x1b, 0xaa, 0xea, 0xe6, 0x19, 0xf6, 0x5f, 0x0b,
	0xb0, 0x9b, 0x9f, 0x1d, 0xf4, 0x25, 0x54, 0x39, 0x1e, 0x7b, 0x11, 0x0e, 0x5c, 0xae, 0xc8, 0xe6,
	0x99, 0xd9, 0xc8, 0xbd, 0x34, 0x9c, 0x4d, 0x23, 0xac, 0x55, 0xa0, 0x1f, 0x40, 0x25, 0x41, 0xff,
	0x9a, 0x51, 0xac, 0x6e, 0xe4, 0x85, 0xd8, 0xb2, 0x11, 0x7d, 0xc3, 0x28, 0x46, 0x2f, 0xa1, 0x9e,
	0x20, 0x7d, 0xfd, 0x50, 0x77, 0x23, 0x82, 0xb9, 0x6a, 0xe4, 0x85, 0x1a, 0x90, 0x81, 0xa4, 0x9e,
	0xf6, 0xf3, 0xef, 0xf9, 0xd5, 0xfb, 0xbd, 0xe7, 0xef, 0xdb, 0xe5, 0xf6, 0xff, 0x4a, 0xf0, 0x64,
	0x49, 0x03, 0x3d, 0x32, 0x8a, 0xbf, 0xb1, 0x60, 0x27, 0x09, 0xc2, 0x7c, 0x53, 0xf7, 0xdf, 0xad,
	0xa9, 0x93, 0x8f, 0xa7, 0x34, 0x5b, 0x06, 0x4c, 0x97, 0xd6, 0xb6, 0x7f, 0x9b, 0x2b, 0x3f, 0xde,
	0xea, 0x81, 0x79, 0x99, 0x66, 0x8e, 0xb1, 0xa2, 0x8e, 0x31, 0x78, 0xc7, 0x63, 0x24, 0x8f, 0xdd,
	0xfc, 0x73, 0xa0, 0x60, 0x8e, 0xad, 0xc2, 0x91, 0x79, 0x66, 0x65, 0xa6, 0xcf, 0xbb, 0x86, 0x23,
	0xfd, 0xd6, 0x9a, 0x0f, 0x87, 0xb8, 0xcd, 0x45, 0xdf, 0x87, 0x8d, 0xe4, 0x01, 0x2b, 0x9a, 0x45,
	0x95, 0xcd, 0xbd, 0x05, 0x2f, 0x58, 0xa7, 0x64, 0xde, 0xac, 0xc2, 0xfe, 0xbb, 0x05, 0xef, 0xdf,
	0x15, 0xf8, 0x85, 0x75, 0x6f, 0x3d, 0xb4, 0xee, 0xbf, 0x86, 0xbd, 0xb4, 0x02, 0x13, 0xa9, 0x31,
	0x11, 0x91, 0xe9, 0xc2, 0x83, 0x65, 0x9f, 0xd7, 0x4e, 0xdd, 0xcf, 0xa1, 0xda, 0xff, 0xb2, 0x60,
	0xff, 0xce, 0xa4, 0xa1, 0x2e, 0x34, 0x12, 0x1f, 0x66, 0x05, 0xb3, 0xdc, 0x89, 0x1d, 0x83, 0x49,
	0x7f, 0x6f, 0xa1, 0x37, 0xd0, 0xcc, 0xa8, 0xc8, 0xba, 0x21, 0xf3, 0xfd, 0xc1, 0xd2, 0xef, 0x4f,
	0xa7, 0x11, 0xe4, 0x91, 0x55, 0x2e, 0xee, 0xca, 0x7a, 0x3a, 0x17, 0x49, 0xbd, 0xdd, 0x3f, 0x17,
	0xa9, 0xa7, 0xba, 0xcc, 0x45, 0x5a, 0xc1, 0x92, 0x5c, 0xe4, 0x7d, 0x21, 0x38, 0x75, 0x91, 0x43,
	0xb5, 0xff, 0x6b, 0xc1, 0x87, 0xf7, 0xbc, 0xef, 0x1e, 0x39, 0x83, 0x42, 0x78, 0x6f, 0xd1, 0xa5,
	0x3c, 0xf1, 0x42, 0x93, 0x8b, 0xcf, 0x1e, 0x72, 0x25, 0xeb, 0xce, 0x6a, 0xe6, 0xde, 0xc2, 0x67,
	0x5e, 0x68, 0xff, 0xc7, 0x02, 0x7b, 0x31, 0x10, 0x5d, 0xc0, 0xee, 0xfc, 0x81, 0x44, 0x88, 0x7d,
	0xe3, 0x56, 0x26, 0xa4, 0xb7, 0xf5, 0xf4, 0x43, 0xec, 0x3b, 0x75, 0x9e, 0x43, 0x45, 0xdf, 0xc0,
	0xde, 0x02, 0x47, 0x4d, 0xae, 0x3e, 0xb8, 0x4b, 0xb1, 0xbe, 0x19, 0x1a, 0xb9, 0x4e, 0x1d, 0xf7,
	0xe0, 0x89, 0xcf, 0x26, 0xed, 0xeb, 0x49, 0x14, 0xf3, 0x21, 0x6b, 0x87, 0x63, 0x2f, 0xba, 0x64,
	0x7c, 0xd2, 0x16, 0xc1, 0x95, 0xd1, 0xf9, 0xe6, 0xd3, 0x11, 0x89, 0x7e, 0x19, 0x0f, 0xe5, 0xf6,
	0xa9, 0x92, 0xa2, 0x6c, 0x42, 0x7c, 0xbd, 0x3c, 0x1c, 0xb1, 0x43, 0x11, 0x5c, 0x3d, 0x0d, 0xaf,
	0x46, 0x4f, 0xd5, 0x0f, 0xbc, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0x9c, 0xf3, 0x1d, 0x74, 0x04,
	0x14, 0x00, 0x00,
}
