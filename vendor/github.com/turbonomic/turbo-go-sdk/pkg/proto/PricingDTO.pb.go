// Code generated by protoc-gen-go.
// source: PricingDTO.proto
// DO NOT EDIT!

package proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The unit for the price.
// The unit affects how to use the price to calculate the cost for an entity,
// and is also useful when displaying information for UI purposes.
//
// TODO (roman, Jul 31 2018): Not all units are relevant for all types of cloud entities.
// In the future it may be worth it to have each type of cloud entity have its own unit,
// to avoid confusion.
type Price_Unit int32

const (
	// The price is calculated on an hourly basis.
	// One unit = one hour.
	Price_HOURS Price_Unit = 1
	// The price is calculated on a daily basis.
	// One unit = one day.
	Price_DAYS Price_Unit = 2
	// The price is calculated on a monthly basis.
	// One unit = one month.
	Price_MONTH Price_Unit = 3
	// The price is a total one-time cost.
	Price_TOTAL Price_Unit = 10
	// The price is calculated on a per-IOPS rate.
	// One unit = one million iops.
	Price_MILLION_IOPS Price_Unit = 20
	// The price is calculated on a GB-month.
	// One unit = one GB-month.
	// A GB-month is gigabytes averaged over the month. For example, if you store 30 GB
	// for 15 days of a 30-day month, that would add up to 15 GB-month.
	Price_GB_MONTH Price_Unit = 21
	// The price is calculated on a per-MiB/s of throughput basis per month.
	// One unit = one month of 1 MiB/s throughput.
	Price_MBPS_MONTH Price_Unit = 22
)

var Price_Unit_name = map[int32]string{
	1:  "HOURS",
	2:  "DAYS",
	3:  "MONTH",
	10: "TOTAL",
	20: "MILLION_IOPS",
	21: "GB_MONTH",
	22: "MBPS_MONTH",
}
var Price_Unit_value = map[string]int32{
	"HOURS":        1,
	"DAYS":         2,
	"MONTH":        3,
	"TOTAL":        10,
	"MILLION_IOPS": 20,
	"GB_MONTH":     21,
	"MBPS_MONTH":   22,
}

func (x Price_Unit) Enum() *Price_Unit {
	p := new(Price_Unit)
	*p = x
	return p
}
func (x Price_Unit) String() string {
	return proto.EnumName(Price_Unit_name, int32(x))
}
func (x *Price_Unit) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Price_Unit_value, data, "Price_Unit")
	if err != nil {
		return err
	}
	*x = Price_Unit(value)
	return nil
}
func (Price_Unit) EnumDescriptor() ([]byte, []int) { return fileDescriptor8, []int{5, 0} }

// The list of prices for a particular compute tier. In the cloud, a compute tier is
// the seller of CPU/memory (but not storage) to a VM. It is commonly referred to as an
// "instance" (e.g. Compute Instance in AWS). We use the tier terminology to be consistent
// across compute and storage, and because you can think of the compute instances as
// different available "tiers" of the Compute service.
//
// A single compute tier may have different available prices depending on other
// configuration option (for example, whether it's shared or a dedicated).
type ComputeTierPriceList struct {
	// The base price is the price of the default - and usually cheapest - configuration.
	// For example, in AWS this would be a shared Linux machine (which has no extra license
	// or tenancy costs).
	BasePrice *ComputeTierPriceList_ComputeTierConfigPrice `protobuf:"bytes,1,opt,name=base_price,json=basePrice" json:"base_price,omitempty"`
	// There are the other configurations available for the tier, and the
	// prices for those configurations ON TOP of the base price. We track it this way
	// so that we can easily separate the compute cost from the license/tenancy cost.
	//
	// For example, if the base price is for a Linux machine that costs $1/hr, and a Windows OS
	// machine costs $1.50/hr, there would be a price adjustment for a Windows OS with price
	// "0.50/hr". To get the full price for a Windows insance you would need to find the
	// appropriate price adjustment, and add it to the base price.
	//
	// The configuration from the base price should not appear in this list.
	PerConfigurationPriceAdjustments []*ComputeTierPriceList_ComputeTierConfigPrice `protobuf:"bytes,2,rep,name=per_configuration_price_adjustments,json=perConfigurationPriceAdjustments" json:"per_configuration_price_adjustments,omitempty"`
	XXX_unrecognized                 []byte                                         `json:"-"`
}

func (m *ComputeTierPriceList) Reset()                    { *m = ComputeTierPriceList{} }
func (m *ComputeTierPriceList) String() string            { return proto.CompactTextString(m) }
func (*ComputeTierPriceList) ProtoMessage()               {}
func (*ComputeTierPriceList) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{0} }

func (m *ComputeTierPriceList) GetBasePrice() *ComputeTierPriceList_ComputeTierConfigPrice {
	if m != nil {
		return m.BasePrice
	}
	return nil
}

func (m *ComputeTierPriceList) GetPerConfigurationPriceAdjustments() []*ComputeTierPriceList_ComputeTierConfigPrice {
	if m != nil {
		return m.PerConfigurationPriceAdjustments
	}
	return nil
}

// The price for a particular configuration of a compute tier.
type ComputeTierPriceList_ComputeTierConfigPrice struct {
	// The guest operating system.
	GuestOsType *OSType `protobuf:"varint,1,opt,name=guest_os_type,json=guestOsType,enum=common_dto.OSType" json:"guest_os_type,omitempty"`
	// The tenancy for this configuration of the tier.
	// A single tier may have different tenancy options that will be priced differently
	// (e.g. dedicated tenancy is more expensive than shared).
	Tenancy *Tenancy `protobuf:"varint,2,opt,name=tenancy,enum=common_dto.Tenancy" json:"tenancy,omitempty"`
	// The available prices for this configuration of the tier. There may be multiple
	// prices (e.g. an hourly price and a monthly price).
	Prices           []*Price `protobuf:"bytes,10,rep,name=prices" json:"prices,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ComputeTierPriceList_ComputeTierConfigPrice) Reset() {
	*m = ComputeTierPriceList_ComputeTierConfigPrice{}
}
func (m *ComputeTierPriceList_ComputeTierConfigPrice) String() string {
	return proto.CompactTextString(m)
}
func (*ComputeTierPriceList_ComputeTierConfigPrice) ProtoMessage() {}
func (*ComputeTierPriceList_ComputeTierConfigPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor8, []int{0, 0}
}

func (m *ComputeTierPriceList_ComputeTierConfigPrice) GetGuestOsType() OSType {
	if m != nil && m.GuestOsType != nil {
		return *m.GuestOsType
	}
	return OSType_UNKNOWN_OS
}

func (m *ComputeTierPriceList_ComputeTierConfigPrice) GetTenancy() Tenancy {
	if m != nil && m.Tenancy != nil {
		return *m.Tenancy
	}
	return Tenancy_DEFAULT
}

func (m *ComputeTierPriceList_ComputeTierConfigPrice) GetPrices() []*Price {
	if m != nil {
		return m.Prices
	}
	return nil
}

// The list of prices for a particular database tier. In the cloud, a database tier is
// a managed database solution (e.g. RDS in AWS). It is commonly referred to as an
// "instance" (e.g. Database Instance in AWS). We use the tier terminology to be consistent
// with compute and storage, and because you can think of the database instances as
// different available "tiers" of databases.
//
// A single database tier may have different available prices depending on other
// configuration options (for example, the database engine).
type DatabaseTierPriceList struct {
	// The base price is the price of the default - and usually cheapest - configuration.
	// For example, in AWS this would be a shared Linux machine (which has no extra license
	// or tenancy costs).
	BasePrice *DatabaseTierPriceList_DatabaseTierConfigPrice `protobuf:"bytes,1,opt,name=base_price,json=basePrice" json:"base_price,omitempty"`
	// There are the other configurations available for the database instance, and the
	// prices for those configurations ON TOP of the base price. We track it this way
	// so that we can easily separate the compute cost from the license/tenancy cost.
	//
	// For example, if the base price is for a PostgreSQL machine that costs $1/hr, and an Oracle
	// machine costs $1.50/hr, there would be a price adjustment for Oracle with price
	// "0.50/hr". To get the full price for an Oracle insance you would need to find the
	// appropriate price adjustment, and add it to the base price.
	//
	// The configuration from the base price should not appear in this list.
	ConfigurationPriceAdjustments []*DatabaseTierPriceList_DatabaseTierConfigPrice `protobuf:"bytes,2,rep,name=configuration_price_adjustments,json=configurationPriceAdjustments" json:"configuration_price_adjustments,omitempty"`
	// different deployment types has different costs
	DeploymentType   *DeploymentType `protobuf:"varint,3,opt,name=deployment_type,json=deploymentType,enum=common_dto.DeploymentType" json:"deployment_type,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *DatabaseTierPriceList) Reset()                    { *m = DatabaseTierPriceList{} }
func (m *DatabaseTierPriceList) String() string            { return proto.CompactTextString(m) }
func (*DatabaseTierPriceList) ProtoMessage()               {}
func (*DatabaseTierPriceList) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{1} }

func (m *DatabaseTierPriceList) GetBasePrice() *DatabaseTierPriceList_DatabaseTierConfigPrice {
	if m != nil {
		return m.BasePrice
	}
	return nil
}

func (m *DatabaseTierPriceList) GetConfigurationPriceAdjustments() []*DatabaseTierPriceList_DatabaseTierConfigPrice {
	if m != nil {
		return m.ConfigurationPriceAdjustments
	}
	return nil
}

func (m *DatabaseTierPriceList) GetDeploymentType() DeploymentType {
	if m != nil && m.DeploymentType != nil {
		return *m.DeploymentType
	}
	return DeploymentType_SINGLE_AZ
}

// The price for a particular configuration of a database tier.
type DatabaseTierPriceList_DatabaseTierConfigPrice struct {
	// The database engine to use for this configuration of the tier.
	// Should be set.
	DbEngine *DatabaseEngine `protobuf:"varint,1,opt,name=db_engine,json=dbEngine,enum=common_dto.DatabaseEngine" json:"db_engine,omitempty"`
	// The edition of the engine to use for this configuration of the tier. Not to be confused
	// with "version", which doesn't affect the price.
	//
	// May be unset, because open-source database engines often don't have editions.
	DbEdition *DatabaseEdition `protobuf:"varint,2,opt,name=db_edition,json=dbEdition,enum=common_dto.DatabaseEdition" json:"db_edition,omitempty"`
	// LicenseModel describes all supported license models in cloud projects.
	DbLicenseModel *LicenseModel `protobuf:"varint,3,opt,name=db_license_model,json=dbLicenseModel,enum=common_dto.LicenseModel" json:"db_license_model,omitempty"`
	// // DeploymentType describes all supported deployment types by cloud probes.
	DbDeploymentType *DeploymentType `protobuf:"varint,4,opt,name=db_deployment_type,json=dbDeploymentType,enum=common_dto.DeploymentType" json:"db_deployment_type,omitempty"`
	// The available prices for this configuration of the database tier.
	// There may be different prices (e.g. an hourly price and a monthly price).
	Prices           []*Price `protobuf:"bytes,20,rep,name=prices" json:"prices,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) Reset() {
	*m = DatabaseTierPriceList_DatabaseTierConfigPrice{}
}
func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) String() string {
	return proto.CompactTextString(m)
}
func (*DatabaseTierPriceList_DatabaseTierConfigPrice) ProtoMessage() {}
func (*DatabaseTierPriceList_DatabaseTierConfigPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor8, []int{1, 0}
}

func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) GetDbEngine() DatabaseEngine {
	if m != nil && m.DbEngine != nil {
		return *m.DbEngine
	}
	return DatabaseEngine_UNKNOWN
}

func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) GetDbEdition() DatabaseEdition {
	if m != nil && m.DbEdition != nil {
		return *m.DbEdition
	}
	return DatabaseEdition_NONE
}

func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) GetDbLicenseModel() LicenseModel {
	if m != nil && m.DbLicenseModel != nil {
		return *m.DbLicenseModel
	}
	return LicenseModel_BRING_YOUR_OWN_LICENSE
}

func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) GetDbDeploymentType() DeploymentType {
	if m != nil && m.DbDeploymentType != nil {
		return *m.DbDeploymentType
	}
	return DeploymentType_SINGLE_AZ
}

func (m *DatabaseTierPriceList_DatabaseTierConfigPrice) GetPrices() []*Price {
	if m != nil {
		return m.Prices
	}
	return nil
}

// The list of prices for a particular IP.
//
// TODO (roman, July 31 2018): It's unclear at the time of this writing what different kinds
// of IPs are available within a region, and whether this model is the best way to represent
// them.
//
// Also, the cost probes currently (July 31 2018) use the same name for all IP Addresses,
// meaning there will only be one IpPriceList per region if we dedupe based on name alone.
//
// However, in AWS there are different IP Address entries within a region. These have different
// group types - charges for IP remaps, charges for IPs attached to a running instance,
// charges for IPs NOT attached to a running instance - represented by different product SKU's.
// Right now the IP Price List is not flexible enough to express all of those options.
type IpPriceList struct {
	// The list of IP prices.
	IpPrice          []*IpPriceList_IpConfigPrice `protobuf:"bytes,1,rep,name=ip_price,json=ipPrice" json:"ip_price,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *IpPriceList) Reset()                    { *m = IpPriceList{} }
func (m *IpPriceList) String() string            { return proto.CompactTextString(m) }
func (*IpPriceList) ProtoMessage()               {}
func (*IpPriceList) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{2} }

func (m *IpPriceList) GetIpPrice() []*IpPriceList_IpConfigPrice {
	if m != nil {
		return m.IpPrice
	}
	return nil
}

// The price for a particular IP configuration.
type IpPriceList_IpConfigPrice struct {
	// The number of IPs you get for free for an instance.
	// This seems to only be relevant in AWS.
	FreeIpCount *int32 `protobuf:"varint,2,opt,name=free_ip_count,json=freeIpCount" json:"free_ip_count,omitempty"`
	// The prices available for this IP Price. There may be different prices (e.g. an hourly
	// price and a monthly price).
	Prices []*Price `protobuf:"bytes,10,rep,name=prices" json:"prices,omitempty"`
	// Type is used to know if it's a static/ non static.
	Type             *string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *IpPriceList_IpConfigPrice) Reset()                    { *m = IpPriceList_IpConfigPrice{} }
func (m *IpPriceList_IpConfigPrice) String() string            { return proto.CompactTextString(m) }
func (*IpPriceList_IpConfigPrice) ProtoMessage()               {}
func (*IpPriceList_IpConfigPrice) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{2, 0} }

func (m *IpPriceList_IpConfigPrice) GetFreeIpCount() int32 {
	if m != nil && m.FreeIpCount != nil {
		return *m.FreeIpCount
	}
	return 0
}

func (m *IpPriceList_IpConfigPrice) GetPrices() []*Price {
	if m != nil {
		return m.Prices
	}
	return nil
}

func (m *IpPriceList_IpConfigPrice) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

// The list of storage prices for a particular cloud storage tier.
type StorageTierPriceList struct {
	// The list of prices.
	//
	// Note: Right now this could be replaced by "repeated Price", but using an extra
	// wrapper is more consistent with the other price lists, and more easily extensible
	// later down the road.
	CloudStoragePrice []*StorageTierPriceList_StorageTierPrice `protobuf:"bytes,1,rep,name=cloud_storage_price,json=cloudStoragePrice" json:"cloud_storage_price,omitempty"`
	XXX_unrecognized  []byte                                   `json:"-"`
}

func (m *StorageTierPriceList) Reset()                    { *m = StorageTierPriceList{} }
func (m *StorageTierPriceList) String() string            { return proto.CompactTextString(m) }
func (*StorageTierPriceList) ProtoMessage()               {}
func (*StorageTierPriceList) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{3} }

func (m *StorageTierPriceList) GetCloudStoragePrice() []*StorageTierPriceList_StorageTierPrice {
	if m != nil {
		return m.CloudStoragePrice
	}
	return nil
}

type StorageTierPriceList_StorageTierPrice struct {
	Prices []*Price `protobuf:"bytes,10,rep,name=prices" json:"prices,omitempty"`
	// The redundancy type for which the prices are being represented.
	RedundancyType   *EntityDTO_VirtualVolumeData_RedundancyType `protobuf:"varint,11,opt,name=redundancy_type,json=redundancyType,enum=common_dto.EntityDTO_VirtualVolumeData_RedundancyType" json:"redundancy_type,omitempty"`
	XXX_unrecognized []byte                                      `json:"-"`
}

func (m *StorageTierPriceList_StorageTierPrice) Reset()         { *m = StorageTierPriceList_StorageTierPrice{} }
func (m *StorageTierPriceList_StorageTierPrice) String() string { return proto.CompactTextString(m) }
func (*StorageTierPriceList_StorageTierPrice) ProtoMessage()    {}
func (*StorageTierPriceList_StorageTierPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor8, []int{3, 0}
}

func (m *StorageTierPriceList_StorageTierPrice) GetPrices() []*Price {
	if m != nil {
		return m.Prices
	}
	return nil
}

func (m *StorageTierPriceList_StorageTierPrice) GetRedundancyType() EntityDTO_VirtualVolumeData_RedundancyType {
	if m != nil && m.RedundancyType != nil {
		return *m.RedundancyType
	}
	return EntityDTO_VirtualVolumeData_LRS
}

// The pricing for reserved instances.
//
// Reserved instances are basically discounted on-demand instances with
// an upfront cost and a term. So instead of paying on-demand, you buy
// "in bulk".
//
// Note: AWS and Azure have reserved instance, and Google has a similar
// concept called "Committed Use Discounts".
type ReservedInstancePrice struct {
	// The total upfront price. May not be set if the payment option for the reserved
	// instance is NO_UPFRONT.
	//
	// TODO (roman, July 31 2019): This may need to be a list, to allow
	// different pricing options. For example, a different hourly vs monthly price.
	UpfrontPrice *Price `protobuf:"bytes,10,opt,name=upfront_price,json=upfrontPrice" json:"upfront_price,omitempty"`
	// The recurring price. This is the amount you have to pay regularly for the instance.
	//
	// TODO (roman, July 31 2019): This may need to be a list, to allow
	// different pricing options. For example, a different hourly vs monthly price.
	RecurringPrice *Price `protobuf:"bytes,11,opt,name=recurring_price,json=recurringPrice" json:"recurring_price,omitempty"`
	// This captures other costs for using the instance - for example, license costs.
	// May not be set, depending on the instance configuration (e.g. a Linux instance
	// will have no license costs).
	//
	// TODO (roman, July 31 2019): This may need to be a list, to allow
	// different pricing options. For example, a different hourly vs monthly price.
	UsagePrice       *Price `protobuf:"bytes,12,opt,name=usage_price,json=usagePrice" json:"usage_price,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ReservedInstancePrice) Reset()                    { *m = ReservedInstancePrice{} }
func (m *ReservedInstancePrice) String() string            { return proto.CompactTextString(m) }
func (*ReservedInstancePrice) ProtoMessage()               {}
func (*ReservedInstancePrice) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{4} }

func (m *ReservedInstancePrice) GetUpfrontPrice() *Price {
	if m != nil {
		return m.UpfrontPrice
	}
	return nil
}

func (m *ReservedInstancePrice) GetRecurringPrice() *Price {
	if m != nil {
		return m.RecurringPrice
	}
	return nil
}

func (m *ReservedInstancePrice) GetUsagePrice() *Price {
	if m != nil {
		return m.UsagePrice
	}
	return nil
}

// The price of a particular instance or cloud entity.
type Price struct {
	// The unit in which the price is measured.
	// Not all units are valid for all types of cloud entities.
	Unit *Price_Unit `protobuf:"varint,1,opt,name=unit,enum=common_dto.Price_Unit" json:"unit,omitempty"`
	// The end range - in units. If not set, assume "infinite".
	// For example, if the price is $0 for the first 10 X, and $10 for the next 10 X, then
	// there should be two Prices, with an end_range of 10 for the first one, and
	// an end_range of 20 for the second. The end is inclusive.
	EndRangeInUnits  *int64          `protobuf:"varint,6,opt,name=end_range_in_units,json=endRangeInUnits" json:"end_range_in_units,omitempty"`
	PriceAmount      *CurrencyAmount `protobuf:"bytes,22,opt,name=price_amount,json=priceAmount" json:"price_amount,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Price) Reset()                    { *m = Price{} }
func (m *Price) String() string            { return proto.CompactTextString(m) }
func (*Price) ProtoMessage()               {}
func (*Price) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{5} }

func (m *Price) GetUnit() Price_Unit {
	if m != nil && m.Unit != nil {
		return *m.Unit
	}
	return Price_HOURS
}

func (m *Price) GetEndRangeInUnits() int64 {
	if m != nil && m.EndRangeInUnits != nil {
		return *m.EndRangeInUnits
	}
	return 0
}

func (m *Price) GetPriceAmount() *CurrencyAmount {
	if m != nil {
		return m.PriceAmount
	}
	return nil
}

// The prices for license related to a specific operating system
type LicensePriceEntry struct {
	// / The operating system which the license is associated with
	OsType *OSType `protobuf:"varint,1,opt,name=os_type,json=osType,enum=common_dto.OSType" json:"os_type,omitempty"`
	// The list of prices associated with licensing a particular Operating System.
	// Not all cloud providers have license price lists. In particular, Azure does and AWS doesn't.
	// In Azure, license is priced by the number of cores the vm it applies to is using.
	LicensePrices []*LicensePriceEntry_LicensePrice `protobuf:"bytes,2,rep,name=license_prices,json=licensePrices" json:"license_prices,omitempty"`
	// To distinguish burstable and non-burstable license rates.
	BurstableCPU     *bool  `protobuf:"varint,3,opt,name=burstableCPU" json:"burstableCPU,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *LicensePriceEntry) Reset()                    { *m = LicensePriceEntry{} }
func (m *LicensePriceEntry) String() string            { return proto.CompactTextString(m) }
func (*LicensePriceEntry) ProtoMessage()               {}
func (*LicensePriceEntry) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{6} }

func (m *LicensePriceEntry) GetOsType() OSType {
	if m != nil && m.OsType != nil {
		return *m.OsType
	}
	return OSType_UNKNOWN_OS
}

func (m *LicensePriceEntry) GetLicensePrices() []*LicensePriceEntry_LicensePrice {
	if m != nil {
		return m.LicensePrices
	}
	return nil
}

func (m *LicensePriceEntry) GetBurstableCPU() bool {
	if m != nil && m.BurstableCPU != nil {
		return *m.BurstableCPU
	}
	return false
}

type LicensePriceEntry_LicensePrice struct {
	// This is the upper bound of the number of cores this price applies to. E.g. if there are
	// three license prices with pricing for 1-2 cores, 3-4 cores, and 5+ cores, there
	// will be entries with number_of_cores = 2, 4, and MAX_INTEGER.
	NumberOfCores *int32 `protobuf:"varint,1,opt,name=number_of_cores,json=numberOfCores" json:"number_of_cores,omitempty"`
	// The price associated with the number of core and the OS
	Price            *Price `protobuf:"bytes,10,opt,name=price" json:"price,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *LicensePriceEntry_LicensePrice) Reset()         { *m = LicensePriceEntry_LicensePrice{} }
func (m *LicensePriceEntry_LicensePrice) String() string { return proto.CompactTextString(m) }
func (*LicensePriceEntry_LicensePrice) ProtoMessage()    {}
func (*LicensePriceEntry_LicensePrice) Descriptor() ([]byte, []int) {
	return fileDescriptor8, []int{6, 0}
}

func (m *LicensePriceEntry_LicensePrice) GetNumberOfCores() int32 {
	if m != nil && m.NumberOfCores != nil {
		return *m.NumberOfCores
	}
	return 0
}

func (m *LicensePriceEntry_LicensePrice) GetPrice() *Price {
	if m != nil {
		return m.Price
	}
	return nil
}

// The price table object contains the pricing information related to a specific cloud provider.
// The cloud provider has pricing for different products and offerings. This means that price for
// different services on the same cloud provider will be all merged together in this object (EC2,
// RDS, ..)
type PriceTable struct {
	// The version of the price table retrieved from the cloud provider.
	// The version can come directly from the cloud provider itself (AWS has a version in its own
	// pricing, like: "version" : "20180809215656")
	// If the cloud provider is not providing a version directly, then the probe needs to generate one
	// on its own.
	// This field will be used by the server side to understand if the price table sent from probe
	// to server is the same one that the server already has. If the version that the server is
	// receiving is the same one that he already processed before, he is free to discard the data.
	Version *string `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	// Information used to uniquely associate this price table with a business account.
	PriceTableKeys []*PricingIdentifier `protobuf:"bytes,8,rep,name=price_table_keys,json=priceTableKeys" json:"price_table_keys,omitempty"`
	// Price table for on-demand instances. this is the "default" pay-per-use option for all cloud
	// providers.
	OnDemandPriceTable []*PriceTable_OnDemandPriceTableByRegionEntry `protobuf:"bytes,2,rep,name=on_demand_price_table,json=onDemandPriceTable" json:"on_demand_price_table,omitempty"`
	SpotPriceTable     []*PriceTable_SpotPriceByRegionEntry          `protobuf:"bytes,4,rep,name=spot_price_table,json=spotPriceTable" json:"spot_price_table,omitempty"`
	// RI price table
	ReservedInstancePriceTable []*PriceTable_ReservedInstancePriceTableByRegionEntry `protobuf:"bytes,5,rep,name=reserved_instance_price_table,json=reservedInstancePriceTable" json:"reserved_instance_price_table,omitempty"`
	// On-Demand License price table by Os type. A table entry represents the list of prices associated
	// with licensing a particular Operating System.
	OnDemandLicensePriceTable []*LicensePriceEntry `protobuf:"bytes,6,rep,name=on_demand_license_price_table,json=onDemandLicensePriceTable" json:"on_demand_license_price_table,omitempty"`
	// Reserved License price table by OS type
	ReservedLicensePriceTable []*LicensePriceEntry `protobuf:"bytes,7,rep,name=reserved_license_price_table,json=reservedLicensePriceTable" json:"reserved_license_price_table,omitempty"`
	// The service provider id of the pricing info.
	ServiceProviderId *string `protobuf:"bytes,9,opt,name=serviceProviderId" json:"serviceProviderId,omitempty"`
	XXX_unrecognized  []byte  `json:"-"`
}

func (m *PriceTable) Reset()                    { *m = PriceTable{} }
func (m *PriceTable) String() string            { return proto.CompactTextString(m) }
func (*PriceTable) ProtoMessage()               {}
func (*PriceTable) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{7} }

func (m *PriceTable) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *PriceTable) GetPriceTableKeys() []*PricingIdentifier {
	if m != nil {
		return m.PriceTableKeys
	}
	return nil
}

func (m *PriceTable) GetOnDemandPriceTable() []*PriceTable_OnDemandPriceTableByRegionEntry {
	if m != nil {
		return m.OnDemandPriceTable
	}
	return nil
}

func (m *PriceTable) GetSpotPriceTable() []*PriceTable_SpotPriceByRegionEntry {
	if m != nil {
		return m.SpotPriceTable
	}
	return nil
}

func (m *PriceTable) GetReservedInstancePriceTable() []*PriceTable_ReservedInstancePriceTableByRegionEntry {
	if m != nil {
		return m.ReservedInstancePriceTable
	}
	return nil
}

func (m *PriceTable) GetOnDemandLicensePriceTable() []*LicensePriceEntry {
	if m != nil {
		return m.OnDemandLicensePriceTable
	}
	return nil
}

func (m *PriceTable) GetReservedLicensePriceTable() []*LicensePriceEntry {
	if m != nil {
		return m.ReservedLicensePriceTable
	}
	return nil
}

func (m *PriceTable) GetServiceProviderId() string {
	if m != nil && m.ServiceProviderId != nil {
		return *m.ServiceProviderId
	}
	return ""
}

// Spot prices for availability zones in this region
type PriceTable_SpotPriceByRegionEntry struct {
	// Region
	RelatedRegion *EntityDTO `protobuf:"bytes,1,opt,name=related_region,json=relatedRegion" json:"related_region,omitempty"`
	// Availability Zone
	RelatedZone *EntityDTO `protobuf:"bytes,2,opt,name=related_zone,json=relatedZone" json:"related_zone,omitempty"`
	// What Compute Tier
	RelatedComputeTier *EntityDTO `protobuf:"bytes,3,opt,name=related_compute_tier,json=relatedComputeTier" json:"related_compute_tier,omitempty"`
	GuestOsType        *OSType    `protobuf:"varint,4,opt,name=guest_os_type,json=guestOsType,enum=common_dto.OSType" json:"guest_os_type,omitempty"`
	// Spot Price For most recent period
	Price            *Price `protobuf:"bytes,10,opt,name=price" json:"price,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PriceTable_SpotPriceByRegionEntry) Reset()         { *m = PriceTable_SpotPriceByRegionEntry{} }
func (m *PriceTable_SpotPriceByRegionEntry) String() string { return proto.CompactTextString(m) }
func (*PriceTable_SpotPriceByRegionEntry) ProtoMessage()    {}
func (*PriceTable_SpotPriceByRegionEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor8, []int{7, 0}
}

func (m *PriceTable_SpotPriceByRegionEntry) GetRelatedRegion() *EntityDTO {
	if m != nil {
		return m.RelatedRegion
	}
	return nil
}

func (m *PriceTable_SpotPriceByRegionEntry) GetRelatedZone() *EntityDTO {
	if m != nil {
		return m.RelatedZone
	}
	return nil
}

func (m *PriceTable_SpotPriceByRegionEntry) GetRelatedComputeTier() *EntityDTO {
	if m != nil {
		return m.RelatedComputeTier
	}
	return nil
}

func (m *PriceTable_SpotPriceByRegionEntry) GetGuestOsType() OSType {
	if m != nil && m.GuestOsType != nil {
		return *m.GuestOsType
	}
	return OSType_UNKNOWN_OS
}

func (m *PriceTable_SpotPriceByRegionEntry) GetPrice() *Price {
	if m != nil {
		return m.Price
	}
	return nil
}

// The on-demand prices in a specific region.
type PriceTable_OnDemandPriceTableByRegionEntry struct {
	// Cloud Region for which those prices are relevant.
	RelatedRegion *EntityDTO `protobuf:"bytes,1,opt,name=related_region,json=relatedRegion" json:"related_region,omitempty"`
	// The prices for compute tiers in this region
	ComputePriceTable []*PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry `protobuf:"bytes,2,rep,name=compute_price_table,json=computePriceTable" json:"compute_price_table,omitempty"`
	// The prices for database tiers in this region
	DatabasePriceTable []*PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry `protobuf:"bytes,3,rep,name=database_price_table,json=databasePriceTable" json:"database_price_table,omitempty"`
	// The prices for cloud storage tiers in this region
	StoragePriceTable []*PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry `protobuf:"bytes,4,rep,name=storage_price_table,json=storagePriceTable" json:"storage_price_table,omitempty"`
	// The prices for IP addresses in this region
	IpPrices         *IpPriceList `protobuf:"bytes,5,opt,name=ip_prices,json=ipPrices" json:"ip_prices,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry) Reset() {
	*m = PriceTable_OnDemandPriceTableByRegionEntry{}
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry) String() string {
	return proto.CompactTextString(m)
}
func (*PriceTable_OnDemandPriceTableByRegionEntry) ProtoMessage() {}
func (*PriceTable_OnDemandPriceTableByRegionEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor8, []int{7, 1}
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry) GetRelatedRegion() *EntityDTO {
	if m != nil {
		return m.RelatedRegion
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry) GetComputePriceTable() []*PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry {
	if m != nil {
		return m.ComputePriceTable
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry) GetDatabasePriceTable() []*PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry {
	if m != nil {
		return m.DatabasePriceTable
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry) GetStoragePriceTable() []*PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry {
	if m != nil {
		return m.StoragePriceTable
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry) GetIpPrices() *IpPriceList {
	if m != nil {
		return m.IpPrices
	}
	return nil
}

// The prices for compute related to a specific compute tier
type PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry struct {
	// Compute tier for which those prices are relevant.
	RelatedComputeTier   *EntityDTO            `protobuf:"bytes,1,opt,name=related_compute_tier,json=relatedComputeTier" json:"related_compute_tier,omitempty"`
	ComputeTierPriceList *ComputeTierPriceList `protobuf:"bytes,2,opt,name=compute_tier_price_list,json=computeTierPriceList" json:"compute_tier_price_list,omitempty"`
	XXX_unrecognized     []byte                `json:"-"`
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) Reset() {
	*m = PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry{}
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) String() string {
	return proto.CompactTextString(m)
}
func (*PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) ProtoMessage() {}
func (*PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor8, []int{7, 1, 0}
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) GetRelatedComputeTier() *EntityDTO {
	if m != nil {
		return m.RelatedComputeTier
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry) GetComputeTierPriceList() *ComputeTierPriceList {
	if m != nil {
		return m.ComputeTierPriceList
	}
	return nil
}

// The prices for database related to a specific database tier
type PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry struct {
	// Database tier for which those prices are relevant.
	RelatedDatabaseTier   *EntityDTO               `protobuf:"bytes,1,opt,name=related_database_tier,json=relatedDatabaseTier" json:"related_database_tier,omitempty"`
	DatabaseTierPriceList []*DatabaseTierPriceList `protobuf:"bytes,2,rep,name=database_tier_price_list,json=databaseTierPriceList" json:"database_tier_price_list,omitempty"`
	XXX_unrecognized      []byte                   `json:"-"`
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) Reset() {
	*m = PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry{}
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) String() string {
	return proto.CompactTextString(m)
}
func (*PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) ProtoMessage() {}
func (*PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor8, []int{7, 1, 1}
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) GetRelatedDatabaseTier() *EntityDTO {
	if m != nil {
		return m.RelatedDatabaseTier
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry) GetDatabaseTierPriceList() []*DatabaseTierPriceList {
	if m != nil {
		return m.DatabaseTierPriceList
	}
	return nil
}

// The prices for storage related to a specific storage tier
type PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry struct {
	// Storage tier for which those prices are relevant.
	RelatedStorageTier   *EntityDTO            `protobuf:"bytes,1,opt,name=related_storage_tier,json=relatedStorageTier" json:"related_storage_tier,omitempty"`
	StorageTierPriceList *StorageTierPriceList `protobuf:"bytes,2,opt,name=storage_tier_price_list,json=storageTierPriceList" json:"storage_tier_price_list,omitempty"`
	XXX_unrecognized     []byte                `json:"-"`
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) Reset() {
	*m = PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry{}
}
func (m *PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) String() string {
	return proto.CompactTextString(m)
}
func (*PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) ProtoMessage() {}
func (*PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor8, []int{7, 1, 2}
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) GetRelatedStorageTier() *EntityDTO {
	if m != nil {
		return m.RelatedStorageTier
	}
	return nil
}

func (m *PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry) GetStorageTierPriceList() *StorageTierPriceList {
	if m != nil {
		return m.StorageTierPriceList
	}
	return nil
}

// The reserved instance prices in a specific region.
type PriceTable_ReservedInstancePriceTableByRegionEntry struct {
	// Cloud Region for which those prices are relevant.
	RelatedRegion *EntityDTO `protobuf:"bytes,1,opt,name=related_region,json=relatedRegion" json:"related_region,omitempty"`
	// This map contains the RI specs in this region, with its price associated.
	// The RI spec should be considered as a key in a map, so each spec should only be present once
	// in this whole map.
	ReservedInstancePriceMap []*PriceTable_ReservedInstancePriceEntry `protobuf:"bytes,2,rep,name=reserved_instance_price_map,json=reservedInstancePriceMap" json:"reserved_instance_price_map,omitempty"`
	XXX_unrecognized         []byte                                   `json:"-"`
}

func (m *PriceTable_ReservedInstancePriceTableByRegionEntry) Reset() {
	*m = PriceTable_ReservedInstancePriceTableByRegionEntry{}
}
func (m *PriceTable_ReservedInstancePriceTableByRegionEntry) String() string {
	return proto.CompactTextString(m)
}
func (*PriceTable_ReservedInstancePriceTableByRegionEntry) ProtoMessage() {}
func (*PriceTable_ReservedInstancePriceTableByRegionEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor8, []int{7, 2}
}

func (m *PriceTable_ReservedInstancePriceTableByRegionEntry) GetRelatedRegion() *EntityDTO {
	if m != nil {
		return m.RelatedRegion
	}
	return nil
}

func (m *PriceTable_ReservedInstancePriceTableByRegionEntry) GetReservedInstancePriceMap() []*PriceTable_ReservedInstancePriceEntry {
	if m != nil {
		return m.ReservedInstancePriceMap
	}
	return nil
}

// This entry contains an RISpec with the associated price.
type PriceTable_ReservedInstancePriceEntry struct {
	// the RI spec associated with the price
	ReservedInstanceSpec *ReservedInstanceSpec `protobuf:"bytes,1,opt,name=reserved_instance_spec,json=reservedInstanceSpec" json:"reserved_instance_spec,omitempty"`
	// the price of the RI spec
	ReservedInstancePrice *ReservedInstancePrice `protobuf:"bytes,2,opt,name=reserved_instance_price,json=reservedInstancePrice" json:"reserved_instance_price,omitempty"`
	XXX_unrecognized      []byte                 `json:"-"`
}

func (m *PriceTable_ReservedInstancePriceEntry) Reset()         { *m = PriceTable_ReservedInstancePriceEntry{} }
func (m *PriceTable_ReservedInstancePriceEntry) String() string { return proto.CompactTextString(m) }
func (*PriceTable_ReservedInstancePriceEntry) ProtoMessage()    {}
func (*PriceTable_ReservedInstancePriceEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor8, []int{7, 3}
}

func (m *PriceTable_ReservedInstancePriceEntry) GetReservedInstanceSpec() *ReservedInstanceSpec {
	if m != nil {
		return m.ReservedInstanceSpec
	}
	return nil
}

func (m *PriceTable_ReservedInstancePriceEntry) GetReservedInstancePrice() *ReservedInstancePrice {
	if m != nil {
		return m.ReservedInstancePrice
	}
	return nil
}

func init() {
	proto.RegisterType((*ComputeTierPriceList)(nil), "common_dto.ComputeTierPriceList")
	proto.RegisterType((*ComputeTierPriceList_ComputeTierConfigPrice)(nil), "common_dto.ComputeTierPriceList.ComputeTierConfigPrice")
	proto.RegisterType((*DatabaseTierPriceList)(nil), "common_dto.DatabaseTierPriceList")
	proto.RegisterType((*DatabaseTierPriceList_DatabaseTierConfigPrice)(nil), "common_dto.DatabaseTierPriceList.DatabaseTierConfigPrice")
	proto.RegisterType((*IpPriceList)(nil), "common_dto.IpPriceList")
	proto.RegisterType((*IpPriceList_IpConfigPrice)(nil), "common_dto.IpPriceList.IpConfigPrice")
	proto.RegisterType((*StorageTierPriceList)(nil), "common_dto.StorageTierPriceList")
	proto.RegisterType((*StorageTierPriceList_StorageTierPrice)(nil), "common_dto.StorageTierPriceList.StorageTierPrice")
	proto.RegisterType((*ReservedInstancePrice)(nil), "common_dto.ReservedInstancePrice")
	proto.RegisterType((*Price)(nil), "common_dto.Price")
	proto.RegisterType((*LicensePriceEntry)(nil), "common_dto.LicensePriceEntry")
	proto.RegisterType((*LicensePriceEntry_LicensePrice)(nil), "common_dto.LicensePriceEntry.LicensePrice")
	proto.RegisterType((*PriceTable)(nil), "common_dto.PriceTable")
	proto.RegisterType((*PriceTable_SpotPriceByRegionEntry)(nil), "common_dto.PriceTable.SpotPriceByRegionEntry")
	proto.RegisterType((*PriceTable_OnDemandPriceTableByRegionEntry)(nil), "common_dto.PriceTable.OnDemandPriceTableByRegionEntry")
	proto.RegisterType((*PriceTable_OnDemandPriceTableByRegionEntry_ComputePriceTableByTierEntry)(nil), "common_dto.PriceTable.OnDemandPriceTableByRegionEntry.ComputePriceTableByTierEntry")
	proto.RegisterType((*PriceTable_OnDemandPriceTableByRegionEntry_DatabasePriceTableByTierEntry)(nil), "common_dto.PriceTable.OnDemandPriceTableByRegionEntry.DatabasePriceTableByTierEntry")
	proto.RegisterType((*PriceTable_OnDemandPriceTableByRegionEntry_StoragePriceTableByTierEntry)(nil), "common_dto.PriceTable.OnDemandPriceTableByRegionEntry.StoragePriceTableByTierEntry")
	proto.RegisterType((*PriceTable_ReservedInstancePriceTableByRegionEntry)(nil), "common_dto.PriceTable.ReservedInstancePriceTableByRegionEntry")
	proto.RegisterType((*PriceTable_ReservedInstancePriceEntry)(nil), "common_dto.PriceTable.ReservedInstancePriceEntry")
	proto.RegisterEnum("common_dto.Price_Unit", Price_Unit_name, Price_Unit_value)
}

func init() { proto.RegisterFile("PricingDTO.proto", fileDescriptor8) }

var fileDescriptor8 = []byte{
	// 1529 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x4f, 0x6f, 0x1b, 0xc7,
	0x15, 0xc7, 0x52, 0xa2, 0x44, 0x3d, 0x52, 0x14, 0x35, 0x22, 0x25, 0x76, 0x6d, 0xc1, 0x32, 0x8b,
	0xd6, 0xae, 0x5d, 0x13, 0xb0, 0x51, 0xd8, 0xad, 0xd1, 0x16, 0x95, 0x28, 0xc3, 0x26, 0x2a, 0x99,
	0xea, 0x92, 0x96, 0x6b, 0x1f, 0xba, 0x58, 0xee, 0x8e, 0x88, 0xad, 0xc9, 0xd9, 0xc5, 0xcc, 0xac,
	0x00, 0xe6, 0xe6, 0x24, 0xc8, 0x2d, 0xf7, 0x20, 0x87, 0x9c, 0x72, 0xca, 0x47, 0xc8, 0x25, 0x01,
	0x02, 0x24, 0xc7, 0x9c, 0xf3, 0x51, 0x72, 0x0b, 0xe6, 0xcf, 0x52, 0xbb, 0xe2, 0x52, 0x94, 0xac,
	0xdb, 0xce, 0x7b, 0xef, 0xf7, 0xde, 0xbc, 0xbf, 0xf3, 0x16, 0x2a, 0x47, 0xd4, 0x77, 0x7d, 0x32,
	0xd8, 0xef, 0x75, 0x9a, 0x21, 0x0d, 0x78, 0x80, 0xc0, 0x0d, 0x46, 0xa3, 0x80, 0xd8, 0x1e, 0x0f,
	0x4c, 0xd4, 0x1a, 0x06, 0x91, 0xd7, 0x0a, 0x18, 0x9f, 0xf0, 0xcd, 0xb5, 0x96, 0xe4, 0x4f, 0x08,
	0x8d, 0xaf, 0x17, 0xa0, 0xda, 0x0a, 0x46, 0x61, 0xc4, 0x71, 0xcf, 0xc7, 0x54, 0x28, 0xc4, 0x07,
	0x3e, 0xe3, 0xe8, 0x18, 0xa0, 0xef, 0x30, 0x6c, 0x87, 0x82, 0x52, 0x37, 0x76, 0x8c, 0xbb, 0xc5,
	0x47, 0x4f, 0x9a, 0x67, 0xea, 0x9b, 0x59, 0xa8, 0x24, 0xb1, 0x15, 0x90, 0x13, 0x7f, 0x20, 0x59,
	0xd6, 0x8a, 0x50, 0x25, 0x3f, 0xd1, 0x67, 0x06, 0xfc, 0x3e, 0xc4, 0xd4, 0x76, 0x25, 0x3b, 0xa2,
	0x0e, 0xf7, 0x03, 0xa2, 0xac, 0xd8, 0x8e, 0xf7, 0xff, 0x88, 0xf1, 0x11, 0x26, 0x9c, 0xd5, 0x73,
	0x3b, 0x0b, 0xd7, 0xb1, 0xb8, 0x13, 0xc6, 0x67, 0x6d, 0x42, 0x92, 0x77, 0xcf, 0x0c, 0x98, 0xdf,
	0x18, 0xb0, 0x99, 0x0d, 0x46, 0x8f, 0x61, 0x75, 0x10, 0x61, 0xc6, 0xed, 0x80, 0xd9, 0x7c, 0x1c,
	0x2a, 0xf7, 0xcb, 0x8f, 0x50, 0xf2, 0x32, 0x9d, 0x6e, 0x6f, 0x1c, 0x62, 0xab, 0x28, 0x05, 0x3b,
	0x4c, 0x1c, 0xd0, 0x03, 0x58, 0xe6, 0x98, 0x38, 0xc4, 0x1d, 0xd7, 0x73, 0x12, 0xb1, 0x91, 0x44,
	0xf4, 0x14, 0xcb, 0x8a, 0x65, 0xd0, 0x9f, 0x60, 0x49, 0xfa, 0xcd, 0xea, 0x20, 0x9d, 0x5d, 0x4f,
	0x4a, 0x2b, 0x37, 0xb4, 0x40, 0xe3, 0xd3, 0x3c, 0xd4, 0xf6, 0x1d, 0xee, 0x88, 0x38, 0xa6, 0xf3,
	0xf4, 0xdf, 0x8c, 0x3c, 0xfd, 0x2d, 0xa9, 0x28, 0x13, 0x96, 0xa2, 0xce, 0xc8, 0xd4, 0x7b, 0x03,
	0x6e, 0x5d, 0x2e, 0x4b, 0xd7, 0xb0, 0xb7, 0xed, 0x5e, 0x94, 0x24, 0xd4, 0x82, 0x35, 0x0f, 0x87,
	0xc3, 0x60, 0x2c, 0x8e, 0x2a, 0x17, 0x0b, 0x32, 0xb2, 0x66, 0xca, 0xe4, 0x44, 0x44, 0xe6, 0xa4,
	0xec, 0xa5, 0xce, 0xe6, 0x4f, 0x39, 0xd8, 0x9a, 0x61, 0x1f, 0x3d, 0x81, 0x15, 0xaf, 0x6f, 0x63,
	0x32, 0xf0, 0x49, 0x9c, 0x66, 0x33, 0xcb, 0x9b, 0x67, 0x52, 0xc2, 0x2a, 0x78, 0x7d, 0xf5, 0x85,
	0x9e, 0x02, 0x08, 0xa0, 0xe7, 0x8b, 0x7b, 0xeb, 0x74, 0xdf, 0xc8, 0x44, 0x2a, 0x11, 0x6b, 0xc5,
	0xeb, 0xeb, 0x4f, 0xb4, 0x07, 0x15, 0xaf, 0x6f, 0x0f, 0x7d, 0x17, 0x13, 0x86, 0xed, 0x51, 0xe0,
	0xe1, 0xa1, 0x76, 0xab, 0x9e, 0xd4, 0x70, 0xa0, 0x04, 0x0e, 0x05, 0xdf, 0x2a, 0x7b, 0xfd, 0xe4,
	0x19, 0xbd, 0x00, 0xe4, 0xf5, 0xed, 0xf3, 0xc1, 0x59, 0x9c, 0x1b, 0x9c, 0x8a, 0xd7, 0x4f, 0x53,
	0x12, 0x65, 0x58, 0x9d, 0x57, 0x86, 0x3f, 0x18, 0x50, 0x6c, 0x87, 0x67, 0xc5, 0xf7, 0x2f, 0x28,
	0xf8, 0xe1, 0xa4, 0xf4, 0x04, 0xf8, 0x0f, 0x49, 0x70, 0x42, 0xb4, 0xd9, 0x0e, 0x93, 0x69, 0x5f,
	0xf6, 0x15, 0xcb, 0xa4, 0xb0, 0x9a, 0xe2, 0xa0, 0x06, 0xac, 0x9e, 0x50, 0x8c, 0x6d, 0x3f, 0xb4,
	0xdd, 0x20, 0x22, 0x5c, 0x86, 0x36, 0x6f, 0x15, 0x05, 0x51, 0x48, 0x46, 0x84, 0x5f, 0xa1, 0x71,
	0x10, 0x82, 0xc5, 0x49, 0x07, 0xaf, 0x58, 0xf2, 0xbb, 0xf1, 0x65, 0x0e, 0xaa, 0x5d, 0x1e, 0x50,
	0x67, 0x70, 0xae, 0x97, 0x1c, 0xd8, 0x70, 0xc5, 0xcc, 0xb4, 0x99, 0xe2, 0xa6, 0x3c, 0x7b, 0x98,
	0x34, 0x92, 0x05, 0x9f, 0x22, 0x5a, 0xeb, 0x52, 0x9b, 0x26, 0x2b, 0x7f, 0xbf, 0x32, 0xa0, 0x72,
	0x5e, 0xee, 0x2a, 0xfe, 0xd8, 0xb0, 0x46, 0xb1, 0x17, 0x11, 0x4f, 0x4c, 0x10, 0x95, 0xf3, 0xa2,
	0xcc, 0xf9, 0xe3, 0x24, 0xe6, 0x19, 0xe1, 0x3e, 0x1f, 0x8b, 0x29, 0x7f, 0xec, 0x53, 0x1e, 0x39,
	0xc3, 0xe3, 0x60, 0x18, 0x8d, 0xb0, 0x28, 0xc9, 0xa6, 0x35, 0x81, 0xab, 0x66, 0xa1, 0xa9, 0x73,
	0xe3, 0x3b, 0x03, 0x6a, 0x16, 0x66, 0x98, 0x9e, 0x62, 0xaf, 0x4d, 0x18, 0x77, 0x88, 0x8b, 0x27,
	0x53, 0x31, 0x0a, 0x4f, 0x68, 0x40, 0xb8, 0x8e, 0x0b, 0xc8, 0x61, 0x93, 0x71, 0xd9, 0x92, 0x96,
	0x53, 0xb8, 0xa7, 0xe2, 0xca, 0x6e, 0x44, 0xa9, 0x4f, 0x06, 0x1a, 0x59, 0x9c, 0x85, 0x2c, 0x4f,
	0x24, 0x15, 0xf6, 0x11, 0x14, 0x23, 0x76, 0x96, 0x89, 0xd2, 0x2c, 0x1c, 0x48, 0x29, 0xf9, 0xdd,
	0xf8, 0x38, 0x07, 0x79, 0x85, 0xbe, 0x07, 0x8b, 0x11, 0xf1, 0xb9, 0xee, 0xeb, 0xcd, 0x29, 0x58,
	0xf3, 0x15, 0xf1, 0xb9, 0x25, 0x65, 0xd0, 0x7d, 0x40, 0x98, 0x78, 0x36, 0x75, 0xc8, 0x00, 0xdb,
	0x3e, 0xb1, 0x05, 0x91, 0xd5, 0x97, 0x76, 0x8c, 0xbb, 0x0b, 0xd6, 0x1a, 0x26, 0x9e, 0x25, 0x18,
	0x6d, 0x22, 0x10, 0x0c, 0xfd, 0x03, 0x4a, 0x7a, 0x16, 0x8e, 0x64, 0x8d, 0x6e, 0xca, 0x7b, 0xa5,
	0xda, 0xae, 0x15, 0x51, 0x8a, 0x89, 0x3b, 0xde, 0x95, 0x12, 0x56, 0x51, 0xca, 0xab, 0x43, 0xc3,
	0x81, 0x45, 0xa1, 0x07, 0xad, 0x40, 0xfe, 0x45, 0xe7, 0x95, 0xd5, 0xad, 0x18, 0xa8, 0x00, 0x8b,
	0xfb, 0xbb, 0x6f, 0xba, 0x95, 0x9c, 0x20, 0x1e, 0x76, 0x5e, 0xf6, 0x5e, 0x54, 0x16, 0xc4, 0x67,
	0xaf, 0xd3, 0xdb, 0x3d, 0xa8, 0x00, 0xaa, 0x40, 0xe9, 0xb0, 0x7d, 0x70, 0xd0, 0xee, 0xbc, 0xb4,
	0xdb, 0x9d, 0xa3, 0x6e, 0xa5, 0x8a, 0x4a, 0x50, 0x78, 0xbe, 0x67, 0x2b, 0xd1, 0x1a, 0x2a, 0x03,
	0x1c, 0xee, 0x1d, 0x75, 0xf5, 0x79, 0xb3, 0xf1, 0x45, 0x0e, 0xd6, 0xf5, 0xbc, 0x90, 0xae, 0x3e,
	0x23, 0x9c, 0x8e, 0xd1, 0x7d, 0x58, 0x9e, 0xff, 0xa4, 0x2d, 0x05, 0xea, 0x35, 0xfb, 0x0f, 0x94,
	0xe3, 0x11, 0xa5, 0xab, 0x53, 0x4d, 0xfb, 0x7b, 0x19, 0x33, 0xea, 0xcc, 0x46, 0x8a, 0x62, 0xad,
	0x0e, 0x13, 0x27, 0x86, 0x1a, 0x50, 0xea, 0x47, 0x94, 0x71, 0xa7, 0x3f, 0xc4, 0xad, 0xa3, 0x57,
	0x72, 0xe8, 0x15, 0xac, 0x14, 0xcd, 0xb4, 0xa1, 0x94, 0x54, 0x81, 0xfe, 0x08, 0x6b, 0x24, 0x1a,
	0xf5, 0x31, 0xb5, 0x83, 0x13, 0xdb, 0x0d, 0x28, 0x66, 0xf2, 0xee, 0x79, 0x6b, 0x55, 0x91, 0x3b,
	0x27, 0x2d, 0x41, 0x44, 0x77, 0x20, 0x3f, 0xa7, 0x2c, 0x15, 0xbf, 0xf1, 0x79, 0x15, 0x40, 0x12,
	0x7a, 0xc2, 0x24, 0xaa, 0xc3, 0xf2, 0x29, 0xa6, 0x4c, 0x4c, 0x71, 0x35, 0x24, 0xe2, 0x23, 0x7a,
	0x0e, 0x15, 0x95, 0x65, 0x79, 0x37, 0xfb, 0x1d, 0x1e, 0xb3, 0x7a, 0x41, 0x86, 0x60, 0xfb, 0xbc,
	0x72, 0x9f, 0x0c, 0xda, 0x1e, 0x26, 0xdc, 0x3f, 0xf1, 0x31, 0xb5, 0xca, 0xe1, 0x44, 0xfd, 0xbf,
	0xf1, 0x98, 0x21, 0x1f, 0x6a, 0x42, 0x16, 0x8f, 0x1c, 0xe2, 0xd9, 0x09, 0x95, 0x3a, 0xa0, 0x8f,
	0xa7, 0xae, 0x2a, 0xa1, 0xcd, 0x0e, 0xd9, 0x97, 0x90, 0x33, 0xd2, 0xde, 0xd8, 0xc2, 0x03, 0x3f,
	0x20, 0x32, 0xd2, 0x16, 0x0a, 0xa6, 0x04, 0xd0, 0x6b, 0xa8, 0xb0, 0x30, 0xe0, 0x29, 0x2b, 0x8b,
	0xd2, 0xca, 0x83, 0x19, 0x56, 0xba, 0x61, 0xa0, 0x1a, 0x35, 0xad, 0xbc, 0xcc, 0x62, 0xba, 0x52,
	0xfc, 0xde, 0x80, 0x6d, 0xaa, 0xe7, 0x82, 0xed, 0xeb, 0xc1, 0x90, 0x32, 0x93, 0x97, 0x66, 0xfe,
	0x39, 0xc3, 0x4c, 0xe6, 0x4c, 0xc9, 0x70, 0xca, 0xa4, 0x33, 0x05, 0x91, 0x0d, 0xdb, 0x67, 0x71,
	0x4c, 0xd5, 0xa6, 0xbe, 0xc2, 0xd2, 0x74, 0x76, 0xa6, 0x0a, 0xd4, 0xfa, 0x5d, 0x1c, 0xb6, 0x24,
	0x4b, 0x19, 0xf8, 0x1f, 0xdc, 0x9c, 0xf8, 0x98, 0xa5, 0x7f, 0xf9, 0x52, 0xfa, 0x63, 0x15, 0xd3,
	0xfa, 0xff, 0x0c, 0xeb, 0x82, 0xe5, 0x0b, 0xaf, 0x82, 0x53, 0xdf, 0xc3, 0xb4, 0xed, 0xd5, 0x57,
	0x64, 0xd5, 0x4d, 0x33, 0xcc, 0x6f, 0x73, 0xb0, 0x99, 0x9d, 0x1d, 0xf4, 0x77, 0x28, 0x53, 0x3c,
	0x74, 0x38, 0xf6, 0x6c, 0x2a, 0xc9, 0x7a, 0xf3, 0xab, 0x65, 0xbe, 0x02, 0xd6, 0xaa, 0x16, 0x56,
	0x2a, 0xd0, 0x5f, 0xa1, 0x14, 0xa3, 0x3f, 0x0a, 0x08, 0x96, 0x4f, 0xec, 0x4c, 0x6c, 0x51, 0x8b,
	0xbe, 0x0d, 0x08, 0x46, 0xcf, 0xa1, 0x1a, 0x23, 0x5d, 0xb5, 0x3b, 0xdb, 0xdc, 0xc7, 0x54, 0x36,
	0xf2, 0x4c, 0x0d, 0x48, 0x43, 0x12, 0xdb, 0xf6, 0xf4, 0x8a, 0xbd, 0x78, 0xb9, 0x15, 0xfb, 0xb2,
	0x5d, 0x6e, 0xfe, 0x5a, 0x80, 0x5b, 0x73, 0x1a, 0xe8, 0x9a, 0x51, 0xfc, 0xc4, 0x80, 0x8d, 0x38,
	0x08, 0xd3, 0x4d, 0xdd, 0xfd, 0xb0, 0xa6, 0x8e, 0xff, 0x67, 0x92, 0x6c, 0x11, 0x30, 0x55, 0x5a,
	0xeb, 0xee, 0x79, 0xae, 0xf8, 0x9f, 0xaa, 0x7a, 0x7a, 0xd5, 0x4c, 0x5d, 0x63, 0x41, 0x5e, 0xa3,
	0xf7, 0x81, 0xd7, 0x88, 0xb7, 0xd7, 0xec, 0x7b, 0x20, 0x6f, 0x8a, 0x2d, 0xc3, 0x91, 0xda, 0x9b,
	0x52, 0xd3, 0xe7, 0x43, 0xc3, 0x91, 0x5c, 0x9e, 0xa6, 0xc3, 0xc1, 0xce, 0x73, 0xd1, 0x5f, 0x60,
	0x25, 0xde, 0x48, 0x59, 0x3d, 0x2f, 0xb3, 0xb9, 0x35, 0x63, 0x25, 0xb5, 0x0a, 0x7a, 0x09, 0x65,
	0xe6, 0xf7, 0x06, 0xdc, 0xbc, 0x28, 0xf0, 0x33, 0xeb, 0xde, 0xb8, 0x6a, 0xdd, 0xbf, 0x86, 0xad,
	0xa4, 0x02, 0x1d, 0xa9, 0xa1, 0xcf, 0xb8, 0xee, 0xc2, 0x9d, 0x79, 0x7f, 0xbc, 0x56, 0xd5, 0xcd,
	0xa0, 0x9a, 0x3f, 0x1a, 0xb0, 0x7d, 0x61, 0xd2, 0x50, 0x1b, 0x6a, 0xb1, 0x0f, 0x93, 0x82, 0x99,
	0xef, 0xc4, 0x86, 0xc6, 0x24, 0x7f, 0xa0, 0xd0, 0x5b, 0xa8, 0xa7, 0x54, 0xa4, 0xdd, 0x10, 0xf9,
	0xbe, 0x3d, 0xf7, 0x97, 0xd0, 0xaa, 0x79, 0x59, 0x64, 0x99, 0x8b, 0x8b, 0xb2, 0x9e, 0xcc, 0x45,
	0x5c, 0x6f, 0x97, 0xcf, 0x45, 0x62, 0xf7, 0x16, 0xb9, 0x48, 0x2a, 0x98, 0x93, 0x8b, 0xac, 0x95,
	0xdf, 0xaa, 0xb2, 0x0c, 0xaa, 0xf9, 0x8b, 0x01, 0x77, 0x2e, 0xf9, 0xde, 0x5d, 0x73, 0x06, 0x85,
	0x70, 0x63, 0xd6, 0xa3, 0x3c, 0x72, 0x42, 0x9d, 0x8b, 0x87, 0x57, 0x79, 0x92, 0x55, 0x67, 0xd5,
	0x33, 0x5f, 0xe1, 0x43, 0x27, 0x34, 0x7f, 0x36, 0xc0, 0x9c, 0x0d, 0x44, 0xc7, 0xb0, 0x39, 0x7d,
	0x21, 0x16, 0x62, 0x57, 0xbb, 0x95, 0x0a, 0xe9, 0x79, 0x3d, 0xdd, 0x10, 0xbb, 0x56, 0x95, 0x66,
	0x50, 0xd1, 0x1b, 0xd8, 0x9a, 0xe1, 0xa8, 0xce, 0xd5, 0xed, 0x8b, 0x14, 0xab, 0x97, 0xa1, 0x96,
	0xe9, 0xd4, 0xde, 0x6d, 0xb8, 0xe5, 0x06, 0xa3, 0xe6, 0xe9, 0x88, 0x47, 0xb4, 0x1f, 0x34, 0xc3,
	0xa1, 0xc3, 0x4f, 0x02, 0x3a, 0x6a, 0x32, 0xef, 0x9d, 0xd6, 0xf9, 0x5b, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xc4, 0x4d, 0x8b, 0x4d, 0x69, 0x13, 0x00, 0x00,
}
